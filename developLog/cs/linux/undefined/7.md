---
icon: '7'
---

# 7장 : 파일시스템

## 개요&#x20;

6장에서 각종 장치는 `디바이스 파일`로 접근 가능하다고 설명했습니다. 하지만 <mark style="color:red;">대부분의 저장</mark>\ <mark style="color:red;">장치는 이 장에서 설명하는</mark> <mark style="color:red;"></mark><mark style="color:red;">`파일 시스템`</mark><mark style="color:red;">으로 접근 가능</mark>합니다.



### 1) 파일 시스템이 존재하지 않는다면?

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

* 데이터를 <mark style="color:blue;">디스크 어떤 위치에 저장할지 직접</mark> 정해야 합니다
*  다른 데이터를 훼손하지 않도록 <mark style="color:blue;">비어 있는 영역도 관리</mark>가 필요
* 쓰기가 끝나  서 나중에 다시 읽어오려면 어느 위치에 파일 크기가 얼마이고, 어떤 데이터를 배치했는지 기  \
  억해야 함

### 2) 이런 일을 대신 해준다! 파일 시스템

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

> 파일 시스템은 위의  정보를 대신해서 관리

* 파일 시스템은 사용자에게 의미 있는 <mark style="color:blue;">데이  터 뭉치를</mark> <mark style="color:blue;"></mark><mark style="color:blue;">`파일 단위`</mark><mark style="color:blue;">로 관리</mark>
* 각각의 데이터가 어디에 있는지 사용자가 직접 관리하지 않  아도 <mark style="color:blue;">저장 장치의 관리 영역에 기록</mark>됩니다

{% hint style="danger" %}
파일 시스템은 **운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘**입니다.
{% endhint %}

파일 형식으로 데이터를 관리하는 `저장 장치`**의 영역**(관리 영역 포함)과 해당 `저장 영역을 다루는 처리`(그림에서 '파일 시스템 코드) 양쪽을 모두 합쳐서 **파**\
**일 시스템**이라고 부릅니다.

> 잘 정리 되어 있는 곳 발견! : [https://www.fun-coding.org/post/filesystem.html#gsc.tab=0](https://www.fun-coding.org/post/filesystem.html#gsc.tab=0)

### 3) 디바이스 파일과 파일 시스템으로 저장 장치에 접근하기

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>



#### 🛤️ 그림 07-03 해석: 디바이스 파일 vs 파일 시스템을 통한 저장 장치 접근

| 구분 | 디바이스 파일 공유해서 접근                         | 파일 시스템 공유해서 접근                                       |
| -- | --------------------------------------- | ---------------------------------------------------- |
| 흐름 | 프로세스 → 디바이스 파일 → 디바이스 드라이버 → 저장 장치      | 프로세스 → 파일 시스템에 있는 파일 → 파일 시스템 코드 → 디바이스 드라이버 → 저장 장치 |
| 목적 | 저장 장치 **특정 주소**(예: 70GiB\~80GiB)로 바로 접근 | **파일 이름**(ex. `/home/test.txt`)을 통해 접근               |
| 특징 | - 파일 시스템 없이 직접 저장장치 영역을 다룸- 파일 손상 위험 있음 | - 파일 시스템이 중간에 있으므로 사용 편리- 안정성과 데이터 보호 기능을 제공         |

#### 왼쪽 (디바이스 파일 공유해서 접근)

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

1. **프로세스**가 직접 디바이스 파일(ex. `/dev/sda`)에 접근합니다.
2. **"70GiB\~80GiB 영역을 읽어주세요!"** 같은 식으로 "주소 기반" 요청을 보냅니다.
3. **디바이스 드라이버**가 이 요청을 받아서 장치에 직접 명령을 내립니다.
4. 저장 장치에서 데이터가 읽힙니다.

> ➡️ **파일 시스템을 거치지 않기 때문에**, 사용자가 잘못 접근하면 **파일 시스템 구조를 깨버릴 수 있음**.

#### 오른쪽 (파일 시스템 공유해서 접근)

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

1. **프로세스**가 파일 이름(예: `/home/test.txt`)을 열려고 합니다.
2. 커널의 **파일 시스템 코드**가 동작합니다. ("이 파일은 저장 장치의 어느 주소에 있을까?")
3. 파일 시스템이 **주소(70GiB\~80GiB)**&#xB85C; 매핑해서 **디바이스 드라이버**에 전달합니다.
4. 디바이스 드라이버가 실제 장치에서 데이터를 읽어옵니다.

> ➡️ **파일 이름만 알면** 복잡한 저장소 구조를 몰라도 되고, **데이터 안전성**도 높습니다.

#### 📚 요약 정리

| 비교 항목  | 디바이스 파일 직접 접근     | 파일 시스템 경유 접근    |
| ------ | ----------------- | --------------- |
| 접근 방식  | 장치 주소 기반          | 파일 이름 기반        |
| 중간 매개체 | 없음 (파일 시스템 무시)    | 파일 시스템이 매개      |
| 위험성    | 높음 (파일 깨짐 가능)     | 낮음 (파일 시스템이 관리) |
| 사용 예시  | 복구 작업, 저수준 디스크 조작 | 일반 파일 읽기/쓰기 작업  |

#### ✨ 비유하자면

<figure><img src="../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

* **디바이스 파일 접근**: "창고에 들어가서 직접 원하는 박스를 꺼내오는 것"
* **파일 시스템 접근**: "창고 관리자에게 '책상 위 서랍 속 파란 파일' 요청하는 것"



### 4) 파일 시스템의 트리 구조

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption><p><a href="https://rebugs.tistory.com/767">https://rebugs.tistory.com/767</a></p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption><p>실제 느낌으로 보자면</p></figcaption></figure>

* 리눅스 파일 시스템은 각 파일을 `디렉터리`라고 하는 **특수한 파일을 사용해서 분류**할 수  &#x20;있습니다.&#x20;
* 디렉터리가 다르면 동일한 파일명을 사용할 수 있습니다.&#x20;
* 또한 디렉터리 안에 또 다  시 디렉터리를 만들어서 트리 구조를 만들 수 있습니다.

{% hint style="warning" %}
리눅스 파일 시스템은 **계층적 구조**를 사용하여 트리 모양으로 이루어져 있습니다.

루트 디렉토리(/)를 **최상위 디렉토리**로 시작하여 **그 아래에 다양한 디렉토리와 파일들이 존재**합니다.
{% endhint %}

### 5) 파일 시스템의 두 얼굴: 데이터와 메타 데이터

파일 시스템 안에는 **두 가지 종류의 데이터**가 존재합니다.

#### 데이터(Data)

* 사용자가 직접 작성하거나 저장한 **문서, 이미지, 동영상, 프로그램 파일** 같은 실제 정보입니다.
* 우리가 직접 보고 사용하는 '콘텐츠'에 해당합니다.

#### 메타 데이터(Meta Data)

* 파일을 효율적으로 관리하기 위해 **파일 시스템 내부에 저장된 부가적인 정보**입니다.
* 사용자에게는 보이지 않는, '파일을 설명하고 관리하는 정보'라고 생각하면 됩니다.

#### 주요 메타 데이터 종류

| 종류         | 설명                                 |
| ---------- | ---------------------------------- |
| 파일 이름      | 파일을 식별할 수 있는 이름                    |
| 저장 위치 및 크기 | 저장 장치 내에서 파일이 저장된 실제 위치와 크기        |
| 파일 종류      | 일반 파일, 디렉터리, 디바이스 파일 등 어떤 종류인지     |
| 파일 시간 정보   | 파일 생성, 최종 수정, 최종 접근 날짜와 시간         |
| 파일 권한 정보   | 누가 파일을 읽고, 쓰고, 실행할 수 있는지에 대한 권한 설정 |
| 디렉터리 데이터   | 디렉터리 내부에 포함된 파일 목록과 그 구조           |

> **데이터는 우리가 쓰는 내용, 메타 데이터는 파일 시스템이 파일을 관리하기 위한 비서 노트!**

### 6) 메타 데이터가 중요한 이유

1\. 빠른 파일 탐색을 가능하게 한다

* 파일 시스템은 "메타 데이터"를 통해 **파일 이름 → 저장 위치**를 빠르게 찾아낼 수 있어요.
* 만약 메타 데이터가 없다면, 파일을 찾으려고 **디스크 전체를 뒤져야 하는 대참사**가 벌어집니다.

{% hint style="danger" %}
비유하자면,

* 메타 데이터가 있는 경우 = "도서관 사서가 책 번호를 알려줘서 바로 찾음"
* 메타 데이터가 없는 경우 = "도서관 책장을 하나하나 다 뒤져야 함"
{% endhint %}

#### 2. 파일 권한과 보안을 책임진다

* 메타 데이터 안에는 파일 소유자, 읽기/쓰기/실행 권한 정보가 들어 있습니다.
* 이 덕분에 파일마다 "**누가 접근할 수 있는지**"를 구체적으로 설정할 수 있어요.

{% hint style="warning" %}
예를 들면, 회사 서버의 중요 문서 파일이 아무나 읽지 못하도록 막는 것도 모두 메타 데이터의 '권한 설정' 덕분입니다.
{% endhint %}

#### 3. 파일 복구에도 꼭 필요하다

* 디스크에 문제가 생겼을 때, 복구 프로그램은 메타 데이터를 읽어서 파일 구조를 복구해요.
* 메타 데이터가 손상되면 **파일은 살아 있어도 무용지물**이 될 수 있습니다.

{% hint style="info" %}
마치, **지도 없이 무인도에 떨어진** 것과 같아요.\
(파일이 어디 있는지 알 방법이 없어짐!)
{% endhint %}

#### 요약 정리

| 역할    | 설명            |
| ----- | ------------- |
| 파일 탐색 | 빠른 위치 찾기      |
| 파일 보호 | 접근 권한 설정      |
| 파일 복구 | 복구 시 필수 정보 제공 |

> **메타 데이터는 파일 시스템의 뇌이자, 보안관이자, 구조대장이다!**

### 7) 메타 데이터의 실제 구조: 파일 시스템 안의 숨은 설계도

파일 시스템은 메타 데이터를 저장할 때 두 가지 중요한 구조를 사용합니다:

#### 1. **inode (아이노드)**: 파일 자체의 정보

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption><p><a href="https://jdcyber.tistory.com/87">https://jdcyber.tistory.com/87</a></p></figcaption></figure>

* 아이노드(i-node)는 리눅스 파일 시스템에서 사용되는 데이터 구조
* **파일의 진짜 몸통**을 담당하는 데이터 구조입니다.
* 하나의 파일이나 디렉터리마다 **하나의 inode**가 존재해요.

{% hint style="success" %}
간단히 말하면, 파일에 대한 중요한 정보를 담고 있는 **"주민등록증" 같은 역할**을 합니다.

이 아이노드는 파일이 실제로 어디에 저장되어 있는지, 파일의 크기, 수정 시간 등 **파일에 관한 다양한 정보를 관리**합니다.
{% endhint %}

**inode에는 어떤 정보가 들어 있을까요?**

| 항목                | 설명                                        |
| ----------------- | ----------------------------------------- |
| 파일 소유권과 접근 권한     | 파일을 누가 소유하고 있는지, 어떤 권한(읽기/쓰기/실행)을 가지고 있는지 |
| 파일 내용이 저장된 물리적 주소 | 파일의 데이터가 실제로 저장된 저장 장치의 위치 정보             |
| 파일의 링크 수          | 해당 파일을 참조하고 있는 링크(하드 링크)의 개수              |
| 파일의 크기            | 파일이 차지하는 전체 용량                            |
| 파일 생성 시간          | 파일이 처음 만들어진 시각                            |
| 최근 사용 시간          | 파일이 마지막으로 읽히거나 접근된 시각                     |
| 최근 수정 시간          | 파일의 내용이 마지막으로 수정된 시각                      |
| 아이노드의 최근 수정 시간    | 파일 내용이 아닌 아이노드(메타데이터) 자체가 수정된 시각          |

> 🧩 **inode는 파일 내용을 직접 저장하지 않고**, "내용은 어디에 저장되어 있다"는 **주소**만 관리해요.
>
> 이 정보들은 파일 시스템에서 파일이 어떻게 저장되고 관리되는지에 대한 중요한 정보를 제공합니다!

아이노드의 예제

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption><p><a href="https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C">https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C</a></p></figcaption></figure>

내 컴퓨터에서 엄청 큰 파일이 있다 가정해봅시다.

컴퓨터의 용량이 부족해서, 이 파일을 휴지통에 버렸을 **때 내 드라이브의 용량이 줄지 않은 것을 확인** 해 본 적이 있을 것입니다.

`휴지통에서 완전히 비우기`를 했을 때, **비로소 그 파일 만큼의 용량이 확보되는것을 확인**해 볼 수 있다.

이처럼 파일을 <mark style="color:red;">휴지통에만 버린 것이 특정 파일의 inode를 삭제</mark>한 것입니다. **(위치값만 삭제한 것)**

> 즉, inode는 위치값만 전달하는 노드이며 그렇기 때문에 DNS Server와 비슷한 역할을 한다 말한 것입니다.

출처 : [https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C](https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C)

#### 2. **디렉터리 엔트리 (Directory Entry)**: 이름을 붙여주는 표

* 디렉터리는 일종의 **파일 목록표**입니다.
* "파일 이름"과 "inode 번호"를 짝지어서 기록해둡니다.

**구성 예시**

| 파일 이름       | inode 번호 |
| ----------- | -------- |
| hello.txt   | 1024     |
| picture.png | 1025     |
| my\_folder  | 1026     |

> 📂 즉, **디렉터리**는 "파일 이름 → inode 번호"를 알려주는 지도 역할을 해요.

#### 전체 구조 그림으로 표현하면

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

```
[디렉터리] ──> 파일 이름, inode 번호
[inode] ──> 파일 속성, 실제 데이터 위치
```

* 디렉터리가 이름을 알려주고,
* inode가 진짜 몸통(속성 + 위치)을 관리하는 방식!

#### 비유로 다시 한 번 정리

| 비유    | 설명                      |
| ----- | ----------------------- |
| 디렉터리  | 백화점 안내판 (매장 이름 + 매장 번호) |
| inode | 각 매장의 실제 위치와 정보         |

> **inode와 디렉터리 엔트리는 파일 시스템의 두 날개!**\
> **하나라도 없으면 파일을 찾을 수도, 관리할 수도 없다!**

### 8) 아이노드의 구성

> 출처 : [https://jdcyber.tistory.com/87](https://jdcyber.tistory.com/87)

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

아이노드는 **64바이트 크기의 표**로, **파일에 대한 모든 정보**를 담고 있습니다.

그리고 이 아이노드들은 <mark style="color:red;">아이노드 블록에 저장</mark>되며, <mark style="color:blue;">전체 디스크의 약 1% 정도를 차지</mark>합니다.

파일이나 디렉토리가 생성되면, **해당 파일을 관리할 아이노드**가 만들어지고, 이 아이노드는 `아이노드 테이블에 등록`되어 관리됩니다.

* 아이노드(inode): 파일이나 디렉토리의 중요한 정보를 담고 있는 64바이트 크기의 데이터 구조입니다.
* 아이노드 테이블(inode table): 시스템 내의 모든 파일과 디렉토리의 아이노드를 관리하는 표입니다.
* 아이노드 번호(inumber): 아이노드가 아이노드 테이블에서 고유하게 등록된 번호입니다.

#### 아이노드 테이블

> 아이노드 테이블은 파일 시스템에서 **파일이나 디렉토리들이 어디에 저장되고 있는지 추적하는 역할**을 합니다.&#x20;

파일이나 디렉토리가 생성되면, 아이노드 번호는 i-list라는 표에 등록되고, 이 번호를 통해 해당 파일에 대한 정보를 빠르게 찾을 수 있습니다.
