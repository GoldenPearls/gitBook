---
icon: '7'
---

# 7장 : 파일시스템

##

##

## 1. 개요&#x20;

6장에서 각종 장치는 `디바이스 파일`로 접근 가능하다고 설명했습니다. 하지만 <mark style="color:red;">대부분의 저장</mark>\ <mark style="color:red;">장치는 이 장에서 설명하는</mark> <mark style="color:red;"></mark><mark style="color:red;">`파일 시스템`</mark><mark style="color:red;">으로 접근 가능</mark>합니다.



### 1) 파일 시스템이 존재하지 않는다면?

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

* 데이터를 <mark style="color:blue;">디스크 어떤 위치에 저장할지 직접</mark> 정해야 합니다
*  다른 데이터를 훼손하지 않도록 <mark style="color:blue;">비어 있는 영역도 관리</mark>가 필요
* 쓰기가 끝나  서 나중에 다시 읽어오려면 어느 위치에 파일 크기가 얼마이고, 어떤 데이터를 배치했는지 기  \
  억해야 함

### 2) 이런 일을 대신 해준다! 파일 시스템

<figure><img src="../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

> 파일 시스템은 위의  정보를 대신해서 관리

* 파일 시스템은 사용자에게 의미 있는 <mark style="color:blue;">데이  터 뭉치를</mark> <mark style="color:blue;"></mark><mark style="color:blue;">`파일 단위`</mark><mark style="color:blue;">로 관리</mark>
* 각각의 데이터가 어디에 있는지 사용자가 직접 관리하지 않  아도 <mark style="color:blue;">저장 장치의 관리 영역에 기록</mark>됩니다

{% hint style="danger" %}
파일 시스템은 **운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘**입니다.
{% endhint %}

파일 형식으로 데이터를 관리하는 `저장 장치`**의 영역**(관리 영역 포함)과 해당 `저장 영역을 다루는 처리`(그림에서 '파일 시스템 코드) 양쪽을 모두 합쳐서 **파**\
**일 시스템**이라고 부릅니다.

> 잘 정리 되어 있는 곳 발견! : [https://www.fun-coding.org/post/filesystem.html#gsc.tab=0](https://www.fun-coding.org/post/filesystem.html#gsc.tab=0)

### 3) 디바이스 파일과 파일 시스템으로 저장 장치에 접근하기

<figure><img src="../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>



#### 🛤️ 그림 07-03 해석: 디바이스 파일 vs 파일 시스템을 통한 저장 장치 접근

| 구분 | 디바이스 파일 공유해서 접근                         | 파일 시스템 공유해서 접근                                       |
| -- | --------------------------------------- | ---------------------------------------------------- |
| 흐름 | 프로세스 → 디바이스 파일 → 디바이스 드라이버 → 저장 장치      | 프로세스 → 파일 시스템에 있는 파일 → 파일 시스템 코드 → 디바이스 드라이버 → 저장 장치 |
| 목적 | 저장 장치 **특정 주소**(예: 70GiB\~80GiB)로 바로 접근 | **파일 이름**(ex. `/home/test.txt`)을 통해 접근               |
| 특징 | - 파일 시스템 없이 직접 저장장치 영역을 다룸- 파일 손상 위험 있음 | - 파일 시스템이 중간에 있으므로 사용 편리- 안정성과 데이터 보호 기능을 제공         |

#### 왼쪽 (디바이스 파일 공유해서 접근)

<figure><img src="../../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

1. **프로세스**가 직접 디바이스 파일(ex. `/dev/sda`)에 접근합니다.
2. **"70GiB\~80GiB 영역을 읽어주세요!"** 같은 식으로 "주소 기반" 요청을 보냅니다.
3. **디바이스 드라이버**가 이 요청을 받아서 장치에 직접 명령을 내립니다.
4. 저장 장치에서 데이터가 읽힙니다.

> ➡️ **파일 시스템을 거치지 않기 때문에**, 사용자가 잘못 접근하면 **파일 시스템 구조를 깨버릴 수 있음**.

#### 오른쪽 (파일 시스템 공유해서 접근)

<figure><img src="../../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

1. **프로세스**가 파일 이름(예: `/home/test.txt`)을 열려고 합니다.
2. 커널의 **파일 시스템 코드**가 동작합니다. ("이 파일은 저장 장치의 어느 주소에 있을까?")
3. 파일 시스템이 **주소(70GiB\~80GiB)**&#xB85C; 매핑해서 **디바이스 드라이버**에 전달합니다.
4. 디바이스 드라이버가 실제 장치에서 데이터를 읽어옵니다.

> ➡️ **파일 이름만 알면** 복잡한 저장소 구조를 몰라도 되고, **데이터 안전성**도 높습니다.

#### 📚 요약 정리

| 비교 항목  | 디바이스 파일 직접 접근     | 파일 시스템 경유 접근    |
| ------ | ----------------- | --------------- |
| 접근 방식  | 장치 주소 기반          | 파일 이름 기반        |
| 중간 매개체 | 없음 (파일 시스템 무시)    | 파일 시스템이 매개      |
| 위험성    | 높음 (파일 깨짐 가능)     | 낮음 (파일 시스템이 관리) |
| 사용 예시  | 복구 작업, 저수준 디스크 조작 | 일반 파일 읽기/쓰기 작업  |

#### ✨ 비유하자면

<figure><img src="../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

* **디바이스 파일 접근**: "창고에 들어가서 직접 원하는 박스를 꺼내오는 것"
* **파일 시스템 접근**: "창고 관리자에게 '책상 위 서랍 속 파란 파일' 요청하는 것"



### 4) 파일 시스템의 트리 구조

<figure><img src="../../../.gitbook/assets/image (3) (1).png" alt=""><figcaption><p><a href="https://rebugs.tistory.com/767">https://rebugs.tistory.com/767</a></p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (4) (1).png" alt=""><figcaption><p>실제 느낌으로 보자면</p></figcaption></figure>

* 리눅스 파일 시스템은 각 파일을 `디렉터리`라고 하는 **특수한 파일을 사용해서 분류**할 수  &#x20;있습니다.&#x20;
* 디렉터리가 다르면 동일한 파일명을 사용할 수 있습니다.&#x20;
* 또한 디렉터리 안에 또 다  시 디렉터리를 만들어서 트리 구조를 만들 수 있습니다.

{% hint style="warning" %}
리눅스 파일 시스템은 **계층적 구조**를 사용하여 트리 모양으로 이루어져 있습니다.

루트 디렉토리(/)를 **최상위 디렉토리**로 시작하여 **그 아래에 다양한 디렉토리와 파일들이 존재**합니다.
{% endhint %}

### 5) 파일 시스템의 두 얼굴: 데이터와 메타 데이터

파일 시스템 안에는 **두 가지 종류의 데이터**가 존재합니다.

#### 데이터(Data)

* 사용자가 직접 작성하거나 저장한 **문서, 이미지, 동영상, 프로그램 파일** 같은 실제 정보입니다.
* 우리가 직접 보고 사용하는 '콘텐츠'에 해당합니다.

#### 메타 데이터(Meta Data)

* 파일을 효율적으로 관리하기 위해 **파일 시스템 내부에 저장된 부가적인 정보**입니다.
* 사용자에게는 보이지 않는, '파일을 설명하고 관리하는 정보'라고 생각하면 됩니다.

#### 주요 메타 데이터 종류

| 종류         | 설명                                 |
| ---------- | ---------------------------------- |
| 파일 이름      | 파일을 식별할 수 있는 이름                    |
| 저장 위치 및 크기 | 저장 장치 내에서 파일이 저장된 실제 위치와 크기        |
| 파일 종류      | 일반 파일, 디렉터리, 디바이스 파일 등 어떤 종류인지     |
| 파일 시간 정보   | 파일 생성, 최종 수정, 최종 접근 날짜와 시간         |
| 파일 권한 정보   | 누가 파일을 읽고, 쓰고, 실행할 수 있는지에 대한 권한 설정 |
| 디렉터리 데이터   | 디렉터리 내부에 포함된 파일 목록과 그 구조           |

> **데이터는 우리가 쓰는 내용, 메타 데이터는 파일 시스템이 파일을 관리하기 위한 비서 노트!**

### 6) 메타 데이터가 중요한 이유

1\. 빠른 파일 탐색을 가능하게 한다

* 파일 시스템은 "메타 데이터"를 통해 **파일 이름 → 저장 위치**를 빠르게 찾아낼 수 있어요.
* 만약 메타 데이터가 없다면, 파일을 찾으려고 **디스크 전체를 뒤져야 하는 대참사**가 벌어집니다.

{% hint style="danger" %}
비유하자면,

* 메타 데이터가 있는 경우 = "도서관 사서가 책 번호를 알려줘서 바로 찾음"
* 메타 데이터가 없는 경우 = "도서관 책장을 하나하나 다 뒤져야 함"
{% endhint %}

#### 2. 파일 권한과 보안을 책임진다

* 메타 데이터 안에는 파일 소유자, 읽기/쓰기/실행 권한 정보가 들어 있습니다.
* 이 덕분에 파일마다 "**누가 접근할 수 있는지**"를 구체적으로 설정할 수 있어요.

{% hint style="warning" %}
예를 들면, 회사 서버의 중요 문서 파일이 아무나 읽지 못하도록 막는 것도 모두 메타 데이터의 '권한 설정' 덕분입니다.
{% endhint %}

#### 3. 파일 복구에도 꼭 필요하다

* 디스크에 문제가 생겼을 때, 복구 프로그램은 메타 데이터를 읽어서 파일 구조를 복구해요.
* 메타 데이터가 손상되면 **파일은 살아 있어도 무용지물**이 될 수 있습니다.

{% hint style="info" %}
마치, **지도 없이 무인도에 떨어진** 것과 같아요.\
(파일이 어디 있는지 알 방법이 없어짐!)
{% endhint %}

#### 요약 정리

| 역할    | 설명            |
| ----- | ------------- |
| 파일 탐색 | 빠른 위치 찾기      |
| 파일 보호 | 접근 권한 설정      |
| 파일 복구 | 복구 시 필수 정보 제공 |

> **메타 데이터는 파일 시스템의 뇌이자, 보안관이자, 구조대장이다!**

### 7) 메타 데이터의 실제 구조: 파일 시스템 안의 숨은 설계도

파일 시스템은 메타 데이터를 저장할 때 두 가지 중요한 구조를 사용합니다:

#### 1. **inode (아이노드)**: 파일 자체의 정보

<figure><img src="../../../.gitbook/assets/image (8) (1).png" alt=""><figcaption><p><a href="https://jdcyber.tistory.com/87">https://jdcyber.tistory.com/87</a></p></figcaption></figure>

* 아이노드(i-node)는 리눅스 파일 시스템에서 사용되는 데이터 구조
* **파일의 진짜 몸통**을 담당하는 데이터 구조입니다.
* 하나의 파일이나 디렉터리마다 **하나의 inode**가 존재해요.

{% hint style="success" %}
간단히 말하면, 파일에 대한 중요한 정보를 담고 있는 **"주민등록증" 같은 역할**을 합니다.

이 아이노드는 파일이 실제로 어디에 저장되어 있는지, 파일의 크기, 수정 시간 등 **파일에 관한 다양한 정보를 관리**합니다.
{% endhint %}

**inode에는 어떤 정보가 들어 있을까요?**

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption><p><a href="https://rebugs.tistory.com/767">https://rebugs.tistory.com/767</a></p></figcaption></figure>

| 항목                | 설명                                        |
| ----------------- | ----------------------------------------- |
| 파일 소유권과 접근 권한     | 파일을 누가 소유하고 있는지, 어떤 권한(읽기/쓰기/실행)을 가지고 있는지 |
| 파일 내용이 저장된 물리적 주소 | 파일의 데이터가 실제로 저장된 저장 장치의 위치 정보             |
| 파일의 링크 수          | 해당 파일을 참조하고 있는 링크(하드 링크)의 개수              |
| 파일의 크기            | 파일이 차지하는 전체 용량                            |
| 파일 생성 시간          | 파일이 처음 만들어진 시각                            |
| 최근 사용 시간          | 파일이 마지막으로 읽히거나 접근된 시각                     |
| 최근 수정 시간          | 파일의 내용이 마지막으로 수정된 시각                      |
| 아이노드의 최근 수정 시간    | 파일 내용이 아닌 아이노드(메타데이터) 자체가 수정된 시각          |

> 🧩 **inode는 파일 내용을 직접 저장하지 않고**, "내용은 어디에 저장되어 있다"는 **주소**만 관리해요.
>
> 이 정보들은 파일 시스템에서 파일이 어떻게 저장되고 관리되는지에 대한 중요한 정보를 제공합니다!

각 파일이나 디렉토리는 고유한 **아이노드 번호**를 가지며, 이 번호를 통해 파일 **시스템은 파일의 메타데이터를 찾습니다.**

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p><a href="https://rebugs.tistory.com/767">https://rebugs.tistory.com/767</a></p></figcaption></figure>

* 파일 이름: 사용자가 파일을 식별할 때 사용하는 이름으로, 디렉토리 구조에서 파일 이름이 저장된다. 이 파일 이름은 아이노드 번호를 참조하여 파일의 실질적인 위치를 찾는다.
* 아이노드: 파일의 메타데이터(파일 크기, 권한, 생성 시간 등)를 포함하며, 파일 내용이 저장된 데이터 블록의 위치를 가리키는 정보가 담겨 있다. 즉, 파일 이름은 아이노드를 가리키고, 아이노드는 파일 내용을 가리킨다.
* 파일 내용: 실제 파일의 데이터가 저장된 블록으로, 아이노드의 정보를 통해 접근된다.

이를 통해 리눅스 파일 시스템은 <mark style="color:red;">파일 이름을 통해 간접적으로 파일 내용에 접근하게 된다.</mark>&#x20;

> 아이노드를 사용하면 하드 링크와 소프트 링크 같은 다양한 파일 참조 방식이 가능해진다.

내용출처 :  [https://rebugs.tistory.com/767](https://rebugs.tistory.com/767)

아이노드의 예제

<figure><img src="../../../.gitbook/assets/image (11) (1).png" alt=""><figcaption><p><a href="https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C">https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C</a></p></figcaption></figure>

내 컴퓨터에서 엄청 큰 파일이 있다 가정해봅시다.

컴퓨터의 용량이 부족해서, 이 파일을 휴지통에 버렸을 **때 내 드라이브의 용량이 줄지 않은 것을 확인** 해 본 적이 있을 것입니다.

`휴지통에서 완전히 비우기`를 했을 때, **비로소 그 파일 만큼의 용량이 확보되는것을 확인**해 볼 수 있다.

이처럼 파일을 <mark style="color:red;">휴지통에만 버린 것이 특정 파일의 inode를 삭제</mark>한 것입니다. **(위치값만 삭제한 것)**

> 즉, inode는 위치값만 전달하는 노드이며 그렇기 때문에 DNS Server와 비슷한 역할을 한다 말한 것입니다.

출처 : [https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C](https://velog.io/@yje876/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%95%84%EC%9D%B4%EB%85%B8%EB%93%9C-%EC%8B%AC%EB%B3%BC%EB%A6%AD-%EB%85%B8%EB%93%9C-%ED%95%98%EB%93%9C-%EB%85%B8%EB%93%9C)

#### 2. **디렉터리 엔트리 (Directory Entry)**: 이름을 붙여주는 표

* 디렉터리는 일종의 **파일 목록표**입니다.
* "파일 이름"과 "inode 번호"를 짝지어서 기록해둡니다.

**구성 예시**

| 파일 이름       | inode 번호 |
| ----------- | -------- |
| hello.txt   | 1024     |
| picture.png | 1025     |
| my\_folder  | 1026     |

> 📂 즉, **디렉터리**는 "파일 이름 → inode 번호"를 알려주는 지도 역할을 해요.

#### 전체 구조 그림으로 표현하면

<figure><img src="../../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

```
[디렉터리] ──> 파일 이름, inode 번호
[inode] ──> 파일 속성, 실제 데이터 위치
```

* 디렉터리가 이름을 알려주고,
* inode가 진짜 몸통(속성 + 위치)을 관리하는 방식!

#### 비유로 다시 한 번 정리

| 비유    | 설명                      |
| ----- | ----------------------- |
| 디렉터리  | 백화점 안내판 (매장 이름 + 매장 번호) |
| inode | 각 매장의 실제 위치와 정보         |

> **inode와 디렉터리 엔트리는 파일 시스템의 두 날개!**\
> **하나라도 없으면 파일을 찾을 수도, 관리할 수도 없다!**

### 8) 아이노드의 구성

> 출처 : [https://jdcyber.tistory.com/87](https://jdcyber.tistory.com/87)

<figure><img src="../../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

아이노드는 **64바이트 크기의 표**로, **파일에 대한 모든 정보**를 담고 있습니다.

그리고 이 아이노드들은 <mark style="color:red;">아이노드 블록에 저장</mark>되며, <mark style="color:blue;">전체 디스크의 약 1% 정도를 차지</mark>합니다.

파일이나 디렉토리가 생성되면, **해당 파일을 관리할 아이노드**가 만들어지고, 이 아이노드는 `아이노드 테이블에 등록`되어 관리됩니다.

* 아이노드(inode): 파일이나 디렉토리의 중요한 정보를 담고 있는 64바이트 크기의 데이터 구조입니다.
* 아이노드 테이블(inode table): 시스템 내의 모든 파일과 디렉토리의 아이노드를 관리하는 표입니다.
* 아이노드 번호(inumber): 아이노드가 아이노드 테이블에서 고유하게 등록된 번호입니다.

#### 아이노드 테이블

> 아이노드 테이블은 파일 시스템에서 **파일이나 디렉토리들이 어디에 저장되고 있는지 추적하는 역할**을 합니다.&#x20;

파일이나 디렉토리가 생성되면, 아이노드 번호는 i-list라는 표에 등록되고, 이 번호를 통해 해당 파일에 대한 정보를 빠르게 찾을 수 있습니다.

### 9)  inode 내부 구조: "주소책 속에 또 다른 주소가!"

inode에는 파일이 저장된 "진짜 데이터"의 **위치**를 기록합니다.\
그런데 **큰 파일**을 저장하려면 단순히 주소 하나만으로는 부족해요.\
그래서 inode는 **다단계 포인터 구조**를 사용합니다!

#### 1. **직접 포인터 (Direct Pointer)**

* **inode 안에 바로 기록된 포인터**입니다.
* 직접적으로 "이 블록에 데이터가 있어요"를 가리킵니다.

> 예를 들어,\
> `Direct Pointer 1 → 블록 123번`\
> 이러면 바로 123번 블록에서 파일 조각을 읽어옵니다.

보통 12개 정도의 직접 포인터가 있어요.

#### 2. **간접 포인터 (Indirect Pointer)**

**파일이 커져서** 직접 포인터만으로는 부족할 때 사용하는 방식입니다.

**1단계 간접 포인터 (Single Indirect)**

* inode 안의 포인터가 "또 다른 블록"을 가리키고,
* 그 블록 안에 진짜 데이터 블록 번호 목록이 있어요!

> **inode → 인덱스 블록 → 데이터 블록**

(= 주소를 한 번 더 거쳐야 합니다.)



**2단계 간접 포인터 (Double Indirect)**

* inode가 "인덱스 블록"을 가리키고,
* 그 인덱스 블록이 또 "다른 인덱스 블록"을 가리키고,
* 그 다음에야 데이터 블록을 가리킵니다.

> **inode → 인덱스 블록 → 인덱스 블록 → 데이터 블록**



**3단계 간접 포인터 (Triple Indirect)**

* 이건 진짜 크\~게 큰 파일을 저장할 때.
* 인덱스 블록 → 인덱스 블록 → 인덱스 블록 → 데이터 블록

> 📂 📂 📂 📄\
> (주소책을 세 번 열어야 데이터에 도착!)

#### 그림으로 요약하면

```
[inode]
├── Direct Pointer 1 ──> [Data Block]
├── Direct Pointer 2 ──> [Data Block]
│
├── Single Indirect Pointer ──> [Index Block] ──> [Data Block List]
│
├── Double Indirect Pointer ──> [Index Block] ──> [Index Block] ──> [Data Block List]
│
└── Triple Indirect Pointer ──> [Index Block] ──> [Index Block] ──> [Index Block] ──> [Data Block List]
```

#### 다시 비유로 정리

| 포인터 종류     | 비유                     |
| ---------- | ---------------------- |
| 직접 포인터     | "내 주머니에 바로 들어있는 열쇠"    |
| 1단계 간접 포인터 | "내 친구가 가진 창고 열쇠"       |
| 2단계 간접 포인터 | "친구의 친구가 가진 창고 열쇠"     |
| 3단계 간접 포인터 | "친구의 친구의 친구가 가진 창고 열쇠" |

> **"파일이 커지면 커질수록 점점 더 복잡한 열쇠놀이를 하게 되는 구조입니다."**

### 10) 리눅스 파일 링크 : 하드링크와 소프트링크의 차이점

> 출처 : [https://jdcyber.tistory.com/86?pidx=0](https://jdcyber.tistory.com/86?pidx=0)

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

#### 1. 하드링크 (Hard Link)

**개념**

* **원본 파일과 동일한 데이터**를 가리키는 **또 다른 이름**.
* 원본 파일과 **같은 아이노드 번호**를 가짐.
* 사실상 **"같은 파일"** 이 두 군데 있는 것처럼 보이는 것.

**왜 배워야 할까?**

* **파일 중복 없이** 여러 위치에서 하나의 파일을 관리 가능.
* **디스크 공간 절약**.
* **백업 시스템**, **중복 파일 관리** 등에 유용.

**비유: "이름을 하나 더 붙이는 것"**

* 한 사람에게 '홍길동', '길동이' 두 이름을 붙여 부르는 것과 같음.
* **누가 이름을 부르든, 같은 사람(파일)을 가리킴**.



**특징**

| 항목      | 설명                    |
| ------- | --------------------- |
| 아이노드 번호 | 원본과 동일                |
| 수정 시    | 모든 링크에 반영됨            |
| 원본 삭제 시 | 다른 하드링크가 남아 있으면 파일 유지 |
| 파일 내용   | 동일한 실제 데이터 참조         |

#### 2. 소프트링크 (Soft Link, Symbolic Link)

**개념**

* **원본 파일의 위치(경로)** 를 가리키는 **별도의 파일**.
* 원본 파일의 **주소를 적어 놓은 종이**와 같음.

**왜 배워야 할까?**

* **자주 바뀌는 파일 경로 관리**.
* 여러 버전의 프로그램, 설정 파일을 **쉽게 연결**.
* 시스템 전체를 관리할 때 **유연성**을 제공.

**비유: "주소를 적어놓은 종이"**

* 친구 집 주소를 적어놓은 종이를 들고 가는 것.
* **집이 이사 가면, 종이는 무용지물**이 됨.



**특징**

| 항목      | 설명                         |
| ------- | -------------------------- |
| 아이노드 번호 | 원본과 다름                     |
| 수정 시    | 소프트링크 자체를 수정할 뿐, 원본은 영향 없음 |
| 원본 삭제 시 | 소프트링크가 깨짐(Dead Link)       |
| 파일 내용   | 원본 파일 경로만 보관               |

#### 핵심 차이 비교

| 구분      | 하드링크    | 소프트링크      |
| ------- | ------- | ---------- |
| 아이노드 번호 | 원본과 동일  | 원본과 다름     |
| 수정 사항   | 동기화됨    | 별도 (동기화 X) |
| 원본 삭제 시 | 문제 없음   | 링크 깨짐      |
| 파일 내용   | 동일한 데이터 | 원본 경로만 기억  |

#### 요약 한 줄

> **하드링크**는 "같은 사람에 여러 이름을 붙이는 것",\
> **소프트링크**는 "집 주소를 종이에 적어 놓은 것"입니다.

{% hint style="danger" %}
어째서 소프트링크는 **원본과 다른 아이노드 번호를 가지고 있는데** 원본을 삭제하면 문제가 생기는 걸까요?
{% endhint %}

#### 🔥 핵심 답변:

**소프트링크(심볼릭 링크)는 파일 자체를 가리키는 게 아니라, "원본 파일의 경로(주소)"만 저장**하기 때문입니다.\
즉, 소프트링크는 **"파일의 내용"이 아니라 "파일 위치"를 기억하는 종이쪽지** 같은 거예요.

* 소프트링크는 원본 파일의 **아이노드 번호**를 저장하지 않습니다.
* 대신 **"이 경로로 가보세요!"** 라고 **파일 경로 문자열**만 들고 있어요.
* 그래서 원본 파일이 삭제되면?\
  👉 소프트링크는 가리키던 경로를 따라가지만, **"더 이상 존재하지 않는 경로"** 라서 깨져버리는 겁니다.

#### 📌 비교 예시

* **하드링크**:\
  "같은 집의 두 개 현관문" → 한쪽 문이 막혀도 다른 문으로 들어갈 수 있어요. (아이노드가 같음)
* **소프트링크**:\
  "집 주소를 써놓은 쪽지" → 집이 사라지면? 쪽지를 따라가도 **없음**. (아이노드가 다름)

#### 🧩 요약 포인트

| 구분      | 하드링크             | 소프트링크               |
| ------- | ---------------- | ------------------- |
| 아이노드    | 원본과 동일           | 원본과 다름              |
| 가리키는 것  | 파일 데이터(내용)       | 파일 경로(주소)           |
| 원본 삭제 시 | 다른 링크로 여전히 접근 가능 | 경로를 따라가도 파일이 없어서 깨짐 |

#### 소프트링크는 어디서 유리할까?

* **하드링크**는 같은 파일 시스템(같은 디스크 안)에서만 사용할 수 있어요.
  * 서로 다른 디스크(예: C드라이브, D드라이브)에는 하드링크를 만들 수 없습니다.
* **소프트링크**는 파일 시스템이 달라도 만들 수 있어요!
  * 즉, **다른 디스크**, **다른 파티션**이라도 "경로"만 알고 있으면 연결이 됩니다.

> 그래서 소프트링크는 **다른 디렉토리**나 **다른 디스크**에 파일을 연결해야 할 때 아주 유리합니다.

#### 📦 표로 한 번에 정리

| 구분         | 하드링크                   | 소프트링크                                 |
| ---------- | ---------------------- | ------------------------------------- |
| 아이노드 번호    | 원본과 같음                 | 원본과 다름                                |
| 저장 내용      | 파일 데이터 직접 가리킴          | 파일 경로를 문자열로 저장                        |
| 원본 파일 삭제 시 | 다른 링크에서 계속 접근 가능       | 깨진 링크(경로를 못 찾음) 발생                    |
| 파일 시스템 제한  | 같은 파일 시스템 안에서만 가능      | 다른 파일 시스템, 다른 디스크도 가능                 |
| 사용 예시      | 같은 디스크에서 파일 복제처럼 사용할 때 | 다른 위치에 있는 파일을 연결하거나, 자주 변경될 파일을 참조할 때 |

## 2. 파일 접근 방법

### 1) 파일 시스템 접근은 어떻게 할까?

우리가 파일을 만들거나 읽거나 삭제할 때, 사실은 **POSIX 표준**에 따라 제공되는 함수들을 사용합니다.

| 작업 종류         | 대표 함수                                  |
| ------------- | -------------------------------------- |
| 파일 작성/삭제      | `creat()`, `unlink()`                  |
| 파일 열기/닫기      | `open()`, `close()`                    |
| 파일 읽기/쓰기      | `read()`, `write()`, `mmap()`          |
| 디렉터리 생성/삭제    | `mkdir()`, `rmdir()`                   |
| 디렉터리 열기/닫기/읽기 | `opendir()`, `closedir()`, `readdir()` |
| 현재 디렉터리 이동    | `chdir()`                              |

> 사용자는 ext4든 XFS든 Btrfs든 **파일 시스템 종류를 신경 쓸 필요 없이** creat(), open() 같은 **통일된 함수**를 호출합니다!

### 2) 파일 시스템 내부 동작 흐름

우리가 함수를 호출하면 내부적으로 다음과 같은 순서로 흘러갑니다:

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

```
[ 사용자 프로그램 ]
      ↓ (creat(), open() 등)
[ 시스템 콜 호출 ]
      ↓
[ VFS (Virtual File System) 계층 ]
      ↓
[ 실제 파일 시스템(ext4/XFS/Btrfs 등) 처리 로직 ]
      ↓
[ 디바이스 드라이버 ]
      ↓
[ 저장 장치 (디스크 등) ]
```

* **VFS 계층**: 파일 시스템 종류에 상관없이 공통된 인터페이스를 제공하는 중간 관리자입니다.
* **디바이스 드라이버**: 실제 하드웨어(디스크)를 읽고 쓰는 역할을 합니다.

### 3) 그림으로 이해해보기

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

예를 들어 동일한 **디바이스 드라이버로 조작할 수 있는 블록 장치** A, B, C가 있을 때 각각 ext4,XFS, Btrf's 파일 시스템이 존재한다면 \[그림 07-05]처럼 됩니다.

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

| 계층           | 역할                        | 예시                           |
| ------------ | ------------------------- | ---------------------------- |
| 사용자 프로그램     | creat(), open() 호출        | bash, python, etc            |
| 시스템 콜        | 커널로 요청 전달                 | `sys_open()`, `sys_read()` 등 |
| VFS 계층       | ext4, XFS, Btrfs 구분 없이 처리 | 파일 종류 인식 없이                  |
| 실제 파일 시스템 처리 | ext4용, XFS용, Btrfs용 코드 실행 | 파일 생성/삭제 등                   |
| 디바이스 드라이버    | 물리 장치 I/O 처리              | SATA, NVMe 드라이버              |
| 저장 장치        | 데이터가 실제 저장되는 곳            | SSD, HDD 등                   |

> **VFS** 덕분에 우리는 **파일 시스템 종류를 몰라도**\
> `open()`, `read()` 같은 함수 하나로 **모든 파일 시스템을 통합적으로 다룰 수 있다!**

## 3. 메모리 맵 파일(Memory-Mapped File)

### 1) 메모리 맵 파일이란?

* 파일의 내용을 **가상 주소 공간**에 매핑하는 기능입니다.
* **`mmap()` 함수**를 사용하여 파일을 **메모리처럼 직접 읽고 쓸 수 있게** 합니다.
* 파일을 메모리에 읽어올 필요 없이, **메모리 접근만으로 파일 조작이 가능**해집니다.

> 📌 **한마디로:** "파일 내용을 메모리처럼 다룰 수 있다."

#### 메모리 맵 파일

<figure><img src="../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

메모리 맵에 저장된 파일은 **메모리와 같은 방법으로 접근할 수 있습니다.** 데이터를 변경하면 나중에 저장 장치에 있는 파일에도 **정해진 타이밍에 반영(타이밍은 8장)**

### 2) 메모리 맵 파일 동작 흐름

#### 1️⃣ 파일 오픈

* 파일을 `open()`으로 엽니다.

#### 2️⃣ mmap() 호출

* `mmap()`으로 파일 내용을 **가상 주소 공간에 매핑**합니다.

#### 3️⃣ 메모리 접근

* 매핑된 메모리 영역을 수정하면, 파일 내용도 **자동으로 변경**됩니다.

#### 4️⃣ 저장 타이밍

* 수정한 내용은 **일정 시점**에 **저장 장치로 반영(sync)** 됩니다. (타이밍은 운영체제가 결정. 강제로 `msync()` 호출 가능)

### 3) 그림으로 이해하는 구조

#### 📌 메모리 맵 파일 생성 구조

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

```
[프로세스 가상 주소 공간]
         │
         ▼
 [mmap()로 파일 매핑]
         │
         ▼
[파일 데이터 복사본 (메모리)]
         │
         ▼
[저장 장치의 실제 파일]
```

* 프로세스가 **메모리**를 수정하면, 이게 나중에 파일에 반영됩니다!

### 4) 실습 예시: 메모리 맵 파일 만들기

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

1.  **파일 준비**

    ```bash
    echo hello > testfile
    ```
2. **Go 프로그램 작성 (`filemap.go`)**
   * 파일을 `open()`
   * `mmap()`으로 매핑
   * 매핑된 메모리 수정 (`"HELLO"`로 덮어쓰기)
3. **프로세스 메모리 맵 상태 확인**
   * `/proc/<pid>/maps` 파일 출력
   * 매핑 전후를 비교해서, 매핑된 주소 확인
4.  **파일 내용 확인**

    ```bash
    cat testfile
    # 결과: HELLO
    ```

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

* ①에서 mmap() 함수 실행에 성공해서 <mark style="color:red;">testfile 파일 데이터 시작 주소가 0xffffa3f69000</mark>가 되  었습니다.
* 2에서는 이 주소로 시작하는 영역이 <mark style="color:red;">실제로 메모리 매핑</mark>된 걸 알 수 있습니다.
* 마지  막으로 3에서 <mark style="color:red;">실제로 파일 내용이 변경된 걸 확인</mark>했습니다.

### 5) 주의사항

* mmap()으로 매핑한 영역은 **메모리 접근**하듯이 읽고 쓸 수 있지만,\
  <mark style="color:red;">반드시 파일과 싱크(sync)</mark>를 맞춰야 파일에도 실제 반영됩니다.
* 파일 수정은 메모리에 먼저 이루어지고, <mark style="color:red;">디스크에 쓰기(sync)</mark>는 **지연될 수 있음.**

#### 요약

> **mmap()** 을 사용하면, 파일을 메모리에 직접 매핑해서 고속으로 파일 입출력을 수행할 수 있다!\
> (단, 변경사항은 싱크(sync) 시점에 파일에 기록된다는 점 주의)

## 4. 일반적인 파일 시스템

### 1) 리눅스에서 사용하는 대표 파일 시스템

<figure><img src="../../../.gitbook/assets/image (294).png" alt=""><figcaption></figcaption></figure>

| 파일 시스템    | 특징                                                               |
| --------- | ---------------------------------------------------------------- |
| **ext4**  | 예전부터 사용된 ext2, ext3에서 쉽게 전환 가능. 리눅스 기본 파일 시스템으로 안정적.             |
| **XFS**   | **대용량 파일**과 **확장성**에 매우 강함. 고성능 서버나 대형 스토리지에 적합.                 |
| **Btrfs** | **스냅샷**, **압축**, **RAID 지원** 등 다양한 기능을 기본 탑재. 차세대 파일 시스템으로 주목받음. |

### 2) 파일 시스템마다 다른 부분

리눅스 파일 시스템은 다음 항목에서 서로 차이를 가집니다.

* **파일 시스템 최대 크기**
* **파일 하나당 최대 크기**
* **최대 파일 개수**
* **파일 이름 최대 길이**
* **파일 접근/수정 속도**
* **추가 기능(스냅샷, 압축 등) 지원 여부**

> 📌 **즉, 어떤 파일 시스템을 고르느냐에 따라 '성능', '기능', '제한사항'이 모두 달라진다!**



