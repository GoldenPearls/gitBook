---
icon: clock-eleven-thirty
---

# 11장 컨테이너

컨테이너 기술을 사용한 소프트웨어라고 하면, **컨테이너 애플리케이션을 관리**하는 `도커`, 도**커 등을 활용한 컨테이너 오케스트레이션 시스템**인 `쿠버네티스Nikeimeier'`가 유명합니다.

## 🧱 컨테이너는 왜 가볍고 빠른 가상화인가?

### 1. 컨테이너란 무엇인가?

#### 1) 컨테이너의 정의

컨테이너는 운영체제 수준의 가상화 기술로, 프로세스 격리와 자원 분리를 통해 마치 독립된 시스템처럼 작동하는 실행 환경입니다.

> `가상 머신`은 <mark style="color:red;">각 가상 머신 전용의 가상 하드웨어와 커널을 사용하는 반면</mark>에, 가상 머신과 달리 **전체 OS를 복제하지 않고, 호스트 OS의 커널을 공유**한다는 특징이 있습니다.

#### 2) 컨테이너 vs 가상 머신

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

| 항목      | 가상 머신                          | 컨테이너                       |
| ------- | ------------------------------ | -------------------------- |
| 커널      | 별도 OS 커널 필요                    | 호스트 OS의 커널 공유              |
| 기동 방식   | 전체 OS 부팅                       | 단일 프로세스 실행                 |
| 기동 속도   | 느림 (수십 초)                      | 빠름 (0.6초 이내)               |
| 기동 시간   | 평균 10\~30초 이상                  | 밀리초\~1초 내외                 |
| 자원 사용량  | 무거움                            | 가벼움                        |
| 하드웨어 접근 | 완전 가상화로 성능 손실 있음               | 네이티브와 유사한 속도 가능            |
| 주 사용 사례 | OS 격리 / 이기종 OS 필요 시            | 마이크로서비스 / 빠른 배포 환경용        |
| 호환성     | 이기종 OS 가능 (Windows 위에 Linux 등) | 동종 커널만 가능 (Linux 위에 Linux) |

**가상 머신**은&#x20;윈도에서 리눅스를 실행하는 등 <mark style="color:red;">완전히 다른 호스트 OS를 쓸 수 있지만</mark>, **리눅스 컨테이너**는 리\
눅스 커널에서만 동작하는 시스템(우분투 레드햇 엔터프라이즈 리눅스 등)만 사용할 수 있습니다.

#### 3) 가상 머신(Virtual Machine)의 기동 단계

가상 머신에서 우분투 20.04와 같은 OS가 완전히 부팅되기까지는 다음과 같은 과정을 거칩니다.

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

1. **호스트 OS**의 가상화 소프트웨어(QEMU, VirtualBox 등)가 가상 머신을 기동한다.
2. **부트 로더**(예: GRUB)가 시작된다.
3. 부트 로더가 **리눅스 커널**을 로드한다.
4. 커널이 **init 프로그램(systemd 등)**&#xC744; 기동한다.
5. `systemd`가 **백그라운드 서비스들(systemctl 서비스)**&#xB97C; 순차적으로 기동한다.

> 📌 이 흐름은 실제 물리 시스템이 부팅되는 방식과 거의 동일하며, **초기화에 수 초\~수십 초**가 소요

#### 4) 컨테이너(Container)의 기동 단계

컨테이너에서는 전체 OS 부팅이 아닌, **애플리케이션 프로세스만 기동**합니다.

1. **컨테이너 런타임(Docker 등)**&#xC774; 컨테이너를 생성한다.
2. 런타임이 **최초 프로세스(예: bash, nginx 등)**&#xB97C; 바로 실행한다.

📌 커널, 부트로더, 시스템 서비스 기동이 없기 때문에 **수 밀리초 수준의 빠른 기동**이 가능합니다.

#### 5) 결과 비교

| 환경    | 기동 시간 (초)   |
| ----- | ----------- |
| 가상 머신 | **14.0 초**  |
| 컨테이너  | **0.670 초** |

> **20배 이상 차이** 발생!\
> 컨테이너는 가상 머신보다 훨씬 빠르게 실행됩니다.

{% hint style="danger" %}
### 왜 이런 차이가 날까요?
{% endhint %}

1. &#x20;가상 머신의 느린 기동 원인

* 부트로더 → 커널 → 시스템 초기화 → 데몬 등 전통적인 OS 부팅 절차 전부 수행
* 하드웨어 접근 시 **VMX 모드 전환 비용**이 계속 발생



2. &#x20;컨테이너의 빠른 기동 비결

* 커널은 이미 **호스트 OS와 공유**
* 필요한 건 **애플리케이션 프로세스 1개 실행**이면 끝
* 별도의 OS 초기화 필요 없음

### 2. 컨테이너의 두 얼굴

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

#### 1) 시스템 컨테이너

* init(systemd 등)을 실행해 전통적인 리눅스 환경처럼 작동
* 다양한 애플리케이션 실행 가능
* LXD 등에서 사용

#### 2) 애플리케이션 컨테이너

* 하나의 앱만 실행
* systemd 없이 시작 프로그램만 실행
* 도커(Docker)의 대표적인 컨테이너 방식

### 3. 컨테이너 내부 구조 – 커널이 컨테이너를 모른다?

#### 1) 커널에는 ‘컨테이너’라는 개념이 없다

사실 커널에는 컨테이너라고 부르는&#x20;기능이 없습니다. 컨테이너는 단지 **네임스페이스와 cgroup을 조합한 결과물**입니다.

#### 2) 네임스페이스란?

네임스페이스는 시스템에 있는 다양한 종류의 자원에 사용할 수 있는데, 모두가 이런 자원을 공유하는 것이 아니라 **소속된 프로세스에 독립된 자원인 것처럼 만들어 주는 기능**입니다.

#### 3) 컨테이너는 네임스페이스의 조합

* 프로세스 ID 공간 분리 (PID 네임스페이스) : 독립된 PID 이름 공간 제공
* 사용자 계정 분리 (User NS) : 독립된 UID, GID를 제공
* 파일 시스템 마운트 분리 (Mount NS) : 독립된 파일 시스템 마운트 제공
* 네트워크 스택 분리 (Network NS)
* IPC, UTS(호스트명 등)도 분리 가능

## 🧠 리눅스의 네임스페이스 – 프로세스 ID(PID) 네임스페이스 완전 이해

### 1) 개념: 프로세스 ID 네임스페이스란?

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

#### ✅ 핵심 정의

* **PID 네임스페이스**는 각 프로세스 집단이 **서로 독립적인 PID 테이블**을 가질 수 있게 해주는 기능입니다.
* **컨테이너 기술의 핵심 구성 요소**이며, 격리된 실행 환경을 구현하는 데 사용됩니다.

#### ✅ 계층 구조

* **PID 네임스페이스는 부모-자식 관계를 가질 수 있으며**, 자식 네임스페이스는 부모의 프로세스를 **볼 수 없지만**, 부모는 자식의 프로세스를 **볼 수 있습니다.**

### 2) 네임스페이스 구조 이해

아래는 **루트 PID 네임스페이스**와 그 자식인 **foo 네임스페이스**의 구조를 도식화한 그림입니다.

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

**특징**

* 루트는 foo의 프로세스를 볼 수 있음
* **foo는 루트의 프로세스를 볼 수 없음**

### 3) 실습: 네임스페이스 확인하기

#### 현재 bash의 네임스페이스 ID 확인

```bash
$ ls -l /proc/$$/ns/pid
lrwxrwxrwx 1 ... -> 'pid: [4026531836]'
```

* 이 ID는 **루트 PID 네임스페이스**를 의미합니다.
* 별도로 지정하지 않는 한 init를 비롯한  &#x20;모든 프로세스는 루트 프로세스ID의 네임스페이스에 소속

### 4) 새로운 네임스페이스 생성 - _`unshare` 명령어로 PID 네임스페이스 실습_

> “하나의 리눅스 시스템에서, 새로운 프로세스 ID 네임스페이스를 만들어 그 안에서 bash를 실행하면 어떤 일이 벌어지는가?”

이를 통해 **PID 네임스페이스의 격리 효과**를 직접 확인할 수 있습니다.

#### 1. 실습 명령어와 의미

```bash
$ sudo unshare --fork --pid --mount-proc bash
```

#### 각 옵션 설명:

| 옵션             | 설명                                   |
| -------------- | ------------------------------------ |
| `--pid`        | 새로운 PID 네임스페이스를 생성                   |
| `--fork`       | `bash`를 새 네임스페이스에서 실행                |
| `--mount-proc` | `/proc` 파일시스템을 새로 마운트 (PID 정보 확인 가능) |

이 명령어로 실행된 bash는 **새로운 PID 네임스페이스에 속하게 되며**, 그 안에서 **PID가 1**번이 됩니다.

#### 2. 내부에서 확인하기

bash 셸이 열리면 다음을 입력해 봅니다:

```bash
# echo $$
1
```

```bash
# ls -l /proc/1/ns/pid
lrwxrwxrwx ... -> 'pid: [4026532814]'
```

* `$$`는 현재 프로세스 ID (1)를 보여줍니다.
* `/proc/1/ns/pid`는 **현재 bash가 속한 PID 네임스페이스의 고유 ID**를 보여줍니다.

#### `ps` 명령어로 내부 상태 확인

```bash
# ps ax
  PID TTY      STAT   TIME COMMAND
    1 pts/1    S      0:00 bash
    9 pts/1    R+     0:00 ps ax
```

* PID가 `1`인 bash와, `9`인 ps만 존재
* → **루트 네임스페이스와 완전히 격리된 새로운 PID 공간**

#### 3. 외부(호스트 OS)에서 확인

#### `pstree` 명령어로 구조 확인

```bash
$ pstree -p | grep unshare
sshd(14126)---bash(14193)---sudo(14382)---unshare(14384)---bash(14385)
```

* 이 구조에서 **PID 14385의 bash가 unshare 명령어로 실행된 셸**입니다.

#### 해당 bash의 네임스페이스 확인

```bash
$ sudo ls -l /proc/14385/ns/pid
lrwxrwxrwx ... -> 'pid: [4026532814]'
```

→ **PID 14385는 루트 네임스페이스에선 14385로 보이지만, 내부에서는 PID 1**

#### 4. 전체 구조 그림

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

| 항목               | 설명                                  |
| ---------------- | ----------------------------------- |
| `unshare --pid`  | 새로운 PID 네임스페이스 생성                   |
| `$$` 출력값         | 새로운 공간에서는 항상 `1`                    |
| `/proc/1/ns/pid` | 새로운 네임스페이스 ID로 확인 가능                |
| `ps ax` 실행 결과    | 격리된 내부 프로세스만 나옴                     |
| 호스트에서 보이는 PID    | 실제로는 일반 PID(예: 14385)로 보임           |
| 네임스페이스 격리 효과     | PID 1인 프로세스를 루트에서 직접 실행하지 않아도 생성 가능 |

***

### 5) 서로 다른 두 PID 네임스페이스

이제 bar라는 **또 다른 PID 네임스페이스**를 만들면, foo와 bar는 **서로의 프로세스를 볼 수 없습니다.**

```bash
$ sudo unshare --fork --pid --mount-proc bash
# echo $$
1
# ls -l /proc/1/ns/pid
-> 'pid: [4026532816]'  ← bar 네임스페이스 ID
```

🖼️ 그림: **여러 개의 PID 네임스페이스**

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

***

### 6) 네임스페이스 격리 정리

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

| 네임스페이스 | 볼 수 있는 프로세스    | ID 예시      |
| ------ | -------------- | ---------- |
| 루트     | foo, bar 포함 전체 | 4026531836 |
| foo    | 자기 자신만         | 4026532814 |
| bar    | 자기 자신만         | 4026532816 |

**→ foo와 bar는 서로를 볼 수 없다!**

### 7) 마무리: 컨테이너와 PID 네임스페이스

> **컨테이너는 독립적인 네임스페이스로 구성된 ‘프로세스 격리된 세계’입니다.**

* 프로세스는 자신이 속한 네임스페이스 안에서만 **보이고, 관리되며, 조작**됩니다.
* 따라서 **컨테이너 내부에서는 시스템 전체의 상태를 파악할 수 없습니다.**
* **모니터링 시 호스트에서의 접근이 필요합니다.**



