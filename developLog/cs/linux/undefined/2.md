---
icon: '2'
---

# 2장 : 프로세스 관리(기초편)

> **ps aux** 명령어를 사용해서 현재 실행 중인 모든 프로세스를 확인하는 방법과,\
> 리눅스에서 프로세스가 어떻게 관리되는지를 살펴보는 과정이다.

## 1. 개요&#x20;

### **1️⃣ 리눅스에서 프로세스를 확인하는 방법**

리눅스에서는 **프로세스를 관리하고 모니터링하는 여러 명령어**가 존재한다.\
가장 기본적인 명령어가 바로 `ps`

#### **🔹 `ps aux` 명령어란?**

```sh
$ ps aux
```

* `a` : **모든 사용자**의 프로세스를 표시
* `u` : 프로세스를 **소유한 사용자 정보 포함**
* `x` : **터미널과 연결되지 않은 프로세스**도 포함 (데몬 프로세스 등)

#### **🔹 `ps aux` 실행 결과 예시**

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
sat      19261  0.0  0.0  13840  5360 ?        S    18:24   0:00 sshd: sat@pts/8
sat      19262  0.0  0.0  12120  5232 pts/8    Ss   18:24   0:00 -bash
sat      19280  0.0  0.0  12752  3692 pts/0    R+   18:25   0:00 ps aux
```

* 줄마다 하나의 프로세스를 표시
* ssh 서버인 sshd(PID=19261)가 bash(PID=19262)를 실행하고 거기서 ps aux를 실행했음
* ps 명령어는 --no-header 옵션으로 헤더 출력을 제거 가능

#### **🔹 각 필드 설명**

| 필드          | 설명                        |
| ----------- | ------------------------- |
| **USER**    | 프로세스를 실행한 사용자             |
| **PID**     | 프로세스 ID                   |
| **%CPU**    | CPU 사용량 (비율)              |
| **%MEM**    | 메모리 사용량 (비율)              |
| **VSZ**     | 가상 메모리 사용량 (KB 단위)        |
| **RSS**     | 실제 물리적 메모리 사용량 (KB 단위)    |
| **TTY**     | 연결된 터미널 (없으면 `?`)         |
| **STAT**    | 프로세스 상태 (`S`, `R`, `Z` 등) |
| **START**   | 프로세스가 시작된 시간              |
| **TIME**    | CPU 실행 시간                 |
| **COMMAND** | 실행된 명령어                   |

### **2️⃣ `ps aux` 실행 결과 분석**

위의 예제에서는 **프로세스 관계**를 확인할 수 있다.

1. `ssh 서버 (sshd, PID 19261)`이 사용자 `sat`의 로그인 요청을 받아들임.
2. `sshd`는 `bash (PID 19262)` 셸을 실행함.
3. 사용자는 터미널에서 `ps aux (PID 19280)`을 실행하여 프로세스 목록을 확인.

> 즉, **프로세스 간 부모-자식 관계**가 있다는 걸 알 수 있다.

### **3️⃣ 프로세스 개수 확인**

리눅스 시스템에서 실행 중인 프로세스 개수를 확인하는 방법:

```sh
$ ps aux --no-header | wc -l
```

* `--no-header` : 헤더(열 이름)를 제외하고 출력
* `wc -l` : 줄(line) 수를 세어 프로세스 개수 확인

결과:

```
216
```

즉, 현재 시스템에는 **216개의 프로세스**가 실행 중이라는 의미



### **✅ 프로세스 관리 명령어 모음**

| **명령어**    | **설명**                                                  | **사용 예시**                                                                    |
| ---------- | ------------------------------------------------------- | ---------------------------------------------------------------------------- |
| `ps aux`   | 현재 실행 중인 **모든 프로세스 목록 출력**                              | <p><code>ps aux</code> <br>→ 전체 프로세스 확인</p>                                  |
| `ps -ef`   | **풀 포맷(full format)으로 프로세스 정보 표시**                      | <p><code>ps -ef</code> <br>→ UID, PID 등 자세한 정보 표시</p>                        |
| `top`      | **실시간 프로세스 모니터링** (CPU, 메모리 사용량 확인)                     | <p><code>top</code> </p><p>→ CPU 점유율 높은 프로세스 확인</p>                          |
| `htop`     | `top`의 개선 버전, **컬러 UI 제공 및 키보드/마우스 지원**                 | <p><code>htop</code> <br>→ 인터랙티브한 프로세스 관리</p>                                |
| `pidof`    | 특정 프로세스의 **PID(프로세스 ID) 찾기**                            | <p><code>pidof nginx</code> <br>→ <code>nginx</code>의 PID 출력</p>             |
| `pgrep`    | 특정 문자열을 포함하는 **프로세스명으로 PID 검색**                         | <p><code>pgrep -l sshd</code> <br>→ <code>sshd</code> 관련 프로세스 찾기</p>         |
| `kill`     | 특정 **PID의 프로세스를 종료**                                    | <p><code>kill 1234</code> <br>→ PID 1234 종료</p>                              |
| `kill -9`  | 프로세스를 **강제 종료** (`SIGKILL` 시그널)                         | <p><code>kill -9 1234</code> <br>→ 강제 종료</p>                                 |
| `pkill`    | **프로세스명을 기반으로 종료**                                      | <p><code>pkill nginx</code> <br>→ <code>nginx</code> 종료</p>                  |
| `pkill -f` | **전체 명령어 문자열을 기준으로 종료**                                 | `pkill -f "python my_script.py"`                                             |
| `nice`     | **프로세스 실행 시 우선순위 설정** (기본값 0, `-20`이 가장 높고 `19`가 가장 낮음) | <p><code>nice -n 10 myapp</code> <br>→ 낮은 우선순위로 실행</p>                       |
| `renice`   | 실행 중인 **프로세스의 우선순위 변경**                                 | <p><code>renice -5 1234</code> <br>→ PID 1234의 우선순위를 <code>-5</code>로 변경</p> |
| `watch`    | 특정 명령을 **주기적으로 실행**하여 변화를 모니터링                          | <p><code>watch -n 1 ps aux</code> <br>→ 1초마다 <code>ps aux</code> 실행</p>      |
| `strace`   | 프로세스가 호출하는 **시스템 호출(syscall) 실시간 추적**                   | <p><code>strace -p 1234</code> <br>→ PID 1234의 시스템 호출 추적</p>                 |
| `lsof`     | **프로세스가 열고 있는 파일 목록 확인**                                | <p><code>lsof -p 1234</code> <br>→ PID 1234가 사용하는 파일 확인</p>                  |
| `netstat`  | **네트워크 연결 상태 및 프로세스 확인**                                | <p><code>netstat -tulnp</code> <br>→ 포트와 프로세스 매핑</p>                         |
| `ss`       | `netstat`의 대체 명령어, **더 빠르고 자세한 네트워크 정보 제공**             | <p><code>ss -tulnp</code> <br>→ 프로세스와 포트 정보 확인</p>                           |
| `uptime`   | **시스템 가동 시간 및 평균 부하(load average) 확인**                  | <p><code>uptime</code> <br>→ 시스템이 얼마나 오랫동안 실행되었는지 확인</p>                     |
| `vmstat`   | **CPU, 메모리, 스왑 사용량 실시간 모니터링**                           | <p><code>vmstat 1</code> <br>→ 1초 간격으로 시스템 상태 확인</p>                         |
| `iotop`    | **디스크 I/O 사용량을 실시간 모니터링**                               | <p><code>iotop</code> <br>→ 가장 많이 디스크를 사용하는 프로세스 확인</p>                      |
| `free -m`  | **메모리 사용량 확인** (`-m` 옵션으로 MB 단위 표시)                     | <p><code>free -m</code> <br>→ 사용 가능한 RAM 확인</p>                              |
| `df -h`    | **디스크 사용량 확인** (`-h` 옵션으로 사람이 읽기 쉬운 형식)                 | <p><code>df -h</code> <br>→ 파일 시스템별 디스크 사용량 확인</p>                           |

### **결론**&#x20;

* `ps aux`를 사용하면 **현재 실행 중인 모든 프로세스를 확인**할 수 있음.
* `ps aux --no-header | wc -l`을 사용하면 **현재 실행 중인 프로세스 개수**를 알 수 있음.
* 리눅스는 다양한 프로세스를 **백그라운드와 포그라운드에서 관리**하며,\
  이를 위해 프로세스 스케줄링과 상태 관리가 이루어짐.



## 2. 프로세스 생성

### **1️⃣ 프로세스 생성 목적**

1. **동일한 프로그램 처리를 여러 프로세스에 나눠서 처리하기(Ex. 웹서버에서 다수의 요청 받기)**

* fork() 함수만 사용

2. **다른 프로그램을 생성하기(ex. bash에서 각종 프로그램을 생성)**

* fork()와 execve() 함수 둘 다 사용!

> 목적에 따라 프로세스 생성을 실제로 실행하는 방법으로는 리눅스는 fork() 함수와 execve() 함수를 사> \
> 용

### **2️⃣** 같은 프로세스를 두 개로 분열시키는 fork() 함수

<figure><img src="../../../.gitbook/assets/image (198).png" alt=""><figcaption></figcaption></figure>

#### 1) `fork()` 함수란?

`fork()` 함수는 **현재 실행 중인 프로세스를 복사**해서 새로운 프로세스를 생성하는 함수이다.

즉, **같은 프로세스를 두 개로 분열시키는 역할**을 한다.

> fork 동작은 <mark style="color:red;">부모 프로세스가 자기 자신을 복제하는 시스템 호출</mark>로, 유닉스 계열 운영 체제에서 프로세스를 만드는 주된 방식

#### 2) `fork()` 함수의 동작 과정

<figure><img src="../../../.gitbook/assets/image (197).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
원본 프로세스를 `부모 프로세스`, 생성된 프로세스를 `자식 프로세스`
{% endhint %}

1. **부모 프로세스가 `fork()` 호출**
   * `fork()`가 실행되면 커널이 **새로운 프로세스를 생성**한다.
2. **커널이 부모 프로세스의 메모리를 자식 프로세스에 복사**
   * 하지만 실제로는 **Copy-on-Write(CoW)** 덕분에 **메모리 전체를 즉시 복사하지 않는다**.
   * 자식 프로세스가 특정 메모리를 변경할 때만 복사됨.
   * 부모 프로세스의 주소 공간을 <mark style="color:red;">Binary 통째로 복사</mark>
3. **부모와 자식 프로세스가 각각 `fork()`에서 복귀**
   * **부모 프로세스**는 `fork()`의 반환값으로 **자식 프로세스의 PID를 받음**.
   * **자식 프로세스**는 `fork()`의 반환값으로 **0을 받음**.
   * 이를 이용해 **부모와 자식을 구별**할 수 있음.
   * fork 함수 호출 **이후 코드**부터 <mark style="color:red;">각자의 메모리를 사용하여 실행</mark>
4. **부모 프로세스(326)**
   * **PID (프로세스 ID):** `326` → 부모 프로세스의 고유 ID
   * **PPID (부모 프로세스 ID):** `123` → 부모 프로세스도 상위 부모(예: `init` 프로세스)가 있음
   * **CPID (자식 프로세스 ID):** `368` → `fork()`를 실행한 후 생성된 자식 프로세스의 PID
5. **자식 프로세스(368)**
   * **PID (프로세스 ID):** `368` → 새롭게 생성된 자식 프로세스의 고유 ID
   * **PPID (부모 프로세스 ID):** `326` → 자식 프로세스의 부모가 **PID 326(부모 프로세스)임을 나타냄**
   * **CPID (자식 프로세스 ID):** `-1` → `fork()` 직후에는 자식 프로세스가 새 자식 프로세스를 생성하지 않았기 때문에 `-1`로 표시

<figure><img src="../../../.gitbook/assets/image (199).png" alt=""><figcaption></figcaption></figure>

#### 3) `fork()`를 사용한 프로세스 생성 예제 (Python)

아래 Python 코드를 실행하면 `fork()`가 실행된 후 **부모와 자식 프로세스가 각각 분기**된다.

**📌 `fork.py` (프로세스 분기 코드)**

```python
#!/usr/bin/python3
import os, sys

ret = os.fork()  # 새로운 프로세스 생성

if ret == 0:
    # 자식 프로세스 실행
    print("자식 프로세스: pid={}, 부모 프로세스의 pid={}".format(os.getpid(), os.getppid()))
    sys.exit(0)  # 자식 프로세스 종료
elif ret > 0:
    # 부모 프로세스 실행
    print("부모 프로세스: pid={}, 자식 프로세스의 pid={}".format(os.getpid(), ret))
    sys.exit(0)  # 부모 프로세스 종료
```

**📌 실행 결과**

```sh
$ ./fork.py
부모 프로세스: pid=132767, 자식 프로세스의 pid=132768
자식 프로세스: pid=132768, 부모 프로세스의 pid=132767
```

이 결과를 보면 **프로세스가 두 개로 나뉜 것을 확인할 수 있다**.

* 부모 프로세스(132767)가 `fork()`를 호출하여 **자식 프로세스(132768)를 생성**.
* 이후 `fork()`의 반환값을 이용해 **부모와 자식을 구별**할 수 있다.

#### 4) `fork()`의 반환값을 이용한 부모-자식 구분

`fork()`를 호출한 후 반환값을 확인하면 된다.

| **반환값**    | **설명**                                   |
| ---------- | ---------------------------------------- |
| `0`        | **자식 프로세스**에서 반환됨                        |
| `>0` (PID) | **부모 프로세스**에서 반환되며, 생성된 자식 프로세스의 PID를 가짐 |
| `<0`       | 오류 발생 (프로세스 생성 실패)                       |

이 특성을 이용해 **부모와 자식 프로세스의 실행 흐름을 분기**할 수 있다.

#### 5) `fork()` 호출 후 부모와 자식의 실행 흐름

<figure><img src="../../../.gitbook/assets/image (200).png" alt=""><figcaption></figcaption></figure>

* `fork()` 이후 부모와 자식은 **완전히 독립된 프로세스**로 실행된다.
* 하지만 자식 프로세스는 **부모의 메모리 복사본을 사용**하기 때문에 **초기 상태는 동일**하다.

```sh
부모 프로세스 (PID=132767) 실행
 ├── fork() 호출 → 새로운 프로세스 생성
 │
 ├── 부모 프로세스는 `fork()`의 반환값으로 `132768`을 받음
 │   └── 부모 프로세스: pid=132767, 자식 프로세스의 pid=132768
 │
 ├── 자식 프로세스는 `fork()`의 반환값으로 `0`을 받음, 자식 프로세스는 fork()의 결과로 자신이 부모로부터 생성되었다는 것만 알 수 있다.
 │   └── 자식 프로세스: pid=132768, 부모 프로세스의 pid=132767
```

**`fork()` 실행 전**

```sh
부모 프로세스 (PID=132767) 실행 중
```

**`fork()` 실행 후**

```sh
부모 프로세스 (PID=132767)  ──>   자식 프로세스 (PID=132768)
```

* 부모는 `fork()`의 반환값으로 **132768 (자식의 PID)를 받음.**
* 자식은 `fork()`의 반환값으로 **0을 받음.**
* 부모의 PID는 그대로 유지되며, 새로운 프로세스(자식)가 생긴 것뿐이다.

#### 6) `fork()`의 메모리 복사 방식 (Copy-on-Write)

* `fork()`는 **부모 프로세스의 메모리를 그대로 복사하는 것처럼 보인다.**
  * <mark style="color:red;">하지만</mark> <mark style="color:red;"></mark><mark style="color:red;">**실제로는 Copy-on-Write(CoW) 방식**</mark><mark style="color:red;">을 사용한다.</mark>
  * 즉, **자식이 데이터를 변경할 때만 새로운 메모리 공간을 할당**한다.
  * 부모 프로세스와 자식 프로세스가 차지하고 있는 **메모리 위치가 다르기 때문에 메모리 관련 정보도 변경된다.**
  * 복제된 프로세스는 부모 프로세스의 **동일한 메모리 영역**을 **복사**하여 생성되나, 부모와 자식은 독립적으로 실행되며, 서로 영향을 주지 않는 별도의 프로세스로 동작한다.
  * 마치, github에 포크해오면 원본 repo에 영향을 주지 않지만 내부는 동일하게 가져오는 것과 같은 원리

#### 7) `exec()`와 `fork()`의 차이

* `fork()`는 **기존 프로세스를 복사하여 새 프로세스를 생성**한다.
* `exec()`는 **현재 프로세스를 새로운 프로그램으로 변경**한다.

```c
pid_t pid = fork();
if (pid == 0) {
    // 자식 프로세스
    execl("/bin/ls", "ls", "-l", NULL);  // 현재 프로세스를 "ls -l"로 변경
}
```

이렇게 하면 자식 프로세스가 `ls -l` 명령을 실행하게 된다.

#### 8) 정리

1. `fork()`는 **현재 프로세스를 복사하여 새로운 프로세스를 생성**한다.
2. 부모 프로세스는 `fork()`의 반환값으로 **자식의 PID를 받음**.
3. 자식 프로세스는 `fork()`의 반환값으로 **0을 받음**.
4. `Copy-on-Write(CoW)` 방식으로 **메모리 복사 비용을 최소화**한다.
   1. 기존 프로그램을 **하드디스크에서 로드하는 방식이 아니라 메모리에서 복사**하는 방식이기 때문에 생성 속도가 빠르다.
   2. `fork()`를 이용하면 여러 개의 프로세스를 생성할 수 있으므로 다중 작업이 가능하다.
   3. 자식 프로세스가 종료되면, 자식이 사용했던 **메모리 및 자원을 부모 프로세스가 정리**할 수 있다.
      * 이를 통해 **불필요한 리소스 낭비를 방지**할 수 있다.
5. `exec()`를 호출하면 **새로운 프로그램으로 실행 프로세스를 교체**할 수 있다.

#### 9) 부모와 자식의 데이터는 별개이다! <a href="#undefined" id="undefined"></a>

**왜 fork라는 함수 이름을 가졌을까?**

![](https://velog.velcdn.com/images/heydy/post/828df0fd-5a57-44e1-8194-e77541b41870/image.png)

**`fork()`**&#xC758; 호출 및 생성 과정을 시각적으로 보면 프로세스가 두 갈래로 나뉘는 것처럼 보이는데, 말그대로 포크와 유사합니다.

**유닉스 철학**에서의 비유하자면 유닉스 시스템에서, **`fork()`**&#xB294; 새로운 작업을 **병렬적**으로 처리하는 데 필수적인 도구입니다.

시스템의 흐름에서 실행 중인 프로세스를 복제하여 **독립적인** 두 작업이 서로 다른 경로를 갈라져 수행된다는 점이 중요하다는 것!

우리는 이 **독립적**이라는 키워드에 집중해보자.\
부모 프로세스와 자식 프로세스의 지역변수는 느낌적인 느낌만으로도 각각 다른 값을 가진다는 것을 알 수 있다

전역변수는 뭔가 공유를 할것만 같은 느낌이 들지만, 전역변수조차도 두 프로세스에서 각각 다른값을 가진다.

#### 10) **`fork()`와 GitHub Fork**

#### **🔹 `fork()`와 GitHub Fork의 공통점**

1. **원본과 독립적인 복사본 생성**
   * `fork()`는 부모 프로세스의 메모리를 복사하여 새로운 **자식 프로세스**를 만든다.
   * GitHub의 포크도 원본 레포지토리를 그대로 복사하여 **독립적인 레포지토리**를 만든다.
2. **초기 상태는 동일하지만, 변경은 개별적으로 가능**
   * `fork()`에서 부모와 자식은 처음에는 같은 메모리를 공유하지만, 이후에는 **서로 다른 실행 흐름을 가질 수 있다.**
   * GitHub에서도 처음에는 원본과 같지만, 이후에는 **각 포크에서 개별적으로 코드 변경 가능**하다.
3. **원본에 영향을 주지 않음**
   * `fork()`를 호출해도 부모 프로세스는 원래대로 실행되고, 자식 프로세스는 독립적으로 실행된다.
   * GitHub에서 레포를 포크해도 원본 레포지토리는 영향을 받지 않는다.

#### **🔹 차이점**

* `fork()`는 **메모리를 복사**해서 프로세스를 생성하지만, GitHub의 Fork는 **파일과 코드 히스토리를 복사**하는 개념이다.
* `fork()`의 자식 프로세스는 부모 프로세스 종료 후에도 독립적으로 실행될 수 있지만, GitHub의 포크된 레포지토리는 원본과 다시 합쳐질 수도 있다.

### **3️⃣** 다른 프로그램을 기동하는 execve() 함수





