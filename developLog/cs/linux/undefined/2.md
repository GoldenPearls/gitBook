---
icon: '2'
---

# 2장 : 프로세스 관리(기초편)

> **ps aux** 명령어를 사용해서 현재 실행 중인 모든 프로세스를 확인하는 방법과,\
> 리눅스에서 프로세스가 어떻게 관리되는지를 살펴보는 과정이다.

## 1. 개요&#x20;

### **1️⃣ 리눅스에서 프로세스를 확인하는 방법**

리눅스에서는 **프로세스를 관리하고 모니터링하는 여러 명령어**가 존재한다.\
가장 기본적인 명령어가 바로 `ps`

#### **🔹 `ps aux` 명령어란?**

```sh
$ ps aux
```

* `a` : **모든 사용자**의 프로세스를 표시
* `u` : 프로세스를 **소유한 사용자 정보 포함**
* `x` : **터미널과 연결되지 않은 프로세스**도 포함 (데몬 프로세스 등)

#### **🔹 `ps aux` 실행 결과 예시**

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
sat      19261  0.0  0.0  13840  5360 ?        S    18:24   0:00 sshd: sat@pts/8
sat      19262  0.0  0.0  12120  5232 pts/8    Ss   18:24   0:00 -bash
sat      19280  0.0  0.0  12752  3692 pts/0    R+   18:25   0:00 ps aux
```

* 줄마다 하나의 프로세스를 표시
* ssh 서버인 sshd(PID=19261)가 bash(PID=19262)를 실행하고 거기서 ps aux를 실행했음
* ps 명령어는 --no-header 옵션으로 헤더 출력을 제거 가능

#### **🔹 각 필드 설명**

| 필드          | 설명                        |
| ----------- | ------------------------- |
| **USER**    | 프로세스를 실행한 사용자             |
| **PID**     | 프로세스 ID                   |
| **%CPU**    | CPU 사용량 (비율)              |
| **%MEM**    | 메모리 사용량 (비율)              |
| **VSZ**     | 가상 메모리 사용량 (KB 단위)        |
| **RSS**     | 실제 물리적 메모리 사용량 (KB 단위)    |
| **TTY**     | 연결된 터미널 (없으면 `?`)         |
| **STAT**    | 프로세스 상태 (`S`, `R`, `Z` 등) |
| **START**   | 프로세스가 시작된 시간              |
| **TIME**    | CPU 실행 시간                 |
| **COMMAND** | 실행된 명령어                   |

### **2️⃣ `ps aux` 실행 결과 분석**

위의 예제에서는 **프로세스 관계**를 확인할 수 있다.

1. `ssh 서버 (sshd, PID 19261)`이 사용자 `sat`의 로그인 요청을 받아들임.
2. `sshd`는 `bash (PID 19262)` 셸을 실행함.
3. 사용자는 터미널에서 `ps aux (PID 19280)`을 실행하여 프로세스 목록을 확인.

> 즉, **프로세스 간 부모-자식 관계**가 있다는 걸 알 수 있다.

### **3️⃣ 프로세스 개수 확인**

리눅스 시스템에서 실행 중인 프로세스 개수를 확인하는 방법:

```sh
$ ps aux --no-header | wc -l
```

<figure><img src="../../../.gitbook/assets/image (201).png" alt=""><figcaption></figcaption></figure>

* `--no-header` : 헤더(열 이름)를 제외하고 출력
* `wc -l` : 줄(line) 수를 세어 프로세스 개수 확인

결과:

```
216
```

즉, 현재 시스템에는 **216개의 프로세스**가 실행 중이라는 의미



### **✅ 프로세스 관리 명령어 모음**

| **명령어**    | **설명**                                                  | **사용 예시**                                                                    |
| ---------- | ------------------------------------------------------- | ---------------------------------------------------------------------------- |
| `ps aux`   | 현재 실행 중인 **모든 프로세스 목록 출력**                              | <p><code>ps aux</code> <br>→ 전체 프로세스 확인</p>                                  |
| `ps -ef`   | **풀 포맷(full format)으로 프로세스 정보 표시**                      | <p><code>ps -ef</code> <br>→ UID, PID 등 자세한 정보 표시</p>                        |
| `top`      | **실시간 프로세스 모니터링** (CPU, 메모리 사용량 확인)                     | <p><code>top</code> </p><p>→ CPU 점유율 높은 프로세스 확인</p>                          |
| `htop`     | `top`의 개선 버전, **컬러 UI 제공 및 키보드/마우스 지원**                 | <p><code>htop</code> <br>→ 인터랙티브한 프로세스 관리</p>                                |
| `pidof`    | 특정 프로세스의 **PID(프로세스 ID) 찾기**                            | <p><code>pidof nginx</code> <br>→ <code>nginx</code>의 PID 출력</p>             |
| `pgrep`    | 특정 문자열을 포함하는 **프로세스명으로 PID 검색**                         | <p><code>pgrep -l sshd</code> <br>→ <code>sshd</code> 관련 프로세스 찾기</p>         |
| `kill`     | 특정 **PID의 프로세스를 종료**                                    | <p><code>kill 1234</code> <br>→ PID 1234 종료</p>                              |
| `kill -9`  | 프로세스를 **강제 종료** (`SIGKILL` 시그널)                         | <p><code>kill -9 1234</code> <br>→ 강제 종료</p>                                 |
| `pkill`    | **프로세스명을 기반으로 종료**                                      | <p><code>pkill nginx</code> <br>→ <code>nginx</code> 종료</p>                  |
| `pkill -f` | **전체 명령어 문자열을 기준으로 종료**                                 | `pkill -f "python my_script.py"`                                             |
| `nice`     | **프로세스 실행 시 우선순위 설정** (기본값 0, `-20`이 가장 높고 `19`가 가장 낮음) | <p><code>nice -n 10 myapp</code> <br>→ 낮은 우선순위로 실행</p>                       |
| `renice`   | 실행 중인 **프로세스의 우선순위 변경**                                 | <p><code>renice -5 1234</code> <br>→ PID 1234의 우선순위를 <code>-5</code>로 변경</p> |
| `watch`    | 특정 명령을 **주기적으로 실행**하여 변화를 모니터링                          | <p><code>watch -n 1 ps aux</code> <br>→ 1초마다 <code>ps aux</code> 실행</p>      |
| `strace`   | 프로세스가 호출하는 **시스템 호출(syscall) 실시간 추적**                   | <p><code>strace -p 1234</code> <br>→ PID 1234의 시스템 호출 추적</p>                 |
| `lsof`     | **프로세스가 열고 있는 파일 목록 확인**                                | <p><code>lsof -p 1234</code> <br>→ PID 1234가 사용하는 파일 확인</p>                  |
| `netstat`  | **네트워크 연결 상태 및 프로세스 확인**                                | <p><code>netstat -tulnp</code> <br>→ 포트와 프로세스 매핑</p>                         |
| `ss`       | `netstat`의 대체 명령어, **더 빠르고 자세한 네트워크 정보 제공**             | <p><code>ss -tulnp</code> <br>→ 프로세스와 포트 정보 확인</p>                           |
| `uptime`   | **시스템 가동 시간 및 평균 부하(load average) 확인**                  | <p><code>uptime</code> <br>→ 시스템이 얼마나 오랫동안 실행되었는지 확인</p>                     |
| `vmstat`   | **CPU, 메모리, 스왑 사용량 실시간 모니터링**                           | <p><code>vmstat 1</code> <br>→ 1초 간격으로 시스템 상태 확인</p>                         |
| `iotop`    | **디스크 I/O 사용량을 실시간 모니터링**                               | <p><code>iotop</code> <br>→ 가장 많이 디스크를 사용하는 프로세스 확인</p>                      |
| `free -m`  | **메모리 사용량 확인** (`-m` 옵션으로 MB 단위 표시)                     | <p><code>free -m</code> <br>→ 사용 가능한 RAM 확인</p>                              |
| `df -h`    | **디스크 사용량 확인** (`-h` 옵션으로 사람이 읽기 쉬운 형식)                 | <p><code>df -h</code> <br>→ 파일 시스템별 디스크 사용량 확인</p>                           |

### **결론**&#x20;

<figure><img src="../../../.gitbook/assets/image (202).png" alt=""><figcaption><p><code>watch -n 1 ps aux</code></p></figcaption></figure>

* `ps aux`를 사용하면 **현재 실행 중인 모든 프로세스를 확인**할 수 있음.
* `ps aux --no-header | wc -l`을 사용하면 **현재 실행 중인 프로세스 개수**를 알 수 있음.
* 리눅스는 다양한 프로세스를 **백그라운드와 포그라운드에서 관리**하며,\
  이를 위해 프로세스 스케줄링과 상태 관리가 이루어짐.



## 2. 프로세스 생성

### **1️⃣ 프로세스 생성 목적**

1. **동일한 프로그램 처리를 여러 프로세스에 나눠서 처리하기(Ex. 웹서버에서 다수의 요청 받기)**

* fork() 함수만 사용

2. **다른 프로그램을 생성하기(ex. bash에서 각종 프로그램을 생성)**

* fork()와 execve() 함수 둘 다 사용!

> 목적에 따라 프로세스 생성을 실제로 실행하는 방법으로는 리눅스는 fork() 함수와 execve() 함수를 사> \
> 용

### **2️⃣** 같은 프로세스를 두 개로 분열시키는 fork() 함수

<figure><img src="../../../.gitbook/assets/image (198).png" alt=""><figcaption></figcaption></figure>

#### 1) `fork()` 함수란?

`fork()` 함수는 **현재 실행 중인 프로세스를 복사**해서 새로운 프로세스를 생성하는 함수이다.

즉, **같은 프로세스를 두 개로 분열시키는 역할**을 한다.

> fork 동작은 <mark style="color:red;">부모 프로세스가 자기 자신을 복제하는 시스템 호출</mark>로, 유닉스 계열 운영 체제에서 프로세스를 만드는 주된 방식

#### 2) `fork()` 함수의 동작 과정

<figure><img src="../../../.gitbook/assets/image (197).png" alt=""><figcaption><p>출처 : <a href="https://kylo8.tistory.com/entry/OS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%B3%B5%EC%82%AC-fork-exec-%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%98%B8%EC%B6%9C">https://kylo8.tistory.com/entry/OS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%B3%B5%EC%82%AC-fork-exec-%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%98%B8%EC%B6%9C</a></p></figcaption></figure>

{% hint style="warning" %}
원본 프로세스를 `부모 프로세스`, 생성된 프로세스를 `자식 프로세스`
{% endhint %}

1. **부모 프로세스가 `fork()` 호출**
   * `fork()`가 실행되면 커널이 **새로운 프로세스를 생성**한다.
2. **커널이 부모 프로세스의 메모리를 자식 프로세스에 복사**
   * 하지만 실제로는 **Copy-on-Write(CoW)** 덕분에 **메모리 전체를 즉시 복사하지 않는다**.
   * 자식 프로세스가 특정 메모리를 변경할 때만 복사됨.
   * 부모 프로세스의 주소 공간을 <mark style="color:red;">Binary 통째로 복사</mark>
3. **부모와 자식 프로세스가 각각 `fork()`에서 복귀**
   * **부모 프로세스**는 `fork()`의 반환값으로 **자식 프로세스의 PID를 받음**.
   * **자식 프로세스**는 `fork()`의 반환값으로 **0을 받음**.
   * 이를 이용해 **부모와 자식을 구별**할 수 있음.
   * fork 함수 호출 **이후 코드**부터 <mark style="color:red;">각자의 메모리를 사용하여 실행</mark>
4. **부모 프로세스(326)**
   * **PID (프로세스 ID):** `326` → 부모 프로세스의 고유 ID
   * **PPID (부모 프로세스 ID):** `123` → 부모 프로세스도 상위 부모(예: `init` 프로세스)가 있음
   * **CPID (자식 프로세스 ID):** `368` → `fork()`를 실행한 후 생성된 자식 프로세스의 PID
5. **자식 프로세스(368)**
   * **PID (프로세스 ID):** `368` → 새롭게 생성된 자식 프로세스의 고유 ID
   * **PPID (부모 프로세스 ID):** `326` → 자식 프로세스의 부모가 **PID 326(부모 프로세스)임을 나타냄**
   * **CPID (자식 프로세스 ID):** `-1` → `fork()` 직후에는 자식 프로세스가 새 자식 프로세스를 생성하지 않았기 때문에 `-1`로 표시

<figure><img src="../../../.gitbook/assets/image (199).png" alt=""><figcaption></figcaption></figure>

#### 3) `fork()`를 사용한 프로세스 생성 예제 (Python)

아래 Python 코드를 실행하면 `fork()`가 실행된 후 **부모와 자식 프로세스가 각각 분기**된다.

**📌 `fork.py` (프로세스 분기 코드)**

```python
#!/usr/bin/python3
import os, sys

ret = os.fork()  # 새로운 프로세스 생성

if ret == 0:
    # 자식 프로세스 실행
    print("자식 프로세스: pid={}, 부모 프로세스의 pid={}".format(os.getpid(), os.getppid()))
    sys.exit(0)  # 자식 프로세스 종료
elif ret > 0:
    # 부모 프로세스 실행
    print("부모 프로세스: pid={}, 자식 프로세스의 pid={}".format(os.getpid(), ret))
    sys.exit(0)  # 부모 프로세스 종료
```

**📌 실행 결과**

<figure><img src="../../../.gitbook/assets/image (203).png" alt=""><figcaption></figcaption></figure>

```sh
$ ./fork.py
부모 프로세스: pid=132767, 자식 프로세스의 pid=132768
자식 프로세스: pid=132768, 부모 프로세스의 pid=132767
```

이 결과를 보면 **프로세스가 두 개로 나뉜 것을 확인할 수 있다**.

* 부모 프로세스(132767)가 `fork()`를 호출하여 **자식 프로세스(132768)를 생성**.
* 이후 `fork()`의 반환값을 이용해 **부모와 자식을 구별**할 수 있다.

#### 4) `fork()`의 반환값을 이용한 부모-자식 구분

`fork()`를 호출한 후 반환값을 확인하면 된다.

| **반환값**    | **설명**                                   |
| ---------- | ---------------------------------------- |
| `0`        | **자식 프로세스**에서 반환됨                        |
| `>0` (PID) | **부모 프로세스**에서 반환되며, 생성된 자식 프로세스의 PID를 가짐 |
| `<0`       | 오류 발생 (프로세스 생성 실패)                       |

이 특성을 이용해 **부모와 자식 프로세스의 실행 흐름을 분기**할 수 있다.

#### 5) `fork()` 호출 후 부모와 자식의 실행 흐름

<figure><img src="../../../.gitbook/assets/image (200).png" alt=""><figcaption></figcaption></figure>

* `fork()` 이후 부모와 자식은 **완전히 독립된 프로세스**로 실행된다.
* 하지만 자식 프로세스는 **부모의 메모리 복사본을 사용**하기 때문에 **초기 상태는 동일**하다.

```sh
부모 프로세스 (PID=132767) 실행
 ├── fork() 호출 → 새로운 프로세스 생성
 │
 ├── 부모 프로세스는 `fork()`의 반환값으로 `132768`을 받음
 │   └── 부모 프로세스: pid=132767, 자식 프로세스의 pid=132768
 │
 ├── 자식 프로세스는 `fork()`의 반환값으로 `0`을 받음, 자식 프로세스는 fork()의 결과로 자신이 부모로부터 생성되었다는 것만 알 수 있다.
 │   └── 자식 프로세스: pid=132768, 부모 프로세스의 pid=132767
```

**`fork()` 실행 전**

```sh
부모 프로세스 (PID=132767) 실행 중
```

**`fork()` 실행 후**

```sh
부모 프로세스 (PID=132767)  ──>   자식 프로세스 (PID=132768)
```

* 부모는 `fork()`의 반환값으로 **132768 (자식의 PID)를 받음.**
* 자식은 `fork()`의 반환값으로 **0을 받음.**
* 부모의 PID는 그대로 유지되며, 새로운 프로세스(자식)가 생긴 것뿐이다.

#### 6) `fork()`의 메모리 복사 방식 (Copy-on-Write)

* `fork()`는 **부모 프로세스의 메모리를 그대로 복사하는 것처럼 보인다.**
  * <mark style="color:red;">하지만</mark> <mark style="color:red;"></mark><mark style="color:red;">**실제로는 Copy-on-Write(CoW) 방식**</mark><mark style="color:red;">을 사용한다.</mark>
  * 즉, **자식이 데이터를 변경할 때만 새로운 메모리 공간을 할당**한다.
  * 부모 프로세스와 자식 프로세스가 차지하고 있는 **메모리 위치가 다르기 때문에 메모리 관련 정보도 변경된다.**
  * 복제된 프로세스는 부모 프로세스의 **동일한 메모리 영역**을 **복사**하여 생성되나, 부모와 자식은 독립적으로 실행되며, 서로 영향을 주지 않는 별도의 프로세스로 동작한다.
  * 마치, github에 포크해오면 원본 repo에 영향을 주지 않지만 내부는 동일하게 가져오는 것과 같은 원리

#### 7) `exec()`와 `fork()`의 차이

* `fork()`는 **기존 프로세스를 복사하여 새 프로세스를 생성**한다.
* `exec()`는 **현재 프로세스를 새로운 프로그램으로 변경**한다.

```c
pid_t pid = fork();
if (pid == 0) {
    // 자식 프로세스
    execl("/bin/ls", "ls", "-l", NULL);  // 현재 프로세스를 "ls -l"로 변경
}
```

이렇게 하면 자식 프로세스가 `ls -l` 명령을 실행하게 된다.

#### 8) 정리

1. `fork()`는 **현재 프로세스를 복사하여 새로운 프로세스를 생성**한다.
2. 부모 프로세스는 `fork()`의 반환값으로 **자식의 PID를 받음**.
3. 자식 프로세스는 `fork()`의 반환값으로 **0을 받음**.
4. `Copy-on-Write(CoW)` 방식으로 **메모리 복사 비용을 최소화**한다.
   1. 기존 프로그램을 **하드디스크에서 로드하는 방식이 아니라 메모리에서 복사**하는 방식이기 때문에 생성 속도가 빠르다.
   2. `fork()`를 이용하면 여러 개의 프로세스를 생성할 수 있으므로 다중 작업이 가능하다.
   3. 자식 프로세스가 종료되면, 자식이 사용했던 **메모리 및 자원을 부모 프로세스가 정리**할 수 있다.
      * 이를 통해 **불필요한 리소스 낭비를 방지**할 수 있다.
5. `exec()`를 호출하면 **새로운 프로그램으로 실행 프로세스를 교체**할 수 있다.

#### 9) 부모와 자식의 데이터는 별개이다! <a href="#undefined" id="undefined"></a>

**왜 fork라는 함수 이름을 가졌을까?**

![](https://velog.velcdn.com/images/heydy/post/828df0fd-5a57-44e1-8194-e77541b41870/image.png)

**`fork()`**&#xC758; 호출 및 생성 과정을 시각적으로 보면 프로세스가 두 갈래로 나뉘는 것처럼 보이는데, 말그대로 포크와 유사합니다.

**유닉스 철학**에서의 비유하자면 유닉스 시스템에서, **`fork()`**&#xB294; 새로운 작업을 **병렬적**으로 처리하는 데 필수적인 도구입니다.

시스템의 흐름에서 실행 중인 프로세스를 복제하여 **독립적인** 두 작업이 서로 다른 경로를 갈라져 수행된다는 점이 중요하다는 것!

우리는 이 **독립적**이라는 키워드에 집중해보자.\
부모 프로세스와 자식 프로세스의 지역변수는 느낌적인 느낌만으로도 각각 다른 값을 가진다는 것을 알 수 있다

전역변수는 뭔가 공유를 할것만 같은 느낌이 들지만, 전역변수조차도 두 프로세스에서 각각 다른값을 가진다.

#### 10) **`fork()`와 GitHub Fork**

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

#### **🔹 `fork()`와 GitHub Fork의 공통점**

1. **원본과 독립적인 복사본 생성**
   * `fork()`는 부모 프로세스의 메모리를 복사하여 새로운 **자식 프로세스**를 만든다.
   * GitHub의 포크도 원본 레포지토리를 그대로 복사하여 **독립적인 레포지토리**를 만든다.
2. **초기 상태는 동일하지만, 변경은 개별적으로 가능**
   * `fork()`에서 부모와 자식은 처음에는 같은 메모리를 공유하지만, 이후에는 **서로 다른 실행 흐름을 가질 수 있다.**
   * GitHub에서도 처음에는 원본과 같지만, 이후에는 **각 포크에서 개별적으로 코드 변경 가능**하다.
3. **원본에 영향을 주지 않음**
   * `fork()`를 호출해도 부모 프로세스는 원래대로 실행되고, 자식 프로세스는 독립적으로 실행된다.
   * GitHub에서 레포를 포크해도 원본 레포지토리는 영향을 받지 않는다.

#### **🔹 차이점**

* `fork()`는 **메모리를 복사**해서 프로세스를 생성하지만, GitHub의 Fork는 **파일과 코드 히스토리를 복사**하는 개념이다.
* `fork()`의 자식 프로세스는 부모 프로세스 종료 후에도 독립적으로 실행될 수 있지만, GitHub의 포크된 레포지토리는 원본과 다시 합쳐질 수도 있다.

### **3️⃣** 다른 프로그램을 기동하는 execve() 함수

> fork() 함수로 프로세스 복사본을 만들었으면 자식 프로세스에서 execve() 함수를 호출한다. 그러면 자식 프로세스는 새로운 프로그램으로 바뀐다.

#### 1) `execve()` 함수란?

{% hint style="info" %}
`execve()` 함수는 **현재 프로세스를 새로운 프로그램으로 변경**하는 함수이다.\
즉, 기존의 프로세스를 유지하는 것이 아니라, **완전히 다른 프로그램으로 교체**하는 역할을 한다.
{% endhint %}

* `fork()`는 **부모 프로세스를 그대로 복사하여 자식 프로세스를 만드는 함수**이지만,
* `execve()`는 **현재 실행 중인 프로세스를 완전히 새로운 프로그램으로 바꾸는 함수**이다.

> execve 함수는 바이너리 파일이나 스크립트 파일을 실행시키는 함수로, <mark style="color:red;">다른 프로그램을 실행하고 자신은 종료한다.</mark>

#### 2) `execve()` 함수의 동작 과정

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p>출처 : <a href="https://kylo8.tistory.com/entry/OS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%B3%B5%EC%82%AC-fork-exec-%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%98%B8%EC%B6%9C">https://kylo8.tistory.com/entry/OS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%B3%B5%EC%82%AC-fork-exec-%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%98%B8%EC%B6%9C</a></p></figcaption></figure>

1. **`execve()` 호출**
   * 새로운 프로그램을 실행하기 위해 `execve("/bin/echo", ["echo", "Hello"], {})` 같은 호출을 한다.
2. **커널이 실행 파일을 읽음**
   * `execve()`가 호출된 프로세스의 <mark style="color:red;">**메모리를 새로운 프로그램의 데이터로 덮어씀**</mark><mark style="color:red;">.</mark>
   * 이 과정에서 실행 파일의 **코드 영역과 데이터 영역을 메모리에 로드**한다.
3. **현재 프로세스를 새로운 프로그램으로 치환**
   * 이전 프로세스의 **코드, 데이터, 스택, 힙 영역이 모두 새로운 프로그램의 내용으로 대체됨**.
4. **새로운 프로그램이 엔트리 포인트(entry point)에서 실행 시작**
   * `main()` 함수 같은 **프로그램의 시작 지점(엔트리 포인트)부터 실행**됨.

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

> 즉, `execve()`는 **새로운 프로그램을 실행하지만, 기존의 프로세스 ID(PID)는 그대로 유지**된다.

\
프로세스가 종료되는 것이 아니라 **메모리 내용만 새로운 프로그램으로 변경되는 것**이다.

{% hint style="success" %}
**참고 : 프로그램과 프로세스**
{% endhint %}

**`execve()`는 새로운 프로세스를 만드는 것이 아니다**

* `fork()`는 새로운 **프로세스를 생성**하는 함수다. 즉, **새로운 PID를 가진 자식 프로세스가 생성됨**.
* 하지만 `execve()`는 **기존 프로세스를 그대로 유지하면서, 그 프로세스의 코드와 데이터를 새로운 프로그램으로 덮어씌운다.**
* **즉, `execve()`를 호출해도 PID는 변하지 않지만, 실행 중인 프로그램이 완전히 바뀌는 것**이다.



**프로세스 vs. 프로그램**

**프로세스(Process)란?**

* **운영체제가 실행 중인 하나의 작업 단위.**
* CPU에서 실행되며, **고유한 PID(Process ID)를 가짐**.
* 메모리(코드, 데이터, 스택, 힙 등)와 함께 관리됨.

**프로그램(Program)이란?**

* **디스크에 저장된 실행 가능한 바이너리(예: `/bin/ls`, `/usr/bin/python3`)**
* 실행되지 않은 정적인 상태.

💡 **즉, "프로그램"은 실행되기 전의 코드이고, "프로세스"는 실행 중인 프로그램을 의미한다.**

#### 3) `fork()` + `execve()`를 사용한 예제 (`fork-and-exec.py`)

다음 코드에서는 `fork()`를 사용하여 자식 프로세스를 생성한 후,\
자식 프로세스에서 `execve()`를 호출하여 새로운 프로그램(`/bin/echo`)을 실행한다.

**📌 `fork-and-exec.py`**

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

```python
#!/usr/bin/python3
import os, sys

ret = os.fork()  # 새로운 프로세스 생성

if ret == 0:
    # 자식 프로세스에서 실행
    print("자식 프로세스: pid={}, 부모 프로세스 pid={}".format(os.getpid(), os.getppid()))
    
    # execve()를 호출하여 자식 프로세스를 새로운 프로그램으로 교체
    os.execve("/bin/echo", ["echo", "pid={}에서 안녕".format(os.getpid())], {})
    
    # execve()가 실행되면 아래 코드는 실행되지 않음
    sys.exit(0)  
elif ret > 0:
    # 부모 프로세스에서 실행
    print("부모 프로세스: pid={}, 자식 프로세스 pid={}".format(os.getpid(), ret))
    sys.exit(0)  # 부모 프로세스 종료
```

#### 4) 실행 결과

<figure><img src="../../../.gitbook/assets/image (204).png" alt=""><figcaption></figcaption></figure>

```sh
$ ./fork-and-exec.py
부모 프로세스: pid=5843, 자식 프로세스 pid=5844
자식 프로세스: pid=5844, 부모 프로세스 pid=5843
pid=5844에서 안녕
```

**실행 흐름 분석**

1. 부모 프로세스(5843)가 `fork()`를 실행하여 **자식 프로세스(5844)를 생성**한다.
2. 부모 프로세스는 `fork()`에서 자식 프로세스의 PID(5844)를 받음.
3. 자식 프로세스는 `fork()`에서 `0`을 반환받아 실행됨.
4. 자식 프로세스에서 `execve("/bin/echo", ...)`를 실행하여 **현재 프로세스를 `echo` 명령으로 변경**.
5. 기존 자식 프로세스의 메모리는 삭제되고, **`echo` 프로그램의 코드와 데이터로 덮어씌워짐**.
6. `echo` 명령이 실행되어 `"pid=5844에서 안녕"`을 출력.

> **즉, 자식 프로세스는 `execve()`를 실행하면서 기존의 프로그램이 완전히 사라지고, `echo`가 실행된 것**이다.

#### 5) `fork()`와 `execve()`의 차이점

| 기능           | `fork()`                      | `execve()`                             |
| ------------ | ----------------------------- | -------------------------------------- |
| 역할           | **부모 프로세스를 복사하여 새로운 프로세스 생성** | **현재 프로세스를 새로운 프로그램으로 교체**             |
| 실행 후 프로세스 개수 | 기존 + 새로운 프로세스 (2개)            | 기존 프로세스가 새로운 프로그램으로 변경됨 (여전히 1개)       |
| 메모리          | 부모 프로세스의 메모리 복사               | 기존 메모리를 **새로운 프로그램으로 덮어씀**             |
| 사용 예시        | 멀티프로세싱 구현, 부모-자식 프로세스 생성      | 새로운 프로그램 실행 (`bash`, `ls`, `python` 등) |

#### 6) `fork()` + `execve()`를 함께 사용하는 이유

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

1. **멀티프로세스를 만들고 싶다면 `fork()`를 사용**
   * 예: 웹 서버에서 여러 클라이언트 요청을 처리하기 위해 새로운 프로세스를 생성
   * `fork()`를 사용하면 **새로운 프로세스(PID가 다른 프로세스)가 생성됨.**
2. **기존 프로세스를 새로운 프로그램으로 바꾸고 싶다면 `execve()`를 사용**
   * `execve()`를 사용하면 **현재 프로세스의 실행 코드가 새로운 프로그램으로 바뀜.**
   * 예: `ls` 명령 실행, `bash` 같은 셸 실행
3. **보통 `fork()`를 먼저 호출한 후 `execve()`를 실행하는 패턴을 사용**
   * 부모 프로세스는 계속 실행되면서, 자식 프로세스는 `execve()`를 통해 특정 프로그램을 실행할 수 있음.
   * &#x20;**새로운 프로세스를 만든 후, 그 프로세스에서 다른 프로그램을 실행할 수 있음.**
   * 예: 터미널에서 새로운 명령어를 실행할 때, 셸(Bash)이 `fork()`로 새 프로세스를 만들고, `execve()`로 새로운 프로그램을 실행함.
   * `fork()`와 `execve()`를 함께 사용하면 **멀티프로세스를 만들면서 새로운 프로그램을 실행할 수 있음.**

#### **6) `execve()` 실행을 위해 필요한 정보**

`execve()` 함수가 실행되려면 **새로운 프로그램의 코드와 데이터뿐만 아니라 몇 가지 추가적인 정보**가 필요하다.\
이 정보들은 실행 파일에 저장되어 있으며, <mark style="color:blue;">운영체제(커널)는 이를 읽어와 메모리에 적절히 배치해야 한다.</mark>

**필요한 정보**

1. **코드 영역**
   * 실행 파일에서 코드(명령어)가 있는 위치 (파일 오프셋)
     * 오프셋 : **어떤 데이터가 파일이나 메모리에서 어느 위치에 저장되어 있는지를 나타내는 값**
   * 코드 크기
   * 메모리에서 코드가 로드될 주소 (메모리 맵 시작 주소)
2. **데이터 영역**
   * 프로그램의 전역 변수와 초기화된 데이터가 저장되는 영역
   * 파일에서 데이터가 위치한 오프셋
   * 데이터 크기 및 메모리 맵 시작 주소
3. **엔트리 포인트 (Entry Point)**
   * **프로그램이 처음 실행될 때 시작할 위치**
   * `main()` 함수가 호출되기 전의 **실제 코드 시작 주소**

#### **7) 실행 파일의 구조와 ELF 포맷**

리눅스에서 <mark style="color:red;">실행 파일</mark>은 보통 **ELF(Executable and Linking Format)** 포맷을 사용한다.\
<mark style="color:blue;">ELF 파일에는</mark> <mark style="color:blue;"></mark><mark style="color:blue;">**프로그램을 실행하는 데 필요한 모든 정보**</mark><mark style="color:blue;">가 포함되어 있다.</mark>

이 정보를 확인하기 위해 `readelf` 명령어를 사용할 수 있다.

```sh
$ readelf -h pause
```

**출력 예시**

<figure><img src="../../../.gitbook/assets/image (206).png" alt=""><figcaption></figcaption></figure>

```
Entry point address: 0x400400
```

* **Entry Point Address (0x400400)** → 이 주소에서 프로그램 실행이 시작됨.

#### **8) ELF 파일의 섹션 정보 확인**

ELF 실행 파일은 여러 `섹션(section)`으로 구성된다.\
각 섹션에는 **코드, 데이터, 심볼 테이블 등** 다양한 정보가 포함된다.

```sh
$ readelf -S pause
```

**출력 예시**

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

| 섹션명     | 설명               | 메모리 주소     | 파일 오프셋   | 크기      |
| ------- | ---------------- | ---------- | -------- | ------- |
| `.text` | 실행 코드 영역         | `0x400400` | `0x400`  | `0x172` |
| `.data` | 데이터 영역 (전역 변수 등) | `0x601020` | `0x1020` | `0x10`  |

| **항목**                    | **설명**                               | **해당 값**          |
| ------------------------- | ------------------------------------ | ----------------- |
| **코드 영역 (TEXT SECTION)**  | 실행 파일에서 \*\*코드(명령어)\*\*가 위치하는 곳      | `.text`           |
| **코드의 파일 오프셋**            | 실행 파일 내에서 코드가 **어디부터 시작하는지** 나타내는 값  | `0x400`           |
| **코드 크기**                 | 코드(명령어)의 총 크기                        | `0x172` (370 바이트) |
| **메모리 맵 시작 주소**           | 실행될 때 메모리에 로드될 주소                    | `0x400400`        |
| **데이터 영역 (DATA SECTION)** | 전역 변수, 초기화된 데이터가 저장되는 공간             | `.data`           |
| **데이터의 파일 오프셋**           | 실행 파일 내에서 데이터가 **어디부터 시작하는지** 나타내는 값 | `0x1020`          |
| **데이터 크기**                | 데이터 영역의 총 크기                         | `0x10` (16 바이트)   |
| **메모리 맵 시작 주소**           | 실행될 때 메모리에 로드될 주소                    | `0x601020`        |
| **엔트리 포인트 (Entry Point)** | 프로그램이 처음 실행될 때 시작할 위치 (main() 호출 전)  | `0x400400`        |

**설명**

* `.text` → **실제 실행 코드(명령어)**
* `.data` → **전역 변수, 초기화된 데이터**
* `.bss` → 초기화되지 않은 전역 변수

이 정보를 기반으로 운영체제는 **코드를 실행할 적절한 메모리 주소에 배치**한다.

#### **8) 프로그램 실행 시 메모리 맵 확인**

프로그램이 실행되면 운영체제는 ELF 파일의 코드와 데이터를 **메모리에 로드**한다.

> 메모리 맵을 확인하면, **파일에서 읽어온 코드와 데이터가 메모리 어디에 위치하는지** 알 수 있다.

**메모리 맵 확인 방법**

1. `pause` 프로그램을 실행한 후 백그라운드로 실행

```sh
$ ./pause &
[3] 12492
```

2. 프로세스의 메모리 맵 확인

```sh
$ cat /proc/12492/maps
```

**출력 예시**

<figure><img src="../../../.gitbook/assets/image (207).png" alt=""><figcaption><p>rw-p : 읽기 쓰기가 가능한 데이터 영역, r--p : 데이터 영역, r--xp : 코드 영역</p></figcaption></figure>

```
00400000-00401000 r-xp 00000000 08:02 788371 .../pause
00600000-00601000 r--p 00000000 08:02 788371 .../pause
00601000-00602000 rw-p 00001000 08:02 788371 .../pause
```

| 주소 범위               | 권한     | 파일 오프셋     | 설명                                  |
| ------------------- | ------ | ---------- | ----------------------------------- |
| `00400000-00401000` | `r-xp` | `00000000` | **코드 영역 (TEXT SECTION)**            |
| `00600000-00601000` | `r--p` | `00000000` | **데이터 영역 (READ-ONLY SECTION)**      |
| `00601000-00602000` | `rw-p` | `00001000` | **읽기/쓰기 가능한 데이터 영역 (DATA SECTION)** |

#### **10) 핵심 정리**

1. **`execve()`를 실행하면 운영체제는 실행 파일(ELF)에서 필요한 정보를 읽고, 프로세스의 메모리를 새로운 프로그램으로 교체한다.**
2. **운영체제는 ELF 파일을 로드하면서 다음 정보를 사용한다.**
   * **코드 섹션 (`.text`)** → 실행할 코드가 있는 메모리 주소
   * **데이터 섹션 (`.data`)** → 전역 변수, 초기화된 데이터
   * **엔트리 포인트 (Entry Point)** → 실행 시작 주소 (`0x400400`)
3. **프로그램이 실행되면 `/proc/<pid>/maps`에서 메모리 맵을 확인할 수 있다.**
4. **실행 파일의 섹션 정보는 `readelf -S` 명령어로 확인 가능하다.**
5. **메모리 맵을 보면, 실행 파일의 코드와 데이터가 메모리에 어떻게 배치되는지 알 수 있다.**

***

### 4️⃣ ASLR로 보안 강화

#### **1) `-no-pie` 옵션이란?**

`-no-pie` 옵션은 **PIE(Position Independent Executable)** 기능을 비활성화하는 GCC(컴파일러) 옵션이다.\
기본적으로 최신 리눅스 배포판에서는 **PIE가 활성화된 상태로 프로그램을 빌드**한다.

* **PIE(위치 독립 실행 파일, Position Independent Executable)이란?**
  * 실행 파일이 **고정된 주소가 아닌, 실행될 때마다 다른 주소에 로드되는 실행 파일**을 의미한다.
  * ASLR(Address Space Layout Randomization)이라는 <mark style="color:red;">보안 기능을 활용하여 실행 위치를 매번 다르게 설정한다.</mark>

`-no-pie` 옵션을 사용하면 **PIE 기능을 끄고 실행 파일이 고정된 주소에서 실행**되도록 만든다.

#### **2) ASLR(Address Space Layout Randomization)이란?**

{% hint style="warning" %}
`ASLR(주소 공간 배치 랜덤화)`는 **프로그램을 실행할 때마다 코드, 데이터, 라이브러리 등이 메모리에서 로드되는 위치를 변경하는 보안 기술**이다.
{% endhint %}

**ASLR의 주요 기능**

1. **프로그램 실행 시 메모리 배치를 랜덤하게 변경** → 해커가 코드 실행 위치를 예측하기 어렵게 함.
2. **버퍼 오버플로우 공격 등을 어렵게 만듦** → 특정 메모리 주소를 이용한 공격을 방지.

**ASLR 활성화 여부 확인**

<figure><img src="../../../.gitbook/assets/image (208).png" alt=""><figcaption></figcaption></figure>

```sh
$ cat /proc/sys/kernel/randomize_va_space
2  # 2면 ASLR 활성화 (기본 설정)
```

**ASLR 비활성화(테스트용)**

```sh
$ sudo sysctl -w kernel.randomize_va_space=0
```

#### **3) `-no-pie` 옵션이 필요한 이유**

기본적으로 최신 리눅스에서는 **모든 실행 파일이 PIE로 빌드된다.**\
그러나 `-no-pie` 옵션을 사용하면 실행 파일을 **PIE가 아닌&#x20;**<mark style="color:red;">**정적 주소에 배치되는 형태로 빌드**</mark>할 수 있다.

**PIE vs. -no-pie 실행 파일 차이**

```sh
$ file pause
pause: ELF 64-bit LSB shared object, ...
```

* **PIE 적용됨** → "shared object"라고 표시됨.

<figure><img src="../../../.gitbook/assets/image (209).png" alt=""><figcaption></figcaption></figure>

* 실행할 때마다 메모리 매핑 주소가 바뀜.

```sh
$ file pause
pause: ELF 64-bit LSB executable, ...
```

* **PIE 적용되지 않음 (`-no-pie` 사용)** → "executable"이라고 표시됨.
* 항상 **고정된 메모리 주소에서 실행됨.**

#### **4) ASLR이 적용된 실행 파일의 메모리 매핑 확인**

```sh
$ cc -o pause pause.c
$ ./pause &
[5] 15406
$ cat /proc/15406/maps
559c5778f000-559c57790000 r-xp 00000000 08:02 788372
.../pause
...
$ ./pause &
[6] 15536
$ cat /proc/15536/maps
5568d2506000-5568d2507000 r-xp 00000000 08:02 788372
.../pause
```

* 실행할 때마다 **메모리 주소가 다름** → **ASLR이 적용됨.**

**PIE를 비활성화하고 실행하면?**

```sh
$ cc -o pause -no-pie pause.c
$ ./pause &
[7] 15678
$ cat /proc/15678/maps
00400000-00401000 r-xp 00000000 08:02 788372
.../pause
```

* 실행할 때마다 **고정된 주소(`0x400000`)에서 실행됨.** → PIE가 적용되지 않음.

<figure><img src="../../../.gitbook/assets/image (211).png" alt=""><figcaption><p>cat /proc/1687/maps</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (212).png" alt=""><figcaption><p>cat /proc/1691/maps</p></figcaption></figure>

#### **5) `-no-pie` 옵션을 사용하는 이유**

1. **메모리 주소가 바뀌지 않게 하려면 `-no-pie`를 사용해야 한다.**
   * PIE가 적용된 실행 파일은 **실행할 때마다 다른 주소에 로드**되므로,\
     메모리 맵을 확인할 때마다 값이 달라질 수 있다.
   * 특정 주소에서 실행되는지 확인하는 실습을 하려면 **PIE를 비활성화해야 한다.**
2. **ELF 파일을 분석할 때 PIE를 비활성화하는 것이 더 직관적이다.**
   * 실행 파일을 디버깅하거나 **파일 오프셋과 메모리 주소를 비교할 때 PIE가 있으면 값이 변동**된다.
   * 예제 코드의 실행 결과가 변하지 않도록 하기 위해 PIE를 끄고 테스트한다

6\) **다시 ASLR을 사용하려면**

```shell
 gcc -fPIE -pie -o pause pause.c
```

## 3. 프로세스의 부모 자식 관계때마다 메모리 주소가 다름&#x20;

### 1️⃣ **프로세스의 조상은 무엇인가?**

우리는 `fork()`를 통해 **부모 프로세스가 자식 프로세스를 생성**한다는 것을 알고 있다.\
그렇다면 **부모 프로세스의 부모는 누구인지**, **궁극적으로 가장 최상위 프로세스는 무엇인지** 확인해보자.

컴퓨터가 부팅될 때 **다음과 같은 순서로 시스템이 초기화**된다.

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

**1. 컴퓨터 전원을 켠다**

<figure><img src="../../../.gitbook/assets/image (214).png" alt=""><figcaption></figcaption></figure>

* **전원이 공급되면 CPU는 기본적으로 `0xFFFFFFF0` 주소에서 실행을 시작**한다.
*   여기에는 `BIOS (Basic Input/Output System) 또는 UEFI (Unified Extensible Firmware Interface)`가 위치한다.

    * `BIOS`는 컴퓨터가 켜질 때 가장 먼저 실행되는 펌웨어로, 하드웨어를 초기화하고 운영체제를 부팅하는 역할을 한다.
    * **메인보드(마더보드)에 내장된 펌웨어**로, 컴퓨터 전원을 켜자마자 가장 먼저 실행된다.
    * 운영체제는  아니고 하드웨어 수준의 소프트웨어

    | 구분           | BIOS         | UEFI                    |
    | ------------ | ------------ | ----------------------- |
    | 등장 시기        | 오래됨 (1980년대) | 비교적 최신 (2010년대)         |
    | 부팅 속도        | 느림           | 빠름                      |
    | 인터페이스        | 텍스트 기반       | 마우스 지원 그래픽 기반           |
    | 부팅 가능 디스크 크기 | 2TB 이하       | 2TB 이상 가능               |
    | 보안 기능        | 거의 없음        | **Secure Boot** 등 보안 강화 |
    | 현재 위치        | 점점 사라지는 중    | 대부분의 최신 시스템에서 사용 중      |



    * 요즘 컴퓨터는 **거의 다 BIOS 대신 UEFI를 사용**하고 있다. 하지만 아직도 BIOS라는 용어는 널리 쓰이고 있음음



**2. BIOS 또는 UEFI가 실행되어 하드웨어를 초기화**

* BIOS/UEFI는 **CPU, RAM, 키보드, 마우스, 디스크 등의 하드웨어를 초기화**한다.
* 이후 **부팅 가능한 장치를 찾고(예: SSD, HDD, USB)** 운영체제를 로드할 준비를 한다.



**3. 부트로더(예: GRUB) 실행**

<figure><img src="../../../.gitbook/assets/image (215).png" alt=""><figcaption></figcaption></figure>

* BIOS/UEFI가 부팅 장치에서 **부트로더(Bootloader)를 로드**한다.
* **부트로더는 운영체제를 메모리에 올리는 역할**을 한다.
* 대표적인 부트로더:
  * **GRUB (GNU GRUB)**: 리눅스에서 가장 많이 사용됨.
  * **LILO (Linux Loader)**: 예전 리눅스에서 사용됨.
  * **Windows Boot Manager**: 윈도우에서 사용됨.
* **부트로더는 BIOS/UEFI가 운영체제를 메모리에 올리기 위해 실행하는 작은 프로그램**
  * **운영체제(OS)를 실행시키기 위한 다리 역할**을 한다고 보면 됨
  * BIOS나 UEFI는 단순한 펌웨어라서 **운영체제를 직접 실행하진 못한다.**
  * 그래서 BIOS/UEFI는 부팅 가능한 장치에서 **부트로더를 찾아 실행**하고,\
    부트로더는 그다음 **운영체제 커널을 로딩해서 실행**시켜주는 거임

**4. 부트로더가 OS 커널을 실행**

* 부트로더는 **운영체제(OS) 커널을 로드하여 실행**한다.
* 여기서는 **리눅스 커널이 실행된다고 가정**한다.
* 커널은 **메모리, 프로세스, 파일 시스템, 장치 드라이버 등을 초기화**한다.



**5. 리눅스 커널이 `init` 프로세스를 실행**

* 커널이 초기화되면, 가장 먼저 실행하는 프로세스가 **`init` 프로세스(PID=1)** 이다.
* `init`은 **모든 사용자 프로세스의 부모가 되는 최상위 프로세스**이다.



**6. `init`이 여러 자식 프로세스를 생성하여 시스템을 구성**

* `init`은 **백그라운드 서비스(데몬)를 실행하고, 사용자가 로그인할 수 있도록 셸을 실행**한다.
* 네트워크, 디스크 관리, 디스플레이 서버(Xorg), 로그 관리 등의 시스템 서비스를 시작한다.
* 이 과정에서 `fork()`와 `execve()`를 사용하여 새로운 프로세스를 생성한다.

> 즉, **현재 실행 중인 모든 프로세스의 최상위 부모는 `init` 프로세스(PID=1)이다.**

### 2️⃣ **프로세스 계층 구조 확인**

리눅스에서 `pstree` 명령어를 사용하면 **프로세스의 부모-자식 관계를 트리 형태로 확인**할 수 있다.

```sh
$ pstree -p
```

**출력 예시**

**이 출력이 의미하는 것**

* `systemd(1)` → 현재 리눅스 배포판에서 `init` 프로세스를 대체하는 `systemd`가 실행됨.
* 모든 프로세스는 **PID=1을 가진 `systemd`(또는 `init`)의 자식 프로세스이다.**
* 예를 들어, `bash(19262)`가 실행된 후 사용자가 `pstree(19638)` 명령을 실행했기 때문에, `pstree`가 `bash`의 자식 프로세스가 된 것을 볼 수 있다.

### 3️⃣ **프로세스를 생성하는 또 다른 방법: `posix_spawn()`**

일반적으로 **새로운 프로세스를 실행하려면 `fork()`로 자식 프로세스를 만들고 `execve()`로 새로운 프로그램을 실행**해야 한다.

그러나 POSIX 표준에서는 이를 더 간단하게 처리할 수 있도록 `posix_spawn()` 함수를 제공한다.

**📌 `posix_spawn()`을 사용한 프로세스 생성 예제**

```python
#!/usr/bin/python3
import os

# posix_spawn()을 사용하여 echo 명령어 실행
os.posix_spawn("/bin/echo", ["echo", "posix_spawn()로 생성되었습니다"], {})

print("echo 명령어를 생성했습니다")
```

**실행 결과**

```sh
$ ./spawn.py
echo 명령어를 생성했습니다
posix_spawn()로 생성되었습니다
```

* `posix_spawn()`을 사용하면 `fork()`와 `execve()`를 따로 호출할 필요 없이 **한 번에 새로운 프로세스를 생성하고 실행**할 수 있다.
* `fork()`와 `execve()`를 따로 호출하는 것보다 **코드가 간결하고 직관적**이다.

### 4️⃣ **`fork()`와 `execve()`를 사용한 전통적인 프로세스 생성**

위의 `posix_spawn()`과 동일한 기능을 `fork()`와 `execve()`로 구현하면 다음과 같다.

```python
#!/usr/bin/python3
import os

ret = os.fork()

if ret == 0:
    # 자식 프로세스에서 execve() 실행
    os.execve("/bin/echo", ["echo", "fork()와 execve()로 생성되었습니다"], {})
elif ret > 0:
    print("echo 명령어를 생성했습니다")
```

**실행 결과**

```sh
$ ./spawn-by-fork-and-exec.py
echo 명령어를 생성했습니다
fork()와 execve()로 생성되었습니다
```

* `fork()`가 실행되면 부모 프로세스와 자식 프로세스가 동시에 실행된다.
* 자식 프로세스는 `execve()`를 실행하여 **자신을 `echo` 프로그램으로 치환**한다.

### 5️⃣ **`posix_spawn()` vs `fork()` + `execve()` 비교**

| 방법                    | 특징                       | 장점                  | 단점                                       |
| --------------------- | ------------------------ | ------------------- | ---------------------------------------- |
| `fork()` + `execve()` | 전통적인 프로세스 생성 방식          | 유연성이 높음, 세부적인 설정 가능 | 코드가 길어짐, `fork()` 후 `execve()`를 꼭 호출해야 함 |
| `posix_spawn()`       | POSIX 표준의 간단한 프로세스 생성 방식 | 코드가 간결하고 직관적임       | 세부 설정이 어렵고 `fork()`보다 제어가 제한됨            |

* `posix_spawn()`은 **간단한 프로세스 실행에는 유용하지만, 복잡한 프로세스 관리는 `fork()`를 사용하는 것이 더 적합**하다.
* 예를 들어 **셸(Bash)처럼 프로세스를 관리하는 프로그램을 만들 때는 `fork()`를 직접 호출하는 것이 좋다.**

### 6️⃣ **정리**

1. **모든 프로세스의 조상은 `init`(또는 `systemd`) 프로세스(PID=1)이다.**
2. **`pstree` 명령어를 사용하면 부모-자식 프로세스 관계를 확인할 수 있다.**
3. **새로운 프로세스를 실행하는 방법**
   * `fork()` + `execve()`를 사용하여 전통적인 방식으로 실행
   * `posix_spawn()`을 사용하여 간단하게 실행
4. **`posix_spawn()`은 `fork()`와 `execve()`를 따로 호출하는 것보다 간단하지만, 세부적인 제어가 어렵다.**
5. **셸과 같은 프로그램을 만들 때는 `fork()`를 직접 호출하는 것이 더 적합하다.**

이제 **프로세스의 부모-자식 관계가 어떻게 형성되는지**, **최상위 프로세스는 누구인지**, 그리고 **다양한 방식으로 프로세스를 생성하는 방법**을 이해할 수 있을 것이다! 🚀

## 4. 프로세스 상태

#### **1) 프로세스 상태(Process States)란?**

운영체제에서 실행되는 **모든 프로세스는 항상 특정한 상태에 속해 있으며, 필요에 따라 상태가 변경**된다.\
즉, **프로세스는 계속해서 CPU를 사용하는 것이 아니라, 어떤 이벤트가 발생할 때까지 대기하거나 다른 프로세스로 전환될 수 있다.**

리눅스에서 실행 중인 프로세스의 상태는 `ps aux` 명령어의 `STAT` 필드를 보면 확인할 수 있다.

```sh
$ ps aux
USER       PID %CPU MEM   VSZ  RSS TTY      STAT  START   TIME COMMAND
sat       19262  0.0  0.0  5336 3632 pts/0   Ss    18:24   0:00 -bash
```

위 출력에서 `STAT` 필드의 값이 `Ss`인데, 여기서 첫 번째 문자인 `S`(Sleep, 슬립 상태)가 프로세스의 현재 상태를 의미한다.

> 즉, 이 `bash` 프로세스는 **사용자가 입력할 때까지 슬립 상태로 대기 중**이라는 뜻이다.

#### **2) 주요 프로세스 상태**

<figure><img src="../../../.gitbook/assets/image (213).png" alt=""><figcaption></figcaption></figure>

운영체제에서 프로세스는 다음과 같은 주요 상태를 가질 수 있다.

1. **실행 가능 상태(Ready)**

* **CPU에서 실행될 수 있지만, 현재 실행 중은 아닌 상태**.
* **STAT 값: `R` (Running or Runnable)**.
* 실행 가능한 프로세스가 여러 개 있으면 **CPU 스케줄러가 하나를 선택하여 실행**.



2. &#x20;**실행 상태(Running)**

* **CPU에서 실행 중인 상태**.
* **STAT 값: `R`**.
* 한 번에 하나의 논리 CPU(Core)에서만 실행될 수 있다.
* 일정 시간(타임 슬라이스)이 지나면 다른 프로세스에게 CPU를 넘겨주고 다시 **실행 가능(Ready) 상태로 이동**.



3. **슬립 상태(Sleeping)**

* **I/O 작업이나 이벤트가 발생할 때까지 기다리는 상태**.
* **STAT 값: `S` (Interruptible Sleep) 또는 `D` (Uninterruptible Sleep)**.
* 예시:
  * **터미널에서 `bash`가 사용자 입력을 기다리는 경우**.
  * **네트워크 요청을 보내고 응답을 기다리는 프로세스**



4. **종료 상태(Terminated)**

* **프로세스가 실행을 완료하고 종료된 상태**.
* **STAT 값: 없음** (일반적으로 `ps`에서 더 이상 표시되지 않음).



5. **좀비 상태(Zombie)**

* **프로세스가 종료되었지만, 부모 프로세스가 종료 상태를 아직 수거하지 않은 상태**.
* **STAT 값: `Z` (Zombie)**.
* 부모 프로세스가 `wait()` 또는 `waitpid()`를 호출해야 좀비 프로세스가 사라짐.
* 좀비 프로세스가 많아지면 시스템 리소스 낭비가 발생할 수 있음.

#### **3) 프로세스 상태 변화 과정**

프로세스는 실행 중 다양한 이벤트에 따라 상태를 변경한다.\
이를 도식화하면 다음과 같다.

```
    프로세스 생성
          ↓
  [실행 가능 상태]  ──────→  [실행 상태]  ──────→  [슬립 상태]
        ↑                 ↓                     ↑
      (스케줄링)      (타임 슬라이스 종료)      (이벤트 발생)
          │                                      ↓
          └────────────── [좀비 상태] ──────→  [완전 종료]
```

**📌 상태 변화 과정 설명**

1. **프로세스가 생성되면 실행 가능 상태(Ready)로 들어간다.**
2. CPU 스케줄러가 선택하면 실행 상태(Running)로 변환된다.
3. CPU 타임 슬라이스(Time Slice)가 끝나면 다시 실행 가능 상태로 돌아간다.
4. 입출력 요청이나 이벤트 대기를 하면 슬립 상태(Sleeping)로 전환된다.
5. 이벤트(입출력 완료 등)가 발생하면 다시 실행 가능 상태(Ready)로 돌아간다.
6. 프로세스가 종료되면 좀비 상태(Zombie)가 되었다가 최종적으로 시스템에서 사라진다.

#### **4) 리눅스에서 프로세스 상태 확인하기**

리눅스에서는 `ps aux` 명령어를 사용하면 모든 프로세스의 상태를 확인할 수 있다.

```sh
$ ps aux
USER       PID %CPU MEM   VSZ  RSS TTY      STAT  START   TIME COMMAND
sat       19262  0.0  0.0  5336 3632 pts/0   Ss    18:24   0:00 -bash
root          1  0.1  0.3 168840  8256 ?     Ss    09:00   0:02 /sbin/init
root       238  0.0  0.0  5472  1452 ?      S     09:00   0:00 /lib/systemd/systemd-journald
```

| **STAT 값** | **설명**                                  |
| ---------- | --------------------------------------- |
| `R`        | 실행 상태(Running) 또는 실행 가능 상태(Ready)       |
| `S`        | 슬립 상태(Sleeping) (I/O 작업 대기 중)           |
| `D`        | Uninterruptible Sleep (I/O 대기 중, 신호 무시) |
| `T`        | 중지 상태(Stopped) (예: `SIGSTOP` 신호를 받은 경우) |
| `Z`        | 좀비 프로세스(Zombie)                         |

**예제 해석**

* `-bash` 프로세스의 STAT 값이 `Ss` → 슬립 상태이며, 세션 리더(Session Leader)임을 의미.
* `init` 프로세스는 `Ss` 상태 → 실행 중이지만 현재 대기 중.
* `systemd-journald`는 `S` 상태 → 로그 기록을 대기 중.

#### **5) CPU가 아무것도 하지 않을 때는 어떻게 되나?**

만약 **시스템의 모든 프로세스가 슬립 상태라면 CPU는 어떻게 동작할까?**\
이때 **CPU는 "아이들 프로세스(idle process)"를 실행**한다.

* **아이들 프로세스(idle process)**
  * CPU가 실행할 프로세스가 없을 때 동작하는 특수한 프로세스.
  * CPU가 **불필요한 작업을 수행하지 않도록 하고, 전력을 절약**하는 역할을 함.
  * `ps` 명령어에서는 보이지 않음.

**📌 아이들 상태의 의미**

1. **CPU는 실행할 프로세스가 없을 때 "반복문"을 실행하지 않고 전력을 절약해야 함.**
2. **CPU는 저전력 모드(Idle Mode)로 들어가며, 새로운 프로세스가 실행될 때까지 대기함.**
3. **노트북이나 스마트폰에서 배터리를 절약할 수 있는 이유 중 하나.**

#### **6) 정리**

1. **프로세스는 실행되는 동안 다양한 상태를 오고 감.**
2. **주요 프로세스 상태**
   * 실행 가능(Ready) → `R`
   * 실행 중(Running) → `R`
   * 슬립 상태(Sleeping) → `S` 또는 `D`
   * 좀비 상태(Zombie) → `Z`
   * 종료(Terminated) → `ps`에서 사라짐
3. **프로세스는 CPU가 필요할 때 실행 상태가 되고, 필요하지 않을 때 슬립 상태로 대기함.**
4. **모든 프로세스가 슬립 상태면 CPU는 아이들 프로세스를 실행하며, 전력을 절약함.**
5. **노트북과 스마트폰이 배터리를 절약할 수 있는 이유는 CPU가 아이들 상태로 대기하기 때문.**

이제 **프로세스가 어떻게 상태를 변경하는지, 그리고 CPU가 프로세스를 어떻게 다루는지** 이해할 수 있을 것이다! 🚀



## 최종 정리

1.



## 참고

* [https://velog.io/@heydy/fork%EC%9D%98-%EB%AA%A8%EB%93%A0%EA%B2%83](https://velog.io/@heydy/fork%EC%9D%98-%EB%AA%A8%EB%93%A0%EA%B2%83)

