---
icon: '6'
---

# 6장 : 장치접근

프로세스 대신해서 커널이 장치에 접근합니다. 구체적으로는 다음과 같은 인터페이스를&#x20;사용합니다.

* 디바이스 파일이라는 특수한 파일을 조작합니다.  \

* 블록 장치에 구축한 파일 시스템을 조작합니다.&#x20;
* 파일 시스템은 7장을  &#x20;참조합니다.
* `네트워크 인터페이스 카드(NIC)`는 속도 등의 문제로 디바이스 파일을 사용하는 대신에  &#x20;소켓 구조를 사용합니다.&#x20;

## 1. 디바이스 파일 : "파일처럼 생긴 장치 조작법"

### 📂 디바이스 파일이란?

* 디바이스 파일은 **장치와 커널의 연결점**입니다.
* 예를 들어 `/dev/sda`, `/dev/sdb`는 각각 다른 저장 장치(또는 파티션)에 해당합니다.
  * TCP 소켓이나 UDP 소켓을 사용해서 다른 기기와 프로세스 통신할 때 사용
  *   자세히 말하면 저장 장치를 파티션으로 나눴다면 /dev/sdal. /dev/sda2처럼 파티션마다 디바이스 파일이 존재

      * `sda` : 하나의 저장 장치 전체 (예: SSD 또는 HDD 하나)
      * `sda1`, `sda2`, `sda3` 등 : 그 저장 장치 안의 파티션(=구획, 방)

      ```plaintext
      /                   <- 루트 디렉토리
      ├── dev             <- 디바이스 파일이 위치한 곳
      │   ├── sda         <- 전체 저장 장치
      │   ├── sda1        <- 첫 번째 파티션
      │   └── sda2        <- 두 번째 파티션
      ```

      #### 📦 예시

      상상해보세요! 하나의 외장 하드가 있고, 그 안을 나눠서:

      * `C:` 드라이브 → `/dev/sda1`
      * `D:` 드라이브 → `/dev/sda2`

      > `/dev/sda`는 하드디스크 전체, `/dev/sda1`, `/dev/sda2`는 그 하드디스크를 나눈 각각의 공간이에요!
* 프로세스는 이 디바이스 파일을 일반 파일처럼 조작해서 장치를 다룹니다.

```
예시: 저장 장치 /dev/sda  
→ 내부적으로는 HDD/SSD 같은 실제 장치와 연결됨
```

### 🔧 디바이스 파일로 장치 조작하기

> 리눅스는 프로세스가 디바이스 파일을 조작하면 커널 내부의 `디바이스 드라이버 device driver`라고> &#x20;부르는 **소프트웨어가 사용자 대신에 장치에 접근**합니다.

#### ✅ 구조 요약

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

```
프로세스 → 디바이스 파일(/dev/XXX) → 디바이스 드라이버 → 실제 장치
```

* 사용자는 `read()`, `write()` 등의 시스템 콜을 호출해 디바이스 파일을 읽고 씁니다.
  * 일반 파일과 똑같은 방식으로 디바이스 파일 조작
* 커널 내부에서는 **디바이스 드라이버**가 이 요청을 해석하고 실제 장치를 조작합니다.
* 특수한 조작은 `ioctl()` 시스템 콜로 수행합니다.

### 🛠️ `ioctl()`이란?

**I/O control의 약자**로,\
장치(디바이스)에 대해 **입출력 외의 특수한 조작을 수행**할 수 있도록 해주는 시스템 콜이에요.

> `read()` → 읽기\
> `write()` → 쓰기\
> `ioctl()` → 그 외 특수한 기능들 제어 (장치 설정, 동작 제어 등)

#### 📦 예시로 이해해봐요!

\- "하드 디스크의 온도를 알고 싶다"

\- "카메라 장치의 해상도를 바꾸고 싶다"

\- "터미널에서 에코 모드를 끄고 싶다"

#### 예1) CD-ROM 꺼내기

CD-ROM 장치는 읽고 쓰는 것도 중요하지만,\
&#xNAN;**“열기/닫기” 같은 특수 기능**도 있어야 하잖아요?

이럴 때 `ioctl()`로 **“CD-ROM 트레이 열기” 명령**을 보냅니다!

```c
ioctl(cd_fd, CDROMEJECT);
```

#### 예2) 터미널 설정 바꾸기

터미널 창에서 **입력 방식(에코 모드, 키 입력 버퍼 설정 등)**&#xC744; 변경하고 싶을 때도\
`ioctl()`을 사용해 제어할 수 있어요.

```c
struct termios t;
ioctl(STDIN_FILENO, TCGETS, &t);  // 현재 터미널 설정 가져오기
t.c_lflag &= ~ECHO;               // 입력된 키를 화면에 표시하지 않도록 설정
ioctl(STDIN_FILENO, TCSETS, &t);  // 변경된 설정 적용
```

#### 💡 그럼 왜 `read()`나 `write()`로 안 될까요?

* `read()`는 데이터를 읽는 것
* `write()`는 데이터를 쓰는 것

하지만 장치는 읽고 쓰기만 하는 게 아니라,\
**동작 제어나 상태 변경** 같은 작업도 필요하거든요.

→ `ioctl()`은 **장치별로 정의된 명령어(명령 코드)**&#xB97C; 통해\
특수한 조작을 가능하게 해줍니다.

> `ioctl()`은 장치와 대화하는 비밀 통로예요! 단순히 읽고 쓰는 걸 넘어, **특수한 명령이나 설정**을 조정할 때 사용됩니다.

### 🔢 디바이스 파일의 중요한 속성

디바이스 파일은 단순한 파일이 아닌, 다음과 같은 **고유 정보**를 가집니다:

| 항목     | 설명                                              |
| ------ | ----------------------------------------------- |
| 종류     | 캐릭터 장치(Character Device) 또는 블록 장치(Block Device) |
| 메이저 번호 | 어떤 **드라이버**를 사용할지 결정하는 번호                       |
| 마이너 번호 | **드라이버 내부에서 어떤 장치**인지 구별하는 번호                   |

예를 들어 `/dev/sda1`, `/dev/sda2`는 같은 저장장치(`sda`)의 서로 다른 파티션입니다.

### 📍 캐릭터 장치 vs 블록 장치

| 구분    | 캐릭터 장치         | 블록 장치                   |
| ----- | -------------- | ----------------------- |
| 예시    | 키보드, 마우스, 터미널  | 하드디스크, SSD, USB         |
| 특징    | 1바이트씩 연속적으로 접근 | 블록 단위(보통 512B, 4KB)로 접근 |
| 전송 방식 | 스트리밍           | 랜덤 접근 가능                |

### 🚨 접근 권한은 루트만?

* 대부분의 디바이스 파일은 **보안상의 이유로 루트만 접근 가능**합니다.
* 예: `/dev/mem`(물리 메모리 전체에 접근)은 일반 사용자에겐 매우 위험하므로 제한됨.

### 🧪 실습: /dev 디렉토리 확인하기

```bash
$ ls -l /dev
```

출력 예시:

```
brw-rw---- 1 root disk 8, 0 Apr 21 14:12 sda
brw-rw---- 1 root disk 8, 1 Apr 21 14:12 sda1
crw------- 1 root root 10, 61 Apr 21 14:12 cpu_dma_latency
```

`b`로 시작: 블록 장치\
`c`로 시작: 캐릭터 장치\
`8, 0` 등은 메이저 번호와 마이너 번호

> **"디바이스 파일은 하드웨어를 추상화한 문, 커널 드라이버는 그 문의 비밀번호다."**

***

## 2. 🎛️ 캐릭터 장치(Character Device)의 조작

캐릭터 장치는 **연속적인 데이터 흐름**을 처리하는 장치로, 대표적인 예는 다음과 같습니다:

* 단말 (예: 터미널)
* 키보드
* 마우스

이 장치들은 **읽기(read)와 쓰기(write)**&#xB294; 가능하지만, **seek(탐색)** 기능은 지원하지 않아요. 즉, 파일처럼 임의 위치로 이동해서 데이터를 읽는 기능은 없다는 뜻입니다.

#### 🖥️ 단말 장치 실습 예시

단말 장치는 디바이스 파일 `/dev/pts/X`에 매핑되어 있고, 해당 파일을 통해 장치를 직접 조작할 수 있습니다.

**✅ 1. 현재 단말 확인**

```bash
$ ps ax | grep bash
6417 pts/9 Ss
6432 pts/9 S+
```

여기서 `pts/9`는 현재 터미널이 사용하는 단말 장치입니다.

/dev/ 아래에 있는 pts/9 파일이 단말에 대응하는 디바이스 파일

**✅ 2. 현재 단말에 문자열 쓰기**

```bash
$ sudo su
# echo hello > /dev/pts/9
```

→ 해당 단말에 `hello` 문자열이 출력됩니다.

* 디바이스 파일에 write() 시스템 콜을 호출
* echo hello 명령어를 실행했을 때와 동일한 결과인데 이유가 뭘까요?

> echo 명령어는 표준 출력에 hello를 쓰고, **리눅스에서 표준 출력은 단말과 연결되어 있기 때문**입니다.

**✅ 3. 다른 단말에도 쓰기 가능**

**“한 터미널에서 다른 터미널 화면에 글씨를 강제로 출력해보기” 실험이에요.**

📌 먼저 기본 개념부터 정리

| 개념                         | 설명                             |
| -------------------------- | ------------------------------ |
| 터미널(단말)                    | 우리가 bash 명령어를 입력하는 창           |
| `/dev/pts/N`               | 각 터미널에 연결된 **디바이스 파일 경로**      |
| `echo hello > /dev/pts/10` | "10번 터미널에 ‘hello’ 라고 써줘" 라는 명령 |

**🧪 실험 과정 요약**

#### 1. 여러 터미널을 띄운다

* 첫 번째 터미널: **내가 명령어를 입력할 곳**
* 두 번째 터미널: **메시지를 받아볼 곳** (아무것도 안 해도 됨)

#### 2. ps 명령어로 각 터미널 번호 확인

```bash
$ ps ax | grep bash
6417 pts/9 Ss 0:00 -bash      ← 첫 번째 터미널
6648 pts/10 Ss 0:00 -bash     ← 두 번째 터미널
```

이걸 보면,

* **첫 번째 터미널**은 `/dev/pts/9`
* **두 번째 터미널**은 `/dev/pts/10` 이란 뜻이에요.

#### 3. 첫 번째 터미널에서 sudo로 전환한 뒤, **다른 터미널에 메시지 전송**

```bash
$ sudo su
# echo hello > /dev/pts/10
```

* `echo hello`: "hello"를 출력해라!
* `> /dev/pts/10`: 그 출력을 **10번 터미널 화면에 보내라!**

#### 4. 아무것도 안 하던 두 번째 터미널(pts/10)에 뜨는 화면

```
$ hello
```

* 이건 내가 입력한 게 아니고,
* **첫 번째 터미널에서 강제로 출력한 hello가 내 터미널에 나타난 것**이에요!

**🎯 핵심 이해 포인트**

* 리눅스에서는 **터미널 하나하나가 다 파일처럼 존재해요** (`/dev/pts/번호`)
* 그래서 다른 터미널에다가도 `write()` 하듯 **출력할 수 있어요**
* `echo hello > /dev/pts/10`은 **10번 터미널에 hello를 강제로 써주는 것**이에요.

**💬 추가 설명이 필요한 경우**

* `sudo`가 필요한 이유는? → 다른 사용자 터미널은 루트만 접근 가능해서!
* `pts/10` 같은 경로는 어떻게 생기냐면 → `pseudo terminal slave`라 불리는 가상 터미널 장치에요.



#### 💡 핵심 개념 요약

| 항목       | 설명                            |
| -------- | ----------------------------- |
| 캐릭터 장치   | 탐색 불가 / 스트림 기반 데이터 처리         |
| 단말 장치 예시 | `/dev/pts/9`, `/dev/pts/10` 등 |
| 시스템 콜    | `read()`, `write()` 를 통해 조작   |

> 리눅스에서는 '모든 것은 파일'이라는 철학 하에, 장치도 파일처럼 다룰 수 있어요

### 🖥️ 리눅스에서의 "표준 출력"은?

리눅스나 유닉스 계열 시스템에서 **모든 입출력은 "파일"처럼 다룰 수 있어요.**

* `stdin` (표준 입력, **키보드**) → **파일 번호 0**
* `stdout` (표준 출력, **화면**) → **파일 번호 1**
* `stderr` (표준 에러, **에러 메시지 출력용**) → **파일 번호 2**

즉, 터미널에서 `echo hello`를 입력하면,\
💡 **"hello"라는 문자열을 표준 출력(stdout)에 쓰는 것**이에요.

#### 🧵 표준 출력이 "단말 장치"에 연결돼 있다는 건?

지금 내가 명령어를 입력하고 있는 **터미널**이 바로 `단말 장치(device)`예요.\
리눅스는 이 터미널을 `/dev/pts/9` 같은 **디바이스 파일**로 만들어놔요.\
즉, 표준 출력은 이 **디바이스 파일에 연결돼 있는 상태**인 거예요.

#### 🔁 그래서 어떻게 동작하냐면?

```bash
echo hello
```

이 명령은 실제로는 다음과 같이 동작하는 거예요:

1. `echo` 프로그램이 실행된다.
2. 내부적으로 `"hello\n"` 문자열을 **stdout(표준 출력)**&#xC73C;로 보낸다.
3. 리눅스는 이 stdout을 **/dev/pts/9 같은 단말 디바이스 파일**에 연결해두었다.
4. 결과적으로 이 문자열은 **내가 보고 있는 터미널 화면에 출력**된다!

#### 🧪 실험적으로 확인해볼 수도 있어요!

```bash
$ echo hello > /dev/pts/10
```

➡ 이 명령은 `echo hello`를 **다른 터미널에 출력하라**는 의미예요.\
왜냐하면 `/dev/pts/10`은 다른 단말(터미널)을 나타내니까요!

#### 🔚 한줄 요약

> `echo hello`는 사실 `stdout`에 "hello"를 출력하는 것이고,\
> 이 `stdout`은 리눅스에서 내 **터미널 디바이스 파일(/dev/pts/9)**&#xC5D0; 연결되어 있기 때문에,\
> 화면에 보이게 되는 거예요!

***

## 3. 📦 블록 장치와 루프 장치, 그리고 직접 조작 실습!

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### 1️⃣ 블록 장치란?

* **블록 단위로 읽고 쓰기가 가능하고, 탐색도 가능한 장치**
* 대표 장치: 하드디스크, SSD 등 저장 장치
* 보통은 **파일 시스템을 통해 접근**하지만, 실습에서는 **파일 시스템 없이 직접 조작**도 가능

### 2️⃣ 블록 디바이스 파일 직접 조작 예시

#### ✅ 준비 과정

1. 비어 있는 파티션 `/dev/sdc7`을 사용한다고 가정

* 비어 있는 파티션이 없다면 나중에 설명하는 `루프   장치 컬럼`을 참조해서 루프 장치를 사용
  *   비어 있는 파티션이 없다는 말은?

      * 실습이나 테스트를 위해 직접 블록 장치(`/dev/sdc7` 같은)에 접근하려면,
      * **다른 데이터가 없는 빈 파티션**이 필요해요.
        * 그런데 대부분의 시스템은 이미 모든 디스크 공간이 OS나 사용자 데이터로 꽉 차 있어요.

      > ⚠️ 이럴 때 잘못된 파티션을 실습에 사용하면 **데이터가 날아가는 대참사**가 발생할 수 있습니다

{% hint style="danger" %}
**루프 장치란?**

**"진짜 디스크가 없어도 마치 디스크인 것처럼" 사용할 수 있게 해주는 가상 장치**예요.

* 하나의 일반 파일(img 파일)을 준비한 다음,
* 그걸 `/dev/loop0`, `/dev/loop1` 같은 **루프 디바이스 파일**에 연결하면
* 마치 진짜 `/dev/sdc1`처럼 동작합니다.
* **"비어 있는 진짜 디스크 공간이 없다면, 루프 장치라는 가짜 디스크를 만들어 실습하라!"**
{% endhint %}

2. ext4 파일 시스템을 생성:

```bash
# mkfs.ext4 /dev/sdc7
```

3. 마운트:

{% hint style="danger" %}
**📦 마운트(Mount)란?**

**❓ 정의부터 간단하게!**

> **마운트**란 어떤 파일 시스템(디스크, USB, 루프 장치 등)을 리눅스 시스템의 디렉토리 트리에 연결하는 작업입니다.

&#x20;**💬 쉽게 말해서?**

* "어디에 붙일지 정해서, 사용할 수 있게 만드는 일"
* 예: USB를 컴퓨터에 꽂고 \`/mnt/usb\`에서 쓸 수 있도록 만드는 것

**🏡 비유로 이해해볼게요!**

* 🧳 여행 가방 = 디스크
* 🪑 여행 가방을 펼쳐 놓을 책상 = 디렉토리(/mnt)

여행 가방(USB, 외장하드 등)을 들고 왔다고 해서 당장 쓸 수는 없죠.

책상 위에 가방을 펼쳐야(good 위치에 마운트해야) 안에 든 옷이나 물건을 꺼낼 수 있어요.



즉, 마운트란:

> 📁 디스크(파일 시스템)를 📂 리눅스의 특정 디렉토리 경로에 "연결"하는 것!
{% endhint %}

```bash
# mount /dev/sdc7 /mnt
# echo "hello world" > /mnt/testfile
# umount /mnt
```

1\) `mount /dev/sdc7 /mnt`

> 💡 **"디바이스 파일 `/dev/sdc7`에 있는 파일 시스템을 `/mnt` 디렉토리에 연결해줘!"**

* `/dev/sdc7`: 디스크나 파티션(예: 외장하드, USB 등)의 **블록 디바이스 파일**
* `/mnt`: 리눅스에서 **임시로 디스크를 붙이는 디렉토리**

📌 이걸 마운트하면:

* `/mnt` 아래에서 `/dev/sdc7`의 내용을 **일반 디렉토리처럼** 접근할 수 있어요.
* 예: `/mnt/testfile`은 실제 `/dev/sdc7`에 저장되는 것!



2\) `echo "hello world" > /mnt/testfile`

> 💡 **"`/mnt/testfile`이라는 새 파일을 만들고, 그 안에 'hello world' 문자열을 써!"**

* 이때 `/mnt`는 위에서 마운트한 `/dev/sdc7`이기 때문에,
* **결과적으로는 `/dev/sdc7` 디스크에 "hello world"라는 내용을 가진 파일이 생깁니다!**



3\) `umount /mnt`

> 💡 **"이제 디스크 사용 끝났으니 `/mnt`에서 연결 해제할게!"**

* `umount`는 "unmount"의 줄임말.
* 연결을 해제하면 `/mnt`는 다시 **빈 디렉토리**가 되고,
* `/dev/sdc7`은 더 이상 접근할 수 없게 됩니다.

📝 요약 흐름 정리

| 단계 | 명령어      | 의미                 |
| -- | -------- | ------------------ |
| 1  | `mount`  | 디바이스를 디렉토리에 붙임     |
| 2  | `echo >` | 붙인 디스크에 파일 생성 및 쓰기 |
| 3  | `umount` | 디바이스와 디렉토리 연결 해제   |

🧠 실전 응용 팁

* 실수로 `umount` 안 하고 디스크 뽑으면? → 데이터 손상 가능 😱
* 꼭 `umount`로 안전하게 연결 해제하고 빼야 해요!

#### ✅ 파일 내용 직접 확인

```bash
# strings -tx /dev/sdc7
...
f35020 lost+found
f35034 testfile
...
```

출력 예:

```
803d000 hello world
10008020 lost+found
10008034 testfile
```

이건 `/mnt/testfile`에 쓴 "hello world"가 실제 블록 장치 `/dev/sdc7` 안의 **803d000 위치에 저장되었음을 보여줍니다.**

\
출력 결과에서 /dev/sdc7에는&#x20;

* lost+found 디렉터리 및 testfile 파일명
* 파일 내부에 있는 hello world 문자열

정보가 들어 있습니다.

각각의 문자열이 두 번 출력된 건 **ext4의 저널링 기능 때문**인데 저널링은 데이터를 쓰기&#x20;전에 저널 영역이라고 부르는 장소에 함께 기록합니다

#### ✅ 블록 장치 직접 조작 (위험하니 주의!)

```bash
$ echo "HELLO WORLD" > testfile-overwrite
$ sudo dd if=testfile-overwrite of=/dev/sdc7 bs=1 seek=$((0x803d000))
```

#### ✅ 결과 확인

```bash
# mount /dev/sdc7 /mnt
# cat /mnt/testfile
HELLO WORLD
```

> 🧙‍♂️ 파일 시스템을 거치지 않고 직접 디바이스 파일을 조작했어요!

### 3️⃣ 루프 장치 (Loop Device)란?

> **파일을 디바이스처럼 사용**할 수 있게 해주는 기능\
> 하드웨어 파티션이 없는 경우에 실험 용도로 딱!

#### ✅ 루프 장치 생성 및 연결

```bash
$ fallocate -l 16M loopdevice.img
$ sudo losetup -f loopdevice.img
$ losetup -l
```

출력 예:

```
/dev/loop0  ... /home/user/loopdevice.img
```

#### ✅ ext4 파일 시스템 만들고 마운트

```bash
$ sudo mkfs.ext4 /dev/loop0
$ mkdir mnt
$ sudo mount /dev/loop0 mnt
$ echo "test" > mnt/example.txt
```

#### ✅ 정리하기

```bash
$ sudo umount mnt
$ sudo losetup -d /dev/loop0
$ rm loopdevice.img
```

### ✅ 요약 표

| 개념            | 설명                                           |
| ------------- | -------------------------------------------- |
| 블록 장치         | 하드디스크, SSD 등. 블록 단위로 탐색 가능                   |
| 디바이스 파일       | `/dev/sda`, `/dev/sdc7` 등. 커널이 장치를 매핑한 가상 경로 |
| 루프 장치         | 일반 파일을 블록 장치처럼 다루는 기능                        |
| `strings -tx` | 바이너리 파일 내 문자열 검색 (파일 오프셋과 함께)                |
| `dd`          | 블록 단위 복사 도구. 디바이스 조작 가능                      |

> **블록 장치는 일반 파일보다 더 직접적이고 강력한 방식으로 저장소를 다룹니다.**\
> 루프 장치는 실험과 테스트 환경에서 매우 유용한 가상 장치입니다.

***

