---
cover: >-
  https://file.notion.so/f/f/3f5af70e-5587-4c7a-8846-c7c5c0a904e2/bb5eb3c8-3a67-42a3-9f79-5b9e7ae18004/Untitled.png?table=block&id=b0e23518-b129-4308-b83b-ec65feb78ce5&spaceId=3f5af70e-5587-4c7a-8846-c7c5c0a904e2&expirationTimestamp=1723118400000&signature=rnD47Ut9ef14TJYUsQjV9D1VaLm05HlFUi3ZDGKTiYQ&downloadName=Untitled.png
coverY: 0
layout:
  cover:
    visible: true
    size: hero
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Big O

## 🍐자료구조와 알고리즘이 필요한 이유

### 1. 프로그래밍 언어란?

컴퓨터 프로그래밍에서 어떠한 알고리즘을 구현하기 위해서 쓰여지는 언어

자료구조와 알고리즘에 대한 이해가 있다면 구현하고자 하는 기능을 보다 쉽고 효울적으로 만들 수 있게 도와줌

현업의 경우 코딩테스트를 공부하지 않음 대부분은 언어나 프레임워크나 라이브러리에서 이미 잘 만들어진 아이들을 가져와서 만들고자 하는 기능을 가져와서 사용

### 2. 그렇다면 왜 코딩테스트를 볼까?

알고리즘 작성 후 질의/응답을 통해 자료구조와 알고리즘에 대해 얼마나 이해하고 있고 시간과 공간 복잡도에 대한 이해가 있는지 확인해보기 위함

EX.

* 하필 이 알고리즘을 선택한 이유는?
* 이것이 저것들의 비해 장단점은?
* 저것과 이것의 차이는?

## 🍐 알고리즘과 자료구조를 공부방법

자료 구조는 어느 상황에 쓰이는 것이 좋고 또 어떤 식의 API들이 있는지 이런 것들 조금 큰 그림을 보면서 공부

### 1. 자료구조

서비스나 어플리케이션에 필요한 데이터를 메모리에 어떻게 구조적으로 잘 정리해서 담아두고, 관리하고 **효율적인 방식으로 필요한 데이터에 빠르게 접근하고 필요한 수정 삽입 삭제** 할 수 있도록 도와준다. 기능에 적합한 알맞는 자료구조를 쓰는 것이 중요하다.

&#x20;**💡 자료 구조 공부시 Point**

1. Order : 자료 구조 안에 있는 데이터들의 순서가 보장?
2. Unique : 중복된 데이터가 들어 갈 수 있는가?
3. Search : 검색에 얼마나 효율적인가?
4. Modification : 우리가 원하는 기능에 따라서 수정시 얼마나 효율적인지?

**++ 블로그에서 따온 글\[읽어보는 거 추천] 출처 :** [https://velog.io/@teo/computational-thinking](https://velog.io/@teo/computational-thinking)

#### 변수, 타입, 조건, 반복, 함수 - 프로그래밍의 핵심 요소

**컴퓨터가 효과적**으로 수행하기 위해서는 사용자의 **요구사항을 데이터의 관점에서 이해**하고, 데이터를 **컴퓨터가 이해할 수 있는 형태로 표현**해야 합니다. 그리고 이를 위해 **데이터의 구조**와 **알고리즘**을 기술해야 한다고 알아보았습니다. 이렇게 컴퓨터가 이해할 수 있도록 표현하는 언어를 **프로그래밍 언어**라고 부릅니다.

지금껏 컴퓨터가 발전하면서 많은 프로그래밍 언어와 도구들이 생겨났지만, 프로그래밍의 본질은 크게 달라지지 않았습니다. 여전히 **변수**, **타입**, **조건**, **반복**, **함수**의 기본 개념을 사용하여 데이터를 컴퓨터가 이해할 수 있는 형태로 표현합니다.

변수는 값을 저장하는 공간이며, 타입은 변수가 저장할 수 있는 값의 종류를 결정합니다. 조건문은 주어진 조건에 따라 프로그램이 다르게 동작하도록 하는 것이며, 반복문은 반복적으로 실행되는 코드를 간단하게 작성할 수 있도록 해줍니다. 함수는 코드의 재사용성을 높여주는 중요한 개념으로, 입력값을 받아 출력값을 반환하는 기능을 합니다.

> 종합해보면, 컴퓨터적 사고란 사용자의 요구사항을 데이터의 관점에서 바라보고, 변수, 타입, 조건, 반복, 함수 등을 이용하여 데이터를 컴퓨터가 이해할 수 있는 형태로 표현하는 과정이라는 것을 이해하여, 결국 인간의 관점에서 기술된 내용들을 컴퓨터가 이해할 수 있는 형태로 바꾸어 생각하는 것이 컴퓨터적 사고력을 키우는 중요한 과정이라고 할 수 있습니다.

#### 이걸 검증(훈련)하고자 하는 것이 바로 코딩 테스트!

지금까지의 얘기를 듣다보면 아마 여러분들도 코딩테스트를 떠올렸을 거라고 생각합니다. 코딩 테스트의 문제들은 이러한 컴퓨터적 사고력을 훈련하고 검증하는 역할을 합니다.

생각해보면 코딩테스트들의 문제들은 특정 언어나 라이브러리 등에 종속되지 않는다는 것을 알 수 있습니다. 왜냐하면 코딩 테스트의 목적이 실무능력의 평가가 아니라 데이터를 다루는 방법, 즉 컴퓨터적인 사고에 대한 평가를 하기 위함이기 때문입니다.

코딩 테스트는 데이터의 구조와 알고리즘을 이해하고, 주어진 문제를 해결하기 위한 적절한 방법을 고민하는 능력을 요구합니다. 이러한 능력들은 컴퓨터적 사고력을 향상시키는 데 매우 중요합니다.

## 🍐 BigO

> 출처 : 니꼴라스 [https://www.youtube.com/watch?v=BEVnxbxBqi8](https://www.youtube.com/watch?v=BEVnxbxBqi8)

### 1. 개요

* 알고리즘의 **스피드**를 어떻게 표현하는지 알아봄
* 빠르다, 느리다의 말이 아닌 `CS지식`

### 2. 알고리즘

***

제한된 공간과 시간 안에서 데이터를 어떻게 처리할 것인지를 정해놓은 로직

주어진 데이터를 검색하거나 정렬 또는 총점을 구하는 등의 다양한 계산을 할 수 있는 것을 말함

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14a3fadf-eead-4b8a-9202-68fae90726cf/Untitled.png)

즉, 주어진 `input`으로 **정의된 계산을 수행**한 다음 `output` 결과값을 내는 것

### 3. 시간복잡도

***

\<aside> 💫 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계

\</aside>

1. “빠르다”, “느리다”는 `시간`으로 **표현하지 않음(시간 복잡도)**
   * 같은 알고리즘이라도 내 컴퓨터가 친구의 컴퓨터보다 빠를 수 있음
   * 컴퓨터라는 **하드웨어**가 결정하기 때문
   * “완료까지 걸리는 절차의 수”`STEPS`
   * 알고리즘을 위해 필요한 연산의 횟수
   * 특정 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지
2. **선형 알고리즘의 경우** 사이즈가 **N**개이면, **N**스텝이 필요함

### 4. 공간복잡도

***

*   공간복잡도 : 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 `메모리`를 차지하는지

    ⇒ 알고리즘을 위해 필요한 메모리의 양
* 예를 들어 `int a[1004];`라는 배열이면 a 배열은 1004X4바이트의 크기를 가지게 됨

### 5. Big O

***

출처 :[https://velog.io/@on-n-on-turtle/누구나-자료구조와-알고리즘-빅오표기법](https://velog.io/@on-n-on-turtle/%EB%88%84%EA%B5%AC%EB%82%98-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%85%EC%98%A4%ED%91%9C%EA%B8%B0%EB%B2%95)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/156f954d-121c-4a0a-baf0-a1b72655058b/Untitled.png)

\<aside> 💫 사이즈가 N개면, N스텝이 필요해요!!! 보다는 선형검색의 시간 복잡도 = O(N) 이렇게 설명하는 컨셉을 Big O

\</aside>

1. Big O란 시간복잡도를 표현하는 **표기법**
2. 언제 무엇을 쓸지 빠르게 파악 가능하며, 자신의 코드를 평가 가능
   1. 왜..? 미래에 어떻게 작동할 수 있는지 알 수 있으니
   2. Big O를 이해시, 알고리즘을 **빠르게 분석** 가능, 언제 무엇을 쓸지 파악 가능
3. 알고리즘의 퍼포먼스를 이해하기 쉽고 `효율적`으로 작성하는 방법

* 선형검색의 시간 복잡도 = `O(N)`
* but, 항상 Big O가 모든 알고리즘을 완벽히 설명하는 것은 아님

1. 배열을 인풋으로 사용할 함수, 인풋의 크기 상관없이 **동일한 수의 스텝**이 필요
   1. 아래의 코드는 print\_first라는 파이썬 함수를 정의하며, 매개변수 arr에게 받으며, arr의 첫 번째 인덱스를 출력해냄
   2. `인덱스`를 이용하여 한 번에 찾으니까
   3. 이 함수의 시간복잡도는 `constant time(상수 시간)` : **N의 크기 상관없이** 끝내는데 동일한 숫자의 스텝이 필요

```python
def print_first(arr):
		print(arr[0])
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df5f8085-6d4b-49d5-9fb5-9c0ab86f18a3/Untitled.png)

1. 이 코드의 경우 2번의 print가 있는데 2개의 스텝이 필요한 것

```python
def print_first(arr):
		print(arr[0])
		print(arr[0])
```

\<aside> 💫 이렇다면 O\[2] 일까? NO! 여전히 **O\[1]**

\</aside>

* Big O는 함수의 디테일에 관심이 없고, 러프하게 어떻게 이 함수가 `인풋의 사이즈`에 따라서 어떻게 작동하는지가 중요
* 함수는 인풋 사이즈가 엄청나게 커져도 상관없이 미리 정해진 숫자에 따라 작동

1. 즉, Big O는 큰 원리에만 관심을 가짐
2. **최악의 시나리오를 의미한다**

> 선형 검색이 항상 `O(N)`은 아니다.
>
> 검색값이 배열의 맨 처음에 있는 **최선의 시나리오**에서는 `O(1)`이고
>
> 검색값이 배열의 맨 끝에 있는 **최악의 시나리오**에서는 `O(N)`이다.
>
> **빅 오 표기법은 일반적으로 최악의 시나리오를 의미한다.**
>
> "비관적인" 접근이 유용한 도구일 수 있기 때문이다.
>
> **최악의 시나리오에서 알고리즘이 얼마나 비효율적인지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있기 때문이다.**

1. 꼭 기억해 둬야 할 것은 빅오는 `상수`를 신경 쓰지 않음

### 6. Constant Time Algorithm(상수 시간 알고리즘)

***

* constant time `(일정한 시간/상수)`
* 인풋사이즈와 관계없이 스텝이 정해진 알고리즘들
* 항상 선호하는 것 ⇒ 인풋이 늘어나도 **변하지 않음**
* 현실적으로 **항상** 만들기 힘들다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a84eac2d-f263-4201-b92e-a6354573a396/Untitled.png)

### 시간복잡도 1: Big O의 시간복잡도, 선형 시간 복잡도

***

배열의 사이즈가 10이라면, 10번 프린트 하는 함수 : **O(N)**

```python
def print_all(arr):
	for n in arr:
		print(n)
```

Q: 만약 반복문을 두번이라면 O(2N)일까? \*\*\*\*

```python
def print_all(arr):
	for n in arr:
		print(n)
	for n in arr:
		print(n)
```

A: **2는 상수**이기에 **버려두고**, 여전히 `O(N)`으로 표현, 핵심은 변하지 않았지 때문

메세지가 같다 ⇒ `인풋이 증가`하면 `스텝도 선형적으로 증가`

#### O(N)이나 선형 시간복잡도를 그래프

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94f0c5eb-bfa5-46ca-840b-06e9b13ba969/Untitled.png)

### 7. 시간복잡도 2 : Quadratic Time(2차 시간)

***

* \*\*`Nested Loops(중첩 반복)`\*\*이 있을 때, 발생
* 아래의 경우 배열의 각 아이템에 대해 루프를 반복, 실행

```python
def print_twice(arr)
	for n in arr:
		for x in arr:
			print(x, n)
```

*   시간복잡도 : **인풋 $n^2$**

    EX. 인풋이 10개시 100번의 스텝 : **루프 안의 루프**에서 함수를 실행시키기 때문

#### 2차 시간복잡도 그래프를 선형 시간복잡도와 비교 그래프

<figure><img src="../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**선형 시간복잡도**가 2차 시간복잡도보다 더 **효율적**

### 8. 시간복잡도 3 : 로그 시간(Logarithmic Time)

***

1. 이진검색 알고리즘 설명시 사용 ⇒ 얼마나 `빠른지` 설명 가능
   1. 이진 검색 알고리즘은 인풋 사이즈가 2배가 되어도 필요한 step의 수는 1개밖에 안들어남
   2. 왜냐? 이진검색은 각 프로세스의 스텝을 절반으로 나눠서 하기 때문이
2. 표현법 : `O(log N)`
3. 정렬된 배열에만 사용 가능
4. exponent(지수) ↔ logarithm(로그)

* n = $log\_232$ n은 32를 2로 몇번을 나눠야 1이 나올까?

\<aside> 💫 32 / 2 = 16 ← 1 16 / 2 = 8 ← 2 8 / 2 = 4 ← 3 4 / 2 = 2 ← 4 2 / 2 = 1 ← 5 times

\</aside>

*   n은 5

    ⇒ 이진 검색과 같음 인풋을 반으로 나누고 시작하는 것처럼

    ⇒ Big O의 특성상 n = $log32$ 아래의 2가 사라짐

    ⇒ So, `log N`이 되는 것
* 로그 시간복잡도의 **그래프**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a2a6b79-5432-4c11-b095-34e5c7c7fb01/Untitled.png)

**선형시간**보다는 `빠르고`, **상수 시간**보다는 `느림`

### 9. **O(1) & O(N) & O(logN) 그래프**

***

**O(1) > O(logN) > O(N) 순으로 가장 효율적이다.**

O(logN)은 아주 조금씩 증가하는 곡선을 그리고 있는데 O(1)보다는 덜 효율적이지만 O(N)보다는 훨씬 효율적이다.

사진 출처 : [https://velog.io/@welloff\_jj/Complexity-and-Big-O-notation](https://velog.io/@welloff\_jj/Complexity-and-Big-O-notation)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/baa069dd-848e-402a-88f2-84806fc07973/Untitled.png)

### 10. 그렇다면 연습문제

***

#### 📖 리스트 내 모든 항목을 출력함

```jsx
public static void printThings() {
    String[] things = {"apples", "chairs", "files", "notes"};

    for (String thing : things)
        System.out.printf("Here's a thing : %s \\n", thing);
}
```

이 알고리즘의 `for`루프에서 배열의 원소가 4개이기 때문에 4단계가 걸린다.

만약 배열의 원소가 10개이면 10단계가 걸릴 것이다.

**`for`루프에 대입되는 배열의 원소 갯수만큼 단계가 걸리므로 이 알고리즘의 효율성은 O(N)이다.**

#### 📖 **주어진 해가 윤년인지 알아봄**

```jsx
public static boolean isLeapYear(int year) {
    return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);
}
```

**`N`은 `number`이다.**

**함수로 전달된 수에 상관없이 단계 수가 일정하므로 O(1)알고리즘이다.**
