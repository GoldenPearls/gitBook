# 5장 웹서버

* 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사한다.
* HTTP 통신을 진단해주는 간단한 웹 서버를 `펄(Perl)`로 작성해본다.
* 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지 단계별로 설명한다.

## 1. 다채로운 웹 서버

* 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.&#x20;
* `웹 서버`는 웹 서버  &#x20;소프트웨어와 웹페이지 제공에 특화된 장비(컴퓨터와 같은) 양쪽 모두를 가리킨다.
* 모든 웹 서버는 리소스에 대한 HTTP 요청을  &#x20;받아서 콘텐츠를 클라이언트에게 돌려준다.

### 1) 웹 서버 구현

{% hint style="warning" %}
웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.&#x20;
{% endhint %}

* 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능  \
  을 제공한다.
* 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.
  * 운영체제 : 컴퓨터 시스템의 하드웨어를 관리하고 TCP/IP 네트워크 지원, 웹 리소    \
    스를 유지하기 위한 파일 시스템, 현재 연산 활동을 제어하기 위한 프로세스 관리    \
    를 제공

### 2) 다목적 소프트웨어 웹 서버

{% hint style="warning" %}
다목적 소프트웨어 웹 서버는 **네트워크에 연결된 표준 컴퓨터 시스템**에서 동작한다.
{% endhint %}

* 오픈 소스 소프트웨어 : 아파치, W3C
* 상용 소프트웨어 : 마이크  로소프트, 아이플래닛의 웹 서버&#x20;

> 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작

넷크래프트의 자동화된 조사에 의해 추정된 웹 시장 점유율의 경우, 책은 너무 오래돼서 찾아봄

<figure><img src="../../../../.gitbook/assets/image (6).png" alt=""><figcaption><p><a href="https://velog.io/@secuwave/NGINX%EC%9D%98-%EC%84%B8%EA%B3%84%EC%A0%81%EC%9D%B8-%EC%A0%90%EC%9C%A0%EC%9C%A8%EA%B3%BC-%EA%B7%B8-%EC%9D%B4%EC%9C%A0">https://velog.io/@secuwave/NGINX%EC%9D%98-%EC%84%B8%EA%B3%84%EC%A0%81%EC%9D%B8-%EC%A0%90%EC%9C%A0%EC%9C%A8%EA%B3%BC-%EA%B7%B8-%EC%9D%B4%EC%9C%A0</a></p></figcaption></figure>

> 현재 NGINX는 월드와이드웹을 지탱하는 주요 웹 서버로 자리매김하고 있다.>

Netcraft의 최신 통계에 따르면, NGINX는 전 세계 웹 서버의 **약 33%를 차지하고 있다.**\
아파치 HTTP 서버(27%)와 비교할 때, NGINX는 압도적인 시장 점유율을 보이고 있으며,\
이는 그 유연성과 성능 때문이다.

**1️⃣ 웹 서버 시장 점유율**

* **NGINX**는 현재 전 세계 웹 서버의 약 **33%**&#xB97C; 차지하며,\
  `Apache HTTP Server(27%)`를 앞지르고 있음.
* 이러한 시장 지배력은 **유연한 아키텍처와 높은 성능** 덕분임.
* NGINX는 정적 리소스 처리뿐 아니라 **프록시 서버, 로드 밸런서, 리버스 프록시** 등\
  다양한 역할을 수행할 수 있는 다목적 서버로 자리잡음.

**2️⃣ 클라우드 환경에서의 활용**

* **AWS, Azure, GCP** 등 주요 클라우드 플랫폼에서 기본적으로 지원.
* `가용성(availability)`과 `확장성(scalability)`이 뛰어나\
  **클라우드 네이티브 아키텍처**에 적합함.
* 특히 **Kubernetes** 환경에서 **Ingress Controller**로 널리 사용됨.\
  → 모던 애플리케이션 배포에 최적화되어 있음.

**3️⃣ 트래픽 관리 및 성능**

* NGINX는 **효율적인 로드 밸런싱** 기능을 통해 대규모 트래픽을 분산 처리함.
* 이를 통해 **대형 웹사이트의 안정성 향상** 및 **응답 속도 개선** 가능.
* 실제로 **대형 인터넷 기업**들이\
  서버 자원 효율성 및 사용자 경험 개선을 위해 NGINX를 도입함.

**⚙️ NGINX 선택 이유 요약**

| 구분                              | 설명                                                     |
| ------------------------------- | ------------------------------------------------------ |
| **성능 (Performance)**            | 경량 구조로 빠른 처리 속도 제공. 정적 파일 서빙, 리버스 프록시, 로드 밸런싱 등 다기능 지원 |
| **유연성 (Flexibility)**           | 다양한 모듈 및 설정 옵션으로 상황에 맞는 커스터마이징 가능                      |
| **비용 효율성 (Cost Efficiency)**    | 무료 오픈소스 제공 + 유료 버전 없이도 고급 기능 활용 가능                     |
| **커뮤니티 지원 (Community Support)** | 활발한 커뮤니티와 지속적인 업데이트로 안정적 생태계 형성                        |

**🧩 결론**

* NGINX는 **웹 서버 + 프록시 서버**로서 현대 웹 인프라의 핵심 구성요소임.
* 높은 성능, 확장성, 유연성을 바탕으로 **클라우드 및 컨테이너 시대의 표준 서버**로 자리함.
* 앞으로도 **웹 기술 발전의 주요 동력**으로 지속적인 성장과 발전이 기대됨.



### 3) 임베디드 웹 서버

임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버\
이다(예: 프린터나 가전제품)



## 2. 최소 기능 펄(Perl) 웹 서버: `type-o-serve`&#x20;

### 1️)  개요

HTTP/1.1을 완전히 지원하는 서버는 **가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 성능 최적화 기능** 등 다양한 요소가 필요하죠.

> 하지만 “HTTP가 어떻게 작동하는지”를 이해하기 위한 최소 기능 서버는 단 **30줄 미만의 Perl 코드**로도 충분히 만들 수 있다.

그 대표적인 예가 바로 **`type-o-serve`**&#x20;

이 유틸리티는 **HTTP 요청과 응답의 상호작용을 실험하고 디버깅하는 간단한 도구**로, 클라이언트(예: 브라우저)와 프록시의 요청이 어떻게 오가는지를 직접 눈으로 확인할 수 있게 해준다.

### 2️)  `type-o-serve`의 동작 방식

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

| 단계                | 동작 내용                                      |
| ----------------- | ------------------------------------------ |
| **1. 포트 설정**      | 기본 포트는 **8080**, 명령줄에서 다른 포트 지정 가능         |
| **2. 소켓 생성 및 대기** | TCP 소켓을 열고 클라이언트의 연결을 기다림 (`listen()`)     |
| **3. 연결 수락**      | 브라우저나 클라이언트가 접속하면 연결 수락 (`accept()`)       |
| **4. 요청 수신 및 출력** | 클라이언트가 보낸 **HTTP 요청 메시지**를 한 줄씩 화면에 출력     |
| **5. 응답 입력 대기**   | 서버 운영자가 응답 내용을 직접 콘솔에 입력 (마침표 `.` 한 줄로 종료) |
| **6. 응답 전송**      | 입력된 내용을 **HTTP 응답 메시지** 형식으로 클라이언트에게 전송    |
| **7. 연결 종료**      | `close()`로 세션 종료, 다시 다음 요청을 기다림            |

종 더 자세한 이미지지

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>



### 3️) 예제 코드&#x20;

```perl
#!/usr/bin/perl
use Socket;
use FileHandle;

# (1) 포트 설정 (기본값 8080)
$port = ($ARGV[0]) ? $ARGV[0] : 8080;
$proto = getprotobyname('tcp');

# (2) 소켓 생성 및 바인딩
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;
printf("<<Type-o-Serve Accepting on Port %d>>\n", $port);

while (1) {
    # (3) 연결 수락
    $cport_caddr = accept(C, S);
    ($cport, $caddr) = sockaddr_in($cport_caddr);
    $C->autoflush(1);

    # (4) 요청 출력
    $cname = gethostbyaddr($caddr, AF_INET);
    printf("<<<Request From %s>>>\n", $cname);
    while ($line = <C>) {
        print $line;
        last if $line =~ /^\r/;  # 빈 줄이면 요청 끝
    }

    # (5) 응답 입력 및 전송
    printf("<<<Type response followed by '.'>>>\n");
    while ($line = <STDIN>) {
        chomp($line);
        last if $line eq ".";
        print C $line . "\r\n";
    }

    close(C);
}
```

### 4️) 실제 동작 예시

**실행**

```bash
perl type-o-serve.pl 8080
```

**브라우저에서 요청**

```
http://www.joes-hardware.com:8080/foo/bar
```

**서버 콘솔 출력 예시**

```
<<Type-o-Serve Accepting on Port 8080>>
<<<Request From home-44-027.extranet.inktomi.com>>>
GET /foo/bar HTTP/1.0
Host: www.joes-hardware.com:8080
User-Agent: Mozilla/4.0
Connection: Keep-Alive

<<<Type response followed by '.'>>>
```

여기서 관리자는 응답을 직접 입력한다.



**입력**

```
HTTP/1.0 200 OK
Connection: close
Content-type: text/plain

Hi there!
.
```

→ 클라이언트는 이 응답을 받아 브라우저 화면에 “Hi there!” 출력.



### 5️) 부가 설명: 왜 중요한가?

| 개념                   | 설명                                                         |
| -------------------- | ---------------------------------------------------------- |
| **HTTP 요청/응답 구조 실습** | 브라우저가 어떤 형태로 요청을 보내고, 서버가 어떻게 응답하는지를 직접 눈으로 확인 가능          |
| **디버깅용 테스트 서버**      | 프록시, 방화벽, 클라이언트 라이브러리 등을 실험할 때 매우 유용                       |
| **학습 목적**            | HTTP 헤더의 구조, CRLF(`\r\n`) 구분, 연결 종료 시점 등 프로토콜 기본기를 이해하기 좋음 |
| **경량 서버 구조 이해**      | 실제 상용 웹 서버(NGINX, Apache)가 내부적으로 하는 일을 단순화해 보여줌            |

### &#x20;6) 핵심 요약

| 항목        | 내용                           |
| --------- | ---------------------------- |
| **서버 이름** | `type-o-serve`               |
| **언어**    | Perl                         |
| **기능**    | HTTP 요청을 받아 출력, 직접 응답 타이핑 가능 |
| **용도**    | HTTP 디버깅, 학습, 테스트            |
| **특징**    | 30줄 이하의 초간단 HTTP 서버          |

{% hint style="success" %}
**“type-o-serve”는 단 30줄짜리 Perl 코드로, HTTP 요청과 응답의 원리를 눈으로 확인할 수 있는 초간단 진단 서버다.**
{% endhint %}

## 3. 진짜 웹 서버가 하는 일

<figure><img src="../../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

아래 사진은 좀 더 나아가.. 모던 웹 어플리케이션 아키텍처임

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption><p><a href="https://blog.rhostem.com/posts/2018-07-22-web-architecture-101">https://blog.rhostem.com/posts/2018-07-22-web-architecture-101</a></p></figcaption></figure>

### 1) 클라이언트 커넥션 수락 단계&#x20;

**1️⃣ 개요 — “서버는 어떻게 연결을 받아들이는가?”**

클라이언트가 서버에 HTTP 요청을 보내려면, 먼저 **TCP 커넥션(connection)** 을 열어야 한다.

* 이미 **지속 커넥션(persistent connection)** 이 열려 있다면 → 그대로 재사용 가능.
* 그렇지 않다면 → 새로운 TCP 연결을 만들어야 함.

> 즉, 웹 서버의 첫 번째 역할은 **클라이언트의 커넥션 요청을 수락(Accept)** 하는 것이다.



**2️⃣ 단계별 작동 흐름**

| 단계                | 설명                                            |
| ----------------- | --------------------------------------------- |
| **① 클라이언트 요청 수신** | 클라이언트가 서버에 TCP 연결을 요청 (3-way handshake)       |
| **② 커넥션 수락 및 등록** | 서버가 연결을 허용하고, 내부 커넥션 목록(connection table)에 추가 |
| **③ 클라이언트 식별**    | IP 주소나 호스트명(DNS 역방향 조회)으로 클라이언트를 식별           |
| **④ 필요 시 인증/차단**  | 비인가 IP, 악의적 접근 등은 즉시 커넥션을 닫을 수 있음             |
| **⑤ 데이터 처리 준비**   | 요청 메시지를 읽고 응답을 돌려줄 준비 완료                      |



**3️⃣ 세부 개념별 설명**

&#x20;(1) 새 커넥션 다루기

* TCP 커넥션 요청이 들어오면, 서버는 커넥션을 “수락(accept)”하고 **상대의 IP 주소를 추출**함.
* 이 IP 주소는 로그, 접근 제어, 통계 등에 사용됨.
* 운영체제마다 다르지만, 유닉스 환경에서는 TCP 커넥션이 **소켓(Socket)** 으로 표현됨.
  * 예: `getpeername()` 호출로 클라이언트 IP 획득
* 서버는 특정 조건(IP 차단, 접근 정책 등)에 따라 **커넥션을 거부하거나 즉시 종료**할 수 있음.

{% hint style="success" %}
“모든 요청을 다 받아주는 것이 아니라, 신뢰할 수 있는 연결만 유지한다.”
{% endhint %}



(2) 클라이언트 호스트명 식별 (Reverse DNS Lookup)

* 대부분의 웹 서버는 클라이언트 IP를 **역방향 DNS(Reverse DNS)** 로 변환해 도메인 형태의 **호스트 이름(hostname)** 을 얻는다.&#x20;
  * Reverse DNS는 “IP → 도메인 이름” 변환, RARP는 “MAC → IP 주소” 변환
* 예: `203.255.255.10` → `user.isp.co.kr`
* 이 정보는 다음 용도로 활용된다.
  * 🔸 접근 제어 (특정 도메인만 허용/차단)
  * 🔸 로깅 및 통계
  * 🔸 트래픽 분석

**주의점:**

* 호스트 이름 조회는 시간이 오래 걸림 → 트랜잭션 지연 가능
* 대규모 서버는 성능 저하 방지를 위해 보통 “비활성화”함.



**Apache 예시 설정:**

```apache
# 기본적으로 비활성화
HostnameLookups off

# HTML, CGI 파일 요청에 대해서만 활성화
<Files ~ "\.(html|cgi)$">
  HostnameLookups on
</Files>
```



(3) ident 프로토콜을 통한 사용자 식별

**개념:**

* IETF의 **ident 프로토콜(RFC 1413)** 은 TCP 연결을 연 사용자의 **로컬 사용자명(username)** 을 알아내는 프로토콜
* 서버가 클라이언트의 identd 서버 포트(113) 로 연결하여 “이 HTTP 요청을 보낸 사용자가 누구인지”를 질의한다.



**동작 흐름**

<figure><img src="../../../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

| 단계  | 설명                                       |
| --- | ---------------------------------------- |
| (a) | 클라이언트(메리)가 HTTP 커넥션을 염 (예: 4236 → 80 포트) |
| (b) | 서버는 클라이언트의 identd(113 포트)에 별도 커넥션 생성     |
| (c) | 서버 → ident 요청 전송: `4236,80`              |
| (d) | 클라이언트 → ident 응답: `USERID:UNIX:mary`     |

{% hint style="warning" %}
서버는 “이 포트를 연 사용자가 누구냐?”를 ident 프로토콜로 물어보는 것.
{% endhint %}



**4️⃣ ident 프로토콜의 문제점**

| 한계              | 설명                                   |
| --------------- | ------------------------------------ |
| ❌ **보편성 낮음**    | 대부분의 PC는 ident 데몬(`identd`)을 실행하지 않음 |
| ❌ **속도 저하**     | 추가적인 TCP 연결로 HTTP 트랜잭션 지연            |
| ❌ **보안 문제**     | 응답 위조 가능, 신원 조작 쉬움                   |
| ❌ **방화벽 차단**    | 기업·기관망에서 113 포트가 차단되는 경우 많음          |
| ❌ **가상 IP 미지원** | NAT 환경에서는 정확한 사용자 식별 불가              |
| ❌ **개인정보 문제**   | 사용자 계정 노출로 인한 프라이버시 침해 우려            |

📌 **따라서:**

→ 현대의 웹 환경에서는 거의 사용되지 않습니다.

→ Apache에서도 `IdentityCheck on` 설정으로 켤 수 있지만, 대부분 비활성화(default off) 상태입니다.

**Apache 설정 예:**

```apache
IdentityCheck on
```

* ident 결과가 없으면 로그의 해당 필드는 `-` (하이픈)으로 표시됨.
* 일반 로그 포맷(Common Log Format)의 두 번째 필드가 바로 이 값임.



예시 로그:

```
192.168.0.5 - frank [10/Oct/2025:13:55:36 +0900] "GET /index.html HTTP/1.1" 200 2326
```

→ 여기서 두 번째 `-` 가 ident 필드.



**5️⃣ 요약 정리**

| 항목        | 내용                                     |
| --------- | -------------------------------------- |
| **단계명**   | 클라이언트 커넥션 수락                           |
| **핵심 역할** | TCP 커넥션을 받아들이고, 클라이언트 식별 및 관리          |
| **주요 기능** | ① 새 커넥션 수락 ② 호스트명 확인 ③ 사용자 식별 (ident)  |
| **보안 고려** | IP/호스트 기반 접근 제어, 악의적 요청 차단             |
| **성능 고려** | DNS Lookup 및 ident는 지연 발생 → 일반적으로 비활성화 |

**부가 해설 — 현대적 맥락에서의 이해**

| 항목             | 과거               | 현재                        |
| -------------- | ---------------- | ------------------------- |
| **커넥션 처리**     | 단일 프로세스가 요청마다 처리 | 이벤트 기반 (NGINX, Node.js 등) |
| **DNS Lookup** | 요청 시마다 수행        | CDN·Proxy 단에서 캐시 처리       |
| **사용자 식별**     | ident, IP 기반     | 토큰 기반(OAuth, JWT), 쿠키 인증  |
| **보안**         | 단순 IP 차단         | WAF, SSL 인증서, 방화벽 규칙 등    |

{% hint style="success" %}
🔍 즉, 지금의 웹 서버들은 “연결 수락” 자체를 **논블로킹(비동기 I/O)** + **보안 계층(TLS)** + **프록시 계층(LB)** 으로 분리하여 처리한다. 이거에 대한 설명
{% endhint %}

<figure><img src="../../../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

> **HTTP 서버는 클라이언트의 요청을 수락하면서 IP·호스트·사용자 정보를 식별하지만, 성능과 보안을 위해 대부분의 식별 기능(DNS·ident)은 제한적으로 사용된다.**

### 2) 요청 메시지 수신 (Receiving Request Message)

**1️⃣ 핵심 개요**

클라이언트(브라우저)가 요청을 보내면, 서버는 TCP 커넥션을 통해 데이터를 받는다.\
이 데이터를 **읽어서 파싱**(해석)하여 HTTP 요청 메시지를 구성한다.



**2️⃣ 요청 메시지 수신의 기본 과정**

| 단계                   | 설명                                                                |
| -------------------- | ----------------------------------------------------------------- |
| **① 네트워크로부터 데이터 수신** | 커넥션 소켓을 통해 TCP 스트림에서 바이트 단위로 데이터를 읽어들임                            |
| **② 요청 라인 파싱**       | 첫 줄을 읽어 **HTTP 메서드(GET/POST 등)**, **요청 URI**, **HTTP 버전** 추출      |
| **③ 헤더 파싱**          | 각 헤더를 한 줄씩 읽어 이름:값 형태로 저장, CRLF(`\r\n`)로 구분                       |
| **④ 빈 줄(CRLF CRLF)** | 헤더와 본문(body)을 구분하는 경계로 인식                                         |
| **⑤ 본문 읽기**          | `Content-Length` 또는 `Transfer-Encoding: chunked` 헤더에 따라 바디 데이터 수신 |
| **⑥ 내부 구조화**         | 파싱된 데이터는 서버 내부 자료구조(예: 구조체, 테이블, 해시맵)에 저장되어 빠른 접근이 가능하게 함         |



예시로 보는 요청 파싱

```
GET /specials/saw-blade.gif HTTP/1.0\r\n
Accept: image/gif\r\n
Host: www.joes-hardware.com\r\n
\r\n
```

➡ 파싱 후 서버 내부 구조 (예시)

| 항목                 | 값                                                      |
| ------------------ | ------------------------------------------------------ |
| method             | GET                                                    |
| uri                | /specials/saw-blade.gif                                |
| version            | HTTP/1.0                                               |
| headers\["Host"]   | [www.joes-hardware.com](http://www.joes-hardware.com/) |
| headers\["Accept"] | image/gif                                              |
| body               | (없음)                                                   |

요청 메시지를 파싱할 때, 웹 서버는 입력 데이터를 네트워크로부터 `불규칙적`으로&#x20;받는다.&#x20;

네트워크 커넥션은 언제라도 무효화될 수 있다. 웹 서버는 파싱해서 이해&#x20;하는 것이 가능한 수준의 분량을 확보할 때까지 데이터를 네트워크로부터 읽어**서&#x20;메시지 일부분을 메모리에 임시로 저장해 둘 필요가 있다**



3️⃣ 요청 메시지의 **내부 표현 구조**

<figure><img src="../../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

대부분의 웹 서버는 파싱된 요청을 메모리 구조체로 관리한다.

* 요청 라인 (method, URI, version)
* 헤더 목록 (HashMap/Dictionary)
* Body (스트림/버퍼)
* 각 필드의 **포인터(pointer)** 와 **길이(length)** 도 함께 저장되어, 문자열을 새로 복사하지 않아도 빠르게 참조 가능.

{% hint style="success" %}
이 구조 덕분에, 서버는 수천 개의 요청을 동시에 처리하면서도 메모리 낭비를 최소화한다.
{% endhint %}



**4️⃣ 커넥션 입력/출력(I/O) 처리 아키텍처**

<figure><img src="../../../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

(1) 단일 스레드 서버 (Single-threaded)

* **특징:** 한 번에 한 요청만 처리.
* **장점:** 구현 간단.
* **단점:** 다른 요청이 도착해도 **현재 요청이 끝날 때까지 대기**해야 함.
* **예시:** 테스트용 도구(`type-o-serve`) 수준에 적합.

🧱 **문제점:** 네트워크 지연이 발생하면 전체 서버가 멈춤.



(2) 멀티프로세스 / 멀티스레드 서버

* **특징:** 요청마다 **별도 프로세스/스레드** 생성 → 병렬 처리 가능.
* **장점:** 여러 요청을 동시에 처리.
* **단점:** 스레드/프로세스 생성 비용 + 메모리 오버헤드.
* **예시:** Apache MPM(pre-fork, worker) 모드.

{% hint style="warning" %}
**보완책:** 미리 스레드/프로세스를 만들어 두는 **워커 풀(worker pool)** 방식.\
→ 새 요청이 들어오면 즉시 유휴 워커가 처리.
{% endhint %}



(3) 다중 I/O 서버 (Multiplexed I/O)

* **핵심 아이디어:** 모든 커넥션을 **한 프로세스/스레드**가 동시에 감시(epoll, select 등).
* **장점:** 수천, 수만 개의 커넥션을 동시에 처리 가능.
* **대표 예시:** NGINX, Node.js, Envoy, HAProxy 등
* **동작 방식:**
  * 요청이 “읽을 준비가 됐을 때(readable)” 또는\
    “쓸 준비가 됐을 때(writable)”만 이벤트를 받아 처리.
  * 유휴 연결은 리소스를 거의 소모하지 않음.

> 즉, 커넥션이 “할 일이 생겼을 때만” CPU가 반응하는 구조!



**5️⃣ 현대적 관점에서의 발전 (2020s 버전)**

| 과거                          | 현대                                             |
| --------------------------- | ---------------------------------------------- |
| 단일 스레드 or 프로세스 기반           | **이벤트 기반 논블로킹 I/O** (epoll, kqueue, io\_uring) |
| `read()` / `write()` 블로킹 호출 | **이벤트 루프(event loop)** 중심                      |
| 스레드 수 = 커넥션 수               | **1 워커 = 수만 커넥션 처리 가능**                        |
| HTTP/1.0 단일 요청-응답           | **HTTP/2, HTTP/3** 멀티플렉싱으로 동시 요청               |
| OS 커널 레벨 버퍼링 의존             | **비동기 소켓 + 백프레셔(backpressure)** 제어             |
| 직접 TCP 커넥션 관리               | **커넥션 풀링 + keep-alive + TLS 세션 재사용**           |
| 단순 요청 파싱                    | **파이프라인 요청, 스트림 기반 프레임 파싱 (HTTP/2 프레임 구조)**    |



**6️⃣ 구조적 비교 요약표**

| 아키텍처                | 처리 방식 | 동시성      | 대표 기술                    | 장단점            |
| ------------------- | ----- | -------- | ------------------------ | -------------- |
| 단일 스레드              | 순차    | 1        | type-o-serve             | 구현 쉬움 / 성능 낮음  |
| 멀티스레드               | 병렬    | 10\~1000 | Apache (worker MPM)      | 병렬성↑ / 메모리 부담↑ |
| 다중 I/O (이벤트 기반)     | 논블로킹  | 1 → 10만  | NGINX, Node.js, Envoy    | 고효율 / 복잡도↑     |
| 하이브리드 (멀티스레드+이벤트루프) | 결합형   | 수십만      | NGINX, epoll+worker pool | 멀티코어 활용 극대화    |



7️⃣ 💡 시각적 개념 정리

```
[ Client ] → [ Socket Listener ]
     ↓
 ┌───────────────────────────────┐
 │ 단일 스레드: 한 요청씩 처리  │
 │ 멀티스레드: 요청마다 스레드 │
 │ 다중 I/O: 이벤트 루프로 관리 │
 └───────────────────────────────┘
     ↓
[ Request Parser ] → [ Internal Data Structure ]
     ↓
[ Router / App Logic ] → [ Response Writer ]
```

{% hint style="success" %}
**웹 서버는 클라이언트로부터 요청 데이터를 수신하고 파싱한 뒤, 내부 구조로 저장한다. 현대 서버들은 이를 수만 개 커넥션에 대해 비동기 이벤트 기반으로 처리한다.**
{% endhint %}



### 3) 요청 처리 : 메서드·리소스·헤더·본문 처리

**1️⃣ 핵심 요약**

웹 서버가 요청을 받으면 다음과 같은 구성 요소를 파싱한다.

| 구성 요소             | 설명                                                                  |
| ----------------- | ------------------------------------------------------------------- |
| **메서드(Method)**   | 클라이언트가 서버에 요청하는 동작의 종류 (`GET`, `POST`, `PUT`, `DELETE` 등)           |
| **리소스(Resource)** | 요청 대상(URI) – 어떤 자원에 접근할지                                            |
| **헤더(Header)**    | 요청의 부가 정보 (`User-Agent`, `Content-Type`, `Host`, `Authorization` 등) |
| **본문(Body)**      | 실제 데이터(payload). 없는 경우도 많음. 예: 폼 데이터, JSON, 파일 등                    |

**2️⃣ HTTP 메서드별 본문(Body) 처리 규칙**

| 메서드         | 본문 허용 여부 | 설명                                                |
| ----------- | -------- | ------------------------------------------------- |
| **GET**     | ❌ 금지     | 리소스 요청만 수행. 서버 상태를 바꾸지 않음. (Body는 무시됨)            |
| **HEAD**    | ❌ 금지     | GET과 동일하지만, 응답 본문은 없음.                            |
| **POST**    | ✅ 필수     | 클라이언트가 서버로 데이터를 전송 (예: 로그인, 폼 제출, 파일 업로드)         |
| **PUT**     | ✅ 필수     | 기존 리소스를 대체하거나 새로 생성할 때 사용.                        |
| **DELETE**  | ⚙️ 선택적   | 일부 서버는 Body를 허용하지만, 대부분 무시함.                      |
| **PATCH**   | ✅ 선택     | 리소스의 일부만 수정할 때 사용.                                |
| **OPTIONS** | ⚙️ 선택    | 특정 리소스가 지원하는 메서드나 CORS 정보를 질의할 때. Body를 보낼 수도 있음. |
| **TRACE**   | ❌ 금지     | 요청의 루프백 테스트용. Body 없음.                            |



**3️⃣ 부가 설명 — 왜 본문이 없는 경우가 많을까?**

HTTP는 **텍스트 기반 프로토콜**이라서, “요청의 의도”를 **요청 라인과 헤더**만으로도 충분히 전달할 수 있다.

(1) GET 요청 (본문 없음)

```
GET /products HTTP/1.1
Host: shop.example.com
```

👉 서버는 단순히 `/products` 페이지를 조회해서 HTML을 반환.



(2) POST 요청 (본문 있음)

```
POST /login HTTP/1.1
Host: shop.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 32

username=goldenpearls&password=1234
```

👉 서버는 본문을 읽어 **사용자 인증 로직**을 수행.



**4️⃣ 현대 웹에서의 확장 설명**

| 항목                        | 설명                                                                                                    |
| ------------------------- | ----------------------------------------------------------------------------------------------------- |
| **본문 형식 다양화**             | JSON(`application/json`), XML, 폼데이터(`multipart/form-data`), 파일 업로드, GraphQL 쿼리 등                      |
| **본문 파싱(Parsing)**        | 서버는 요청 헤더의 `Content-Type`에 따라 파서를 선택함. 예: Express.js → `body-parser`, Spring → `HttpMessageConverter` |
| **본문 유효성 검증(Validation)** | 요청 크기 제한(`maxRequestSize`), 필드 검증(`@Valid`), 보안 검사(XSS, SQL Injection 방지)                             |
| **스트리밍/청크 전송**            | 대용량 업로드 시 `Transfer-Encoding: chunked` 방식 사용 → 본문 크기를 미리 알 수 없음                                       |
| **CORS 및 OPTIONS 요청**     | 브라우저의 사전 요청(Preflight Request)에서는 OPTIONS 메서드를 사용하며, 대부분 본문 없음                                        |
| **HTTP/2, HTTP/3의 영향**    | 본문도 스트림 단위로 나뉘어 전송되어 병렬 처리가 가능해짐                                                                      |



**5️⃣ 간단 정리표**

| 구분           | GET    | POST      | PUT       | OPTIONS    |
| ------------ | ------ | --------- | --------- | ---------- |
| **목적**       | 데이터 조회 | 데이터 전송/생성 | 데이터 수정/대체 | 서버 정보 조회   |
| **본문 여부**    | ❌ 없음   | ✅ 있음      | ✅ 있음      | ⚙️ 선택      |
| **응답 본문**    | ✅ 있음   | ✅ 있음      | ✅ 있음      | ⚙️ 선택      |
| **대표 사용 사례** | 페이지 조회 | 로그인/폼 제출  | 리소스 업데이트  | CORS 사전 요청 |

**보충 이해: “엔터티 본문(Entity Body)”의 의미**

HTTP에서 “엔터티(Entity)”란 **메시지 전체를 의미**하고, 그중 실제 데이터 부분을 “엔터티 본문(Entity Body)”이라고 한다.

* 요청 본문(Request Body): 클라이언트 → 서버로 전송되는 데이터
* 응답 본문(Response Body): 서버 → 클라이언트로 전송되는 데이터

예를 들어, `Content-Length`는 **엔터티 본문의 크기**를 나타내는 헤더

{% hint style="success" %}
웹 서버는 요청을 파싱해 메서드, 리소스, 헤더, 본문을 구분하며, 메서드 종류에 따라 본문의 존재 여부와 의미가 달라진다. 현대 웹에서는 JSON·파일·스트리밍 등 다양한 형태의 본문을 효율적으로 처리하도록 확장되었다.
{% endhint %}

### 4) 리소스의 매핑과 접근

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

**1️⃣ 개요**

웹 서버(Web Server)는 기본적으로 **리소스(Resource) 제공자**이다.\


즉,

* **정적 리소스(static)** → 미리 존재하는 파일 (HTML, CSS, 이미지 등)
* **동적 리소스(dynamic)** → 요청 시 생성되는 콘텐츠 (예: PHP, JSP, Servlet, Node.js 등)\
  를 **클라이언트에게 반환하는 역할**을 한다.



> 서버는 클라이언트가 보낸 **URI(Request URI)** 를 해석해 **어떤 파일**을 줄지, 혹은 **어떤 프로그램**을 실행할지를 결정한다.



**Docroot (문서 루트)**

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

🔹 개념

* 웹 서버는 보통 콘텐츠 파일들이 저장된 “기준 디렉터리(base directory)”를 가지고 있다. 이를 **Document Root (docroot)** 라고 부른다.
* 요청 URI는 이 **docroot**에 상대 경로로 붙여서 실제 파일 경로를 계산한다.

> 웹 서버는 요청 메시지에서> &#x20;URI를 가져와서 문서 루트 뒤에 붙인다.

📘 **예시**

<figure><img src="../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

```
요청 URI: /specials/saw-blade.gif
DocumentRoot: /usr/local/httpd/files

→ 실제 파일 경로:
/usr/local/httpd/files/specials/saw-blade.gif
```



⚠️ 보안 주의

서버는 `/../` 와 같은 상대 경로 접근을 허용하면 **docroot 바깥 파일(시스템 파일 등)** 이 노출될 수 있으므로 이를 반드시 차단한다.



**가상 호스팅(Virtual Hosting)**

🔹 개념

하나의 물리적 서버(IP 주소)에서 **여러 웹사이트(도메인)** 를 운영하는 기능이다. 서버는 **Host 헤더**(또는 IP)로 어떤 사이트의 요청인지 구분하고 각 사이트마다 **별도의 문서 루트(docroot)** 를 가진다.

📘 **예시**

<figure><img src="../../../../.gitbook/assets/image (393).png" alt=""><figcaption></figcaption></figure>

| Host 헤더                                                  | 실제 루트 경로     | 반환 파일                   |
| -------------------------------------------------------- | ------------ | ----------------------- |
| [www.joes-hardware.com](http://www.joes-hardware.com/)   | `/docs/joe`  | `/docs/joe/index.html`  |
| [www.marys-antiques.com](http://www.marys-antiques.com/) | `/docs/mary` | `/docs/mary/index.html` |

🛠️ **Apache 설정 예시**

```apache
<VirtualHost www.joes-hardware.com>
  ServerName www.joes-hardware.com
  DocumentRoot /docs/joe
</VirtualHost>

<VirtualHost www.marys-antiques.com>
  ServerName www.marys-antiques.com
  DocumentRoot /docs/mary
</VirtualHost>
```

{% hint style="success" %}
👉 이 방식으로 하나의 서버가 여러 독립된 사이트를 호스팅할 수 있다.  즉, **“한 몸에 여러 입을 단 서버”**.
{% endhint %}



**사용자 홈 디렉터리 Docroot**

🔹 개념

* 여러 사용자가 한 서버를 공유할 때, 각 사용자가 자신의 홈 디렉터리에서 웹 페이지를 서비스할 수 있다.
* URL은 `~사용자명` 형태로 구분된된다.



📘 **예시**

```
GET /~betty/index.html HTTP/1.0

→ 실제 파일:
/home/betty/public_html/index.html
```

🧩 **경로 규칙**

* `~` 뒤의 사용자명은 시스템 계정명을 의미.
* 각 사용자의 홈 디렉터리 내에 `public_html` 폴더를 웹 서버가 공개.



**디렉터리 목록 (Directory Index)**

🔹 문제

URI가 **디렉터리 경로**를 가리킬 때, 서버는 어떤 파일을 보여줘야 할까?



🔹 가능한 대응

1. **오류 반환** (403 Forbidden)
2. **index 파일 반환** (`index.html`, `index.htm`, `home.html` 등)
3. **디렉터리 내용 목록을 HTML로 반환** (자동 목록 생성)



📘 **Apache 설정 예시**

```apache
DirectoryIndex index.html index.htm home.html
Options -Indexes   # 디렉터리 목록 표시 비활성화
```

⚠️ **주의**

디렉터리 목록을 켜면 의도치 않게 민감한 파일이 노출될 수 있음.\
보안상 운영 서버에서는 **항상 꺼두는 게 일반적**이다.



**동적 콘텐츠 리소스 매핑**

<figure><img src="../../../../.gitbook/assets/image (394).png" alt=""><figcaption></figcaption></figure>

🔹 개념

웹 서버는 단순히 정적 파일만 제공하는 것이 아니라, **프로그램을 실행해 결과를 반환하는 동적 콘텐츠도 처리**할 수 있다.

> 즉, 요청에 맞게 콘텐츠를 생성> 하는 프로그램에 URI를 매핑하는 것이다



📘 **대표 예시**

| 기술                                     | 설명                         |
| -------------------------------------- | -------------------------- |
| **CGI (Common Gateway Interface)**     | 초기 방식. 요청마다 새 프로세스 생성. 느림. |
| **PHP / JSP / ASP**                    | 요청마다 인터프리터 실행. 템플릿 기반.     |
| **Servlet / Node.js / Spring / Flask** | 서버 내부 프로세스에서 직접 실행. 고성능.   |

📘 **Apache 예시**

```apache
ScriptAlias /cgi-bin/ /usr/local/httpd/cgi-bin/
AddHandler cgi-script .cgi
```

🧠 **즉:**

> `/cgi-bin`으로 시작하는 요청 URI는 서버가 프로그램을 실행시켜 그 결과를 HTML처럼 반환한다.



**서버 사이드 인클루드 (Server-Side Includes, SSI)**

🔹 개념

HTML 문서 안에서 **특정 부분만 동적으로 바꾸는 기능ㅇ**.\
예를 들어, 매번 같은 푸터나 날짜를 자동 삽입할 수 있다.

📘 **예시**

```html
<!--#echo var="DATE_LOCAL" -->
<!--#include file="footer.html" -->
```

서버는 HTML 파일을 전송하기 전에 이런 SSI 구문을 찾아 실제 값(날짜, 외부 파일 등)으로 **치환 후 전송**한다.

🔹 **현대적 대체 기술:**

* JSP의 `<%@ include %>`
* PHP의 `include()`
* React/Next.js의 SSR(Server-Side Rendering)



**접근 제어 (Access Control)**

🔹 개념

웹 서버는 특정 리소스에 접근 권한을 제한할 수 있다.

#### 주요 방식

| 종류                         | 설명                                         |
| -------------------------- | ------------------------------------------ |
| **IP 기반 제어**               | 특정 IP 대역만 접근 허용 (`Allow from 192.168.*.*`) |
| **HTTP 인증 (Basic/Digest)** | ID/비밀번호 입력 후 접근 허용                         |
| **HTTPS + 토큰**             | 현대적 방식 — 세션·JWT·OAuth 등 사용                 |
| **ACL 파일(.htaccess)**      | 경로 단위 접근 제어 설정 (Apache 등)                  |

📘 **Apache 예시**

```apache
<Directory "/var/www/private">
  AuthType Basic
  AuthName "Restricted Area"
  AuthUserFile /etc/httpd/.htpasswd
  Require valid-user
</Directory>
```



**현대 서버(2020s 기준)에서의 확장 개념**

| 전통 개념          | 현대적 대응                   | 설명                                           |
| -------------- | ------------------------ | -------------------------------------------- |
| Docroot        | `webroot` / `public/`    | Express, Flask, Spring Boot 등에서 정적 리소스 폴더 지정 |
| VirtualHost    | NGINX `server {}` 블록     | 도메인 기반 가상 호스팅, SSL 적용                        |
| CGI            | API Gateway / App Server | 프로그램 실행 대신 내부 라우팅으로 처리                       |
| SSI            | SSR / Template Engine    | HTML 렌더링 엔진 (JSP, Handlebars, Thymeleaf 등)   |
| Access Control | JWT / OAuth2 / RBAC      | 토큰 기반 인증과 역할 권한 체계로 발전                       |

> 웹 서버는 URI를 docroot, 가상 호스트, 또는 동적 프로그램에 매핑해 클라이언트에게 정적·동적 리소스를 제공하며, 디렉터리 색인·SSI·접근 제어 등의 기능을 통해 효율성과 보안을 함께 관리한다.



### 5) 응답 만들기 (Generating the Response)

**1️⃣ 기본 개요**

서버는 요청 URI에 해당하는 리소스를 찾은 후, 요청 메서드(`GET`, `POST`, `HEAD` 등)에 맞는 동작을 수행하고 **HTTP 응답(Response)** 을 구성한다.

응답은 세 부분으로 구성된다.

| 구성 요소                 | 설명                                                     |
| --------------------- | ------------------------------------------------------ |
| **상태 줄(Status Line)** | `HTTP/1.1 200 OK` 처럼 요청의 처리 결과를 나타냄                    |
| **응답 헤더(Headers)**    | 응답의 부가 정보 (`Content-Type`, `Content-Length`, `Date` 등) |
| **응답 본문(Body)**       | 요청한 리소스의 실제 데이터 (HTML, 이미지, JSON 등)                    |



**2️⃣ 응답 엔터티 (Response Entity)**

만약 요청 처리 결과로 본문(데이터)이 생성되었다면, 서버는 이 본문을 함께 돌려보낸다.

대표적인 헤더 구성은 다음과 같다.

| 헤더                       | 설명                                                                |
| ------------------------ | ----------------------------------------------------------------- |
| **Content-Type**         | 응답 데이터의 MIME 타입 지정 (`text/html`, `image/png`, `application/json`) |
| **Content-Length**       | 본문 데이터의 크기 (바이트 단위)                                               |
| **Content-Encoding**     | gzip, deflate 등 압축 인코딩 방식                                         |
| **Last-Modified / ETag** | 캐싱을 위한 리소스 버전 정보                                                  |



**3️⃣ MIME 타입 결정하기 (MIME Type Resolution)**

서버는 응답 본문의 `데이터 타입`을 반드시 알아야 한다. 이 정보를 기반으로 브라우저가 데이터를 올바르게 처리하기 때문문



**MIME 타입 결정 방법 4가지**

| 방식                             | 설명                               | 예시                                                |
| ------------------------------ | -------------------------------- | ------------------------------------------------- |
| **① 확장자 기반 (mime.types)**      | 파일 확장자와 MIME 타입 매핑               | `.html → text/html` `.jpg → image/jpeg`           |
| **② 매직 타이핑 (Magic Typing)**    | 파일 내용을 일부 읽어 패턴으로 식별             | PDF 헤더 `%PDF` → `application/pdf`                 |
| **③ 명시적 지정 (Explicit Typing)** | 서버 설정에서 특정 경로·파일의 MIME 지정        | `/downloads/*` → `application/zip`                |
| **④ 유형 협상 (Type Negotiation)** | 클라이언트의 `Accept` 헤더에 맞춰 서버가 타입 결정 | `Accept: text/html, application/json` → 서버가 자동 선택 |

📘 **현대 서버 예시**

* NGINX: `types` 블록으로 MIME 매핑 관리
* Apache: `/etc/mime.types` 파일 사용
* Express.js: `res.type('json')`, `res.setHeader('Content-Type', 'application/json')`



### 6) 리다이렉션 (Redirection)

서버는 단순히 “리소스 없음”을 반환하는 대신, 클라이언트에게 **“다른 위치로 이동하라”**&#xACE0; 지시할 수도 있다.

이때 상태 코드는 `3XX` 계열이 사용된다.

| 상태 코드                      | 의미                     | 사용 상황                |
| -------------------------- | ---------------------- | -------------------- |
| **301 Moved Permanently**  | 리소스가 **영구 이동됨**        | 새 URL로 완전히 이전된 경우    |
| **302 Found**              | 임시 이동 (HTTP/1.0 기본)    | 임시 리소스 위치 변경         |
| **303 See Other**          | 다른 URI로 리다이렉트          | 예: 폼 제출 후 결과 페이지로 이동 |
| **307 Temporary Redirect** | **메서드 유지**하면서 임시 리다이렉트 | POST → POST 유지       |
| **308 Permanent Redirect** | **메서드 유지**하면서 영구 리다이렉트 | HTTP/1.1 확장 버전       |

📘 **리다이렉션 예시**

```
HTTP/1.1 301 Moved Permanently
Location: https://new.example.com/
```

🧠 **현대적 응용**

* URL 정규화 (슬래시 누락 자동 보정 `/docs` → `/docs/`)
* 로드 밸런싱 시 트래픽 분산 (`redirect to less busy node`)
* 로그인 후 특정 페이지 이동 (`/login` → `/dashboard`)



### 7) 응답 보내기 (Sending the Response)

서버는 생성한 응답을 클라이언트로 전송한다.\
이 과정에서도 **커넥션 관리(지속 연결, 파이프라인)** 가 중요

| 구분                   | 설명                                                         |
| -------------------- | ---------------------------------------------------------- |
| **비지속 연결(HTTP/1.0)** | 요청 → 응답 후 연결 종료                                            |
| **지속 연결(HTTP/1.1)**  | 여러 요청을 같은 TCP 연결에서 처리 (`Connection: keep-alive`)           |
| **Chunked 전송 인코딩**   | 응답 크기를 모를 때, 데이터를 조각 단위로 전송 (`Transfer-Encoding: chunked`) |

🧠 **핵심 포인트**

* 지속 커넥션에서는 `Content-Length`가 정확해야 함
* 서버는 동시에 수천 개 커넥션을 관리하므로 **비동기 I/O** 구조 필요
* 현대 서버는 epoll/kqueue 기반으로 응답 스트림을 관리 (NGINX, Node.js 등)



### 7) 로깅 (Logging)

모든 요청-응답 트랜잭션이 끝나면 서버는 트랜잭션의 결과를 **로그 파일**에 기록

⇒ 로그 log-4j나 서버가 데이터 베이스에 기록하기도 하고 이전에는 몽고디비에 기록했다 함 다른 걸로 기록하기도&#x20;

| 항목                       | 예시                                                 |
| ------------------------ | -------------------------------------------------- |
| **시간**                   | 2025-10-17T11:32:05                                |
| **클라이언트 IP**             | 192.168.1.12                                       |
| **요청 라인**                | "GET /index.html HTTP/1.1"                         |
| **상태 코드**                | 200                                                |
| **응답 크기**                | 1234 bytes                                         |
| **Referer / User-Agent** | [https://google.com](https://google.com/) / Chrome |

📘 **Apache 예시**

```
127.0.0.1 - frank [10/Oct/2025:13:55:36 +0900] 
"GET /apache.gif HTTP/1.0" 200 2326
```



🧠 **현대적 로깅 확장**

* **JSON 기반 로그**: ELK(Elastic Stack), Loki, Datadog 등과 연동
* **접근 로그 + 에러 로그 분리**
* **구조화 로깅(Structured Logging)** 으로 실시간 분석 가능
* **분산 트레이싱(OpenTelemetry)** 을 통해 요청 단위 추적



### 8) 전체 요약 – 웹 서버의 7단계 요청 처리 플로우

| 단계               | 설명                     |
| ---------------- | ---------------------- |
| 1️⃣ 클라이언트 커넥션 수락 | TCP 연결 수립              |
| 2️⃣ 요청 메시지 수신    | 요청 파싱 (메서드, URI, 헤더 등) |
| 3️⃣ 요청 해석        | 리소스 매핑, 접근 제어 확인       |
| 4️⃣ 리소스 접근       | 파일 또는 동적 프로그램 실행       |
| 5️⃣ 응답 생성        | 상태 코드 + 헤더 + 본문 구성     |
| 6️⃣ 응답 전송        | 커넥션 관리 + 데이터 전송        |
| 7️⃣ 로깅           | 트랜잭션 결과 기록             |

{% hint style="success" %}
웹 서버는 리소스를 식별한 뒤 MIME 타입과 상태 코드에 맞게 응답 메시지를 생성하고, 필요 시 리다이렉션·압축·지속 연결 등을 처리한 후 로그로 모든 트랜잭션을 남긴다.\
현대 서버들은 이를 비동기 이벤트 기반 아키텍처로 고도화하여 대규모 요청을 효율적으로 처리한다.
{% endhint %}



## 4. 로깅에 대한 이야기

### 1️⃣ 기본 개념 — 로그(Logging)의 역할

웹 서버나 백엔드 애플리케이션은 매 요청마다 다음과 같은 정보를 기록합니다.

| 항목              | 예시                       |
| --------------- | ------------------------ |
| 요청 시간           | 2025-10-17T11:20:53      |
| 요청자 IP          | 192.168.1.12             |
| HTTP 메서드        | GET                      |
| URI             | /api/users/15            |
| 상태 코드           | 200                      |
| 처리 시간           | 123ms                    |
| 사용자 ID / 세션     | user\_abc123             |
| 예외 발생 시 스택 트레이스 | `NullPointerException` 등 |

👉 이런 기록들이 **“서버 로그(server log)”** 또는 **“접근 로그(access log)”**&#xC608;요.\
운영팀·개발팀은 이를 통해 장애, 성능, 공격 시도를 추적합니다.



### 2️⃣ 로그가 기록되는 주요 위치 4가지

| 구분                              | 예시                                         | 설명                                                                  |
| ------------------------------- | ------------------------------------------ | ------------------------------------------------------------------- |
| **① 파일(File-based Logging)**    | `/var/log/app.log`, `log4j.log`            | 가장 일반적. 서버 내부 디스크에 저장. → log4j, logback, Winston, NGINX access\_log |
| **② 데이터베이스(DB Logging)**        | MySQL, PostgreSQL, MongoDB 등               | 로그를 구조화하여 검색 및 분석 가능. → 예: `request_log` 테이블                        |
| **③ 중앙 로깅 서버 (Remote Logging)** | ELK(Elastic Stack), Loki, Graylog, Datadog | 여러 서버의 로그를 한 곳에 모아 관리. → JSON 형태로 전송, 실시간 대시보드                      |
| **④ 클라우드 로깅 서비스**               | AWS CloudWatch, GCP Cloud Logging          | 클라우드 환경에서 자동 수집, 필터링, 알람 설정 가능                                      |

### 3️⃣ log4j / logback / 기타 로깅 프레임워크

| 프레임워크                        | 특징                           | 저장 방식                              |
| ---------------------------- | ---------------------------- | ---------------------------------- |
| **log4j (Apache)**           | 고전적인 Java 로깅 시스템             | 파일, 콘솔, DB, 원격 전송 가능               |
| **logback (Spring Boot 기본)** | log4j 후속 버전, XML 설정 기반       | RollingFileAppender, DBAppender 지원 |
| **SLF4J**                    | 로깅 인터페이스 (log4j/logback을 통합) | 실제 구현체는 logback 등                  |
| **Winston (Node.js)**        | JS 기반 다중 트랜스포트 지원            | 파일, MongoDB, Elasticsearch 등       |
| **NGINX Access/Error Log**   | 웹 서버 자체 로그                   | 파일 기반, JSON 포맷 가능                  |

📘 log4j는 “Appender” 개념으로 **출력 위치를 자유롭게 지정**할 수 있어요.

```xml
<appender name="FILE" class="org.apache.log4j.FileAppender">
    <param name="File" value="/var/log/app.log"/>
</appender>

<appender name="DB" class="org.apache.log4j.jdbc.JDBCAppender">
    <param name="URL" value="jdbc:mysql://localhost:3306/logdb"/>
    <param name="User" value="root"/>
    <param name="Password" value="1234"/>
</appender>
```

➡ 즉, 같은 로그를 **파일 + DB + 콘솔**에 동시에 기록할 수도 있습니다.



### 4️⃣ MongoDB에 로그를 기록했던 이유

시니어가 말한 “예전에 MongoDB에 로그를 기록했다”는 건 이런 구조예요 👇

```plaintext
[Web Server or App] 
     ↓
 [Log4j Appender / Custom Logger]
     ↓
 [MongoDB Collection: app_logs]
```

**✅ MongoDB를 로그 저장소로 쓴 이유**

1. **스키마 유연성** → 로그마다 필드가 다를 수 있음 (예외, API, 사용자 등)
2. **대량 데이터 저장** → 일자별 분할(`app_logs_2025_10_17`) 가능
3. **빠른 검색/필터링** → 인덱스로 특정 조건(에러코드, 유저ID) 빠르게 조회
4. **JSON 기반 구조** → 로그를 그대로 저장 가능 (`{ level, message, timestamp, ... }`)

**⚠️ 하지만 단점도 있었어요**

* 트래픽이 많은 서비스에서는 **쓰기 부하(write load)** 가 큼
* 로그가 너무 많으면 **DB 공간이 급속히 커짐**
* 분석보다 저장에 적합 → 나중에는 **ELK나 Loki로 이관**하는 경우가 많아요.



### 5️⃣ 현대적인 구조 — 로그 파이프라인 예시

```
[Spring App / NGINX / Node.js]
        │
        ▼
 ┌──────────────────────────────┐
 │     log4j / logback / winston│
 │     (파일 + JSON 포맷)       │
 └──────────────────────────────┘
        │
        ▼
 [Filebeat / Fluentd / Vector]
        │
        ▼
 [Elasticsearch / Loki / MongoDB]
        │
        ▼
 [Grafana / Kibana / Datadog 대시보드]
```

즉, 현대 서버는 단순히 “로그 파일”에 쓰는 게 아니라\
&#xNAN;**→ 로그 수집기(Log Collector)** 가 읽어서\
&#xNAN;**→ 중앙 로그 서버로 전송하고, 시각화 툴에서 분석**합니다.



### &#x20;6️⃣ DB 로그 구조 예시 (MySQL 버전)

```sql
CREATE TABLE request_log (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  timestamp DATETIME,
  method VARCHAR(10),
  uri VARCHAR(255),
  status_code INT,
  response_time_ms INT,
  user_id VARCHAR(100),
  ip_address VARCHAR(45),
  message TEXT
);
```

이렇게 하면 쿼리로 로그를 분석할 수 있습니다.

```sql
-- 하루 동안 평균 응답 시간
SELECT AVG(response_time_ms) FROM request_log 
WHERE timestamp >= CURDATE();
```



### 7️⃣ 요약 정리

<figure><img src="../../../../.gitbook/assets/image (395).png" alt=""><figcaption></figcaption></figure>

| 구분           | 설명                    | 예시                                |
| ------------ | --------------------- | --------------------------------- |
| **파일 로그**    | 가장 기본적, 빠르지만 검색 어려움   | log4j, logback, NGINX             |
| **DB 로그**    | 구조화된 저장, 쿼리 분석 가능     | MySQL, MongoDB                    |
| **중앙 로그 서버** | 대규모 분산 환경에서 필수        | ELK, Loki, CloudWatch             |
| **현대적 추세**   | 구조화(JSON) + 수집기 + 시각화 | Logback → Fluentd → Elasticsearch |



> 과거에는 로그를 파일이나 MongoDB에 직접 기록했지만,\
> 현재는 log4j/logback을 통해 JSON 형태로 로그를 남기고,\
> Fluentd나 Filebeat가 이를 중앙 로그 서버(ELK/Loki 등)에 모아\
> 검색, 시각화, 모니터링까지 자동화하는 구조로 발전했습니다.



