# 5장 웹서버

* 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사한다.
* HTTP 통신을 진단해주는 간단한 웹 서버를 `펄(Perl)`로 작성해본다.
* 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지 단계별로 설명한다.

## 1. 다채로운 웹 서버

* 웹 서버는 HTTP 요청을 처리하고 응답을 제공한다.&#x20;
* `웹 서버`는 웹 서버  &#x20;소프트웨어와 웹페이지 제공에 특화된 장비(컴퓨터와 같은) 양쪽 모두를 가리킨다.
* 모든 웹 서버는 리소스에 대한 HTTP 요청을  &#x20;받아서 콘텐츠를 클라이언트에게 돌려준다.

### 1) 웹 서버 구현

{% hint style="warning" %}
웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.&#x20;
{% endhint %}

* 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능  \
  을 제공한다.
* 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.
  * 운영체제 : 컴퓨터 시스템의 하드웨어를 관리하고 TCP/IP 네트워크 지원, 웹 리소    \
    스를 유지하기 위한 파일 시스템, 현재 연산 활동을 제어하기 위한 프로세스 관리    \
    를 제공

### 2) 다목적 소프트웨어 웹 서버

{% hint style="warning" %}
다목적 소프트웨어 웹 서버는 **네트워크에 연결된 표준 컴퓨터 시스템**에서 동작한다.
{% endhint %}

* 오픈 소스 소프트웨어 : 아파치, W3C
* 상용 소프트웨어 : 마이크  로소프트, 아이플래닛의 웹 서버&#x20;

> 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작

넷크래프트의 자동화된 조사에 의해 추정된 웹 시장 점유율의 경우, 책은 너무 오래돼서 찾아봄

<figure><img src="../../../../.gitbook/assets/image (6).png" alt=""><figcaption><p><a href="https://velog.io/@secuwave/NGINX%EC%9D%98-%EC%84%B8%EA%B3%84%EC%A0%81%EC%9D%B8-%EC%A0%90%EC%9C%A0%EC%9C%A8%EA%B3%BC-%EA%B7%B8-%EC%9D%B4%EC%9C%A0">https://velog.io/@secuwave/NGINX%EC%9D%98-%EC%84%B8%EA%B3%84%EC%A0%81%EC%9D%B8-%EC%A0%90%EC%9C%A0%EC%9C%A8%EA%B3%BC-%EA%B7%B8-%EC%9D%B4%EC%9C%A0</a></p></figcaption></figure>

> 현재 NGINX는 월드와이드웹을 지탱하는 주요 웹 서버로 자리매김하고 있다.>

Netcraft의 최신 통계에 따르면, NGINX는 전 세계 웹 서버의 **약 33%를 차지하고 있다.**\
아파치 HTTP 서버(27%)와 비교할 때, NGINX는 압도적인 시장 점유율을 보이고 있으며,\
이는 그 유연성과 성능 때문이다.

**1️⃣ 웹 서버 시장 점유율**

* **NGINX**는 현재 전 세계 웹 서버의 약 **33%**&#xB97C; 차지하며,\
  `Apache HTTP Server(27%)`를 앞지르고 있음.
* 이러한 시장 지배력은 **유연한 아키텍처와 높은 성능** 덕분임.
* NGINX는 정적 리소스 처리뿐 아니라 **프록시 서버, 로드 밸런서, 리버스 프록시** 등\
  다양한 역할을 수행할 수 있는 다목적 서버로 자리잡음.

**2️⃣ 클라우드 환경에서의 활용**

* **AWS, Azure, GCP** 등 주요 클라우드 플랫폼에서 기본적으로 지원.
* `가용성(availability)`과 `확장성(scalability)`이 뛰어나\
  **클라우드 네이티브 아키텍처**에 적합함.
* 특히 **Kubernetes** 환경에서 **Ingress Controller**로 널리 사용됨.\
  → 모던 애플리케이션 배포에 최적화되어 있음.

**3️⃣ 트래픽 관리 및 성능**

* NGINX는 **효율적인 로드 밸런싱** 기능을 통해 대규모 트래픽을 분산 처리함.
* 이를 통해 **대형 웹사이트의 안정성 향상** 및 **응답 속도 개선** 가능.
* 실제로 **대형 인터넷 기업**들이\
  서버 자원 효율성 및 사용자 경험 개선을 위해 NGINX를 도입함.

**⚙️ NGINX 선택 이유 요약**

| 구분                              | 설명                                                     |
| ------------------------------- | ------------------------------------------------------ |
| **성능 (Performance)**            | 경량 구조로 빠른 처리 속도 제공. 정적 파일 서빙, 리버스 프록시, 로드 밸런싱 등 다기능 지원 |
| **유연성 (Flexibility)**           | 다양한 모듈 및 설정 옵션으로 상황에 맞는 커스터마이징 가능                      |
| **비용 효율성 (Cost Efficiency)**    | 무료 오픈소스 제공 + 유료 버전 없이도 고급 기능 활용 가능                     |
| **커뮤니티 지원 (Community Support)** | 활발한 커뮤니티와 지속적인 업데이트로 안정적 생태계 형성                        |

**🧩 결론**

* NGINX는 **웹 서버 + 프록시 서버**로서 현대 웹 인프라의 핵심 구성요소임.
* 높은 성능, 확장성, 유연성을 바탕으로 **클라우드 및 컨테이너 시대의 표준 서버**로 자리함.
* 앞으로도 **웹 기술 발전의 주요 동력**으로 지속적인 성장과 발전이 기대됨.



### 3) 임베디드 웹 서버

임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버\
이다(예: 프린터나 가전제품)



## 2. 최소 기능 펄(Perl) 웹 서버: `type-o-serve`&#x20;

### 1️)  개요

HTTP/1.1을 완전히 지원하는 서버는 **가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 성능 최적화 기능** 등 다양한 요소가 필요하죠.

> 하지만 “HTTP가 어떻게 작동하는지”를 이해하기 위한 최소 기능 서버는 단 **30줄 미만의 Perl 코드**로도 충분히 만들 수 있다.

그 대표적인 예가 바로 **`type-o-serve`**&#x20;

이 유틸리티는 **HTTP 요청과 응답의 상호작용을 실험하고 디버깅하는 간단한 도구**로, 클라이언트(예: 브라우저)와 프록시의 요청이 어떻게 오가는지를 직접 눈으로 확인할 수 있게 해준다.

### 2️)  `type-o-serve`의 동작 방식

<figure><img src="../../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

| 단계                | 동작 내용                                      |
| ----------------- | ------------------------------------------ |
| **1. 포트 설정**      | 기본 포트는 **8080**, 명령줄에서 다른 포트 지정 가능         |
| **2. 소켓 생성 및 대기** | TCP 소켓을 열고 클라이언트의 연결을 기다림 (`listen()`)     |
| **3. 연결 수락**      | 브라우저나 클라이언트가 접속하면 연결 수락 (`accept()`)       |
| **4. 요청 수신 및 출력** | 클라이언트가 보낸 **HTTP 요청 메시지**를 한 줄씩 화면에 출력     |
| **5. 응답 입력 대기**   | 서버 운영자가 응답 내용을 직접 콘솔에 입력 (마침표 `.` 한 줄로 종료) |
| **6. 응답 전송**      | 입력된 내용을 **HTTP 응답 메시지** 형식으로 클라이언트에게 전송    |
| **7. 연결 종료**      | `close()`로 세션 종료, 다시 다음 요청을 기다림            |

종 더 자세한 이미지지

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>



### 3️) 예제 코드&#x20;

```perl
#!/usr/bin/perl
use Socket;
use FileHandle;

# (1) 포트 설정 (기본값 8080)
$port = ($ARGV[0]) ? $ARGV[0] : 8080;
$proto = getprotobyname('tcp');

# (2) 소켓 생성 및 바인딩
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;
printf("<<Type-o-Serve Accepting on Port %d>>\n", $port);

while (1) {
    # (3) 연결 수락
    $cport_caddr = accept(C, S);
    ($cport, $caddr) = sockaddr_in($cport_caddr);
    $C->autoflush(1);

    # (4) 요청 출력
    $cname = gethostbyaddr($caddr, AF_INET);
    printf("<<<Request From %s>>>\n", $cname);
    while ($line = <C>) {
        print $line;
        last if $line =~ /^\r/;  # 빈 줄이면 요청 끝
    }

    # (5) 응답 입력 및 전송
    printf("<<<Type response followed by '.'>>>\n");
    while ($line = <STDIN>) {
        chomp($line);
        last if $line eq ".";
        print C $line . "\r\n";
    }

    close(C);
}
```

### 4️) 실제 동작 예시

**실행**

```bash
perl type-o-serve.pl 8080
```

**브라우저에서 요청**

```
http://www.joes-hardware.com:8080/foo/bar
```

**서버 콘솔 출력 예시**

```
<<Type-o-Serve Accepting on Port 8080>>
<<<Request From home-44-027.extranet.inktomi.com>>>
GET /foo/bar HTTP/1.0
Host: www.joes-hardware.com:8080
User-Agent: Mozilla/4.0
Connection: Keep-Alive

<<<Type response followed by '.'>>>
```

여기서 관리자는 응답을 직접 입력한다.



**입력**

```
HTTP/1.0 200 OK
Connection: close
Content-type: text/plain

Hi there!
.
```

→ 클라이언트는 이 응답을 받아 브라우저 화면에 “Hi there!” 출력.



### 5️) 부가 설명: 왜 중요한가?

| 개념                   | 설명                                                         |
| -------------------- | ---------------------------------------------------------- |
| **HTTP 요청/응답 구조 실습** | 브라우저가 어떤 형태로 요청을 보내고, 서버가 어떻게 응답하는지를 직접 눈으로 확인 가능          |
| **디버깅용 테스트 서버**      | 프록시, 방화벽, 클라이언트 라이브러리 등을 실험할 때 매우 유용                       |
| **학습 목적**            | HTTP 헤더의 구조, CRLF(`\r\n`) 구분, 연결 종료 시점 등 프로토콜 기본기를 이해하기 좋음 |
| **경량 서버 구조 이해**      | 실제 상용 웹 서버(NGINX, Apache)가 내부적으로 하는 일을 단순화해 보여줌            |

### &#x20;6) 핵심 요약

| 항목        | 내용                           |
| --------- | ---------------------------- |
| **서버 이름** | `type-o-serve`               |
| **언어**    | Perl                         |
| **기능**    | HTTP 요청을 받아 출력, 직접 응답 타이핑 가능 |
| **용도**    | HTTP 디버깅, 학습, 테스트            |
| **특징**    | 30줄 이하의 초간단 HTTP 서버          |

{% hint style="success" %}
**“type-o-serve”는 단 30줄짜리 Perl 코드로, HTTP 요청과 응답의 원리를 눈으로 확인할 수 있는 초간단 진단 서버다.**
{% endhint %}

## 3. 진짜 웹 서버가 하는 일

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

아래 사진은 좀 더 나아가.. 모던 웹 어플리케이션 아키텍처임

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption><p><a href="https://blog.rhostem.com/posts/2018-07-22-web-architecture-101">https://blog.rhostem.com/posts/2018-07-22-web-architecture-101</a></p></figcaption></figure>

### 1) 클라이언트 커넥션 수락 단계&#x20;

**1️⃣ 개요 — “서버는 어떻게 연결을 받아들이는가?”**

클라이언트가 서버에 HTTP 요청을 보내려면, 먼저 **TCP 커넥션(connection)** 을 열어야 한다.

* 이미 **지속 커넥션(persistent connection)** 이 열려 있다면 → 그대로 재사용 가능.
* 그렇지 않다면 → 새로운 TCP 연결을 만들어야 함.

> 즉, 웹 서버의 첫 번째 역할은 **클라이언트의 커넥션 요청을 수락(Accept)** 하는 것이다.



**2️⃣ 단계별 작동 흐름**

| 단계                | 설명                                            |
| ----------------- | --------------------------------------------- |
| **① 클라이언트 요청 수신** | 클라이언트가 서버에 TCP 연결을 요청 (3-way handshake)       |
| **② 커넥션 수락 및 등록** | 서버가 연결을 허용하고, 내부 커넥션 목록(connection table)에 추가 |
| **③ 클라이언트 식별**    | IP 주소나 호스트명(DNS 역방향 조회)으로 클라이언트를 식별           |
| **④ 필요 시 인증/차단**  | 비인가 IP, 악의적 접근 등은 즉시 커넥션을 닫을 수 있음             |
| **⑤ 데이터 처리 준비**   | 요청 메시지를 읽고 응답을 돌려줄 준비 완료                      |



**3️⃣ 세부 개념별 설명**

&#x20;(1) 새 커넥션 다루기

* TCP 커넥션 요청이 들어오면, 서버는 커넥션을 “수락(accept)”하고 **상대의 IP 주소를 추출**함.
* 이 IP 주소는 로그, 접근 제어, 통계 등에 사용됨.
* 운영체제마다 다르지만, 유닉스 환경에서는 TCP 커넥션이 **소켓(Socket)** 으로 표현됨.
  * 예: `getpeername()` 호출로 클라이언트 IP 획득
* 서버는 특정 조건(IP 차단, 접근 정책 등)에 따라 **커넥션을 거부하거나 즉시 종료**할 수 있음.

{% hint style="success" %}
“모든 요청을 다 받아주는 것이 아니라, 신뢰할 수 있는 연결만 유지한다.”
{% endhint %}



(2) 클라이언트 호스트명 식별 (Reverse DNS Lookup)

* 대부분의 웹 서버는 클라이언트 IP를 **역방향 DNS(Reverse DNS)** 로 변환해 도메인 형태의 **호스트 이름(hostname)** 을 얻는다.&#x20;
  * Reverse DNS는 “IP → 도메인 이름” 변환, RARP는 “MAC → IP 주소” 변환
* 예: `203.255.255.10` → `user.isp.co.kr`
* 이 정보는 다음 용도로 활용된다.
  * 🔸 접근 제어 (특정 도메인만 허용/차단)
  * 🔸 로깅 및 통계
  * 🔸 트래픽 분석

**주의점:**

* 호스트 이름 조회는 시간이 오래 걸림 → 트랜잭션 지연 가능
* 대규모 서버는 성능 저하 방지를 위해 보통 “비활성화”함.



**Apache 예시 설정:**

```apache
# 기본적으로 비활성화
HostnameLookups off

# HTML, CGI 파일 요청에 대해서만 활성화
<Files ~ "\.(html|cgi)$">
  HostnameLookups on
</Files>
```



(3) ident 프로토콜을 통한 사용자 식별

**개념:**

* IETF의 **ident 프로토콜(RFC 1413)** 은 TCP 연결을 연 사용자의 **로컬 사용자명(username)** 을 알아내는 프로토콜
* 서버가 클라이언트의 identd 서버 포트(113) 로 연결하여 “이 HTTP 요청을 보낸 사용자가 누구인지”를 질의한다.



**동작 흐름**

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

| 단계  | 설명                                       |
| --- | ---------------------------------------- |
| (a) | 클라이언트(메리)가 HTTP 커넥션을 염 (예: 4236 → 80 포트) |
| (b) | 서버는 클라이언트의 identd(113 포트)에 별도 커넥션 생성     |
| (c) | 서버 → ident 요청 전송: `4236,80`              |
| (d) | 클라이언트 → ident 응답: `USERID:UNIX:mary`     |

{% hint style="warning" %}
서버는 “이 포트를 연 사용자가 누구냐?”를 ident 프로토콜로 물어보는 것.
{% endhint %}



**4️⃣ ident 프로토콜의 문제점**

| 한계              | 설명                                   |
| --------------- | ------------------------------------ |
| ❌ **보편성 낮음**    | 대부분의 PC는 ident 데몬(`identd`)을 실행하지 않음 |
| ❌ **속도 저하**     | 추가적인 TCP 연결로 HTTP 트랜잭션 지연            |
| ❌ **보안 문제**     | 응답 위조 가능, 신원 조작 쉬움                   |
| ❌ **방화벽 차단**    | 기업·기관망에서 113 포트가 차단되는 경우 많음          |
| ❌ **가상 IP 미지원** | NAT 환경에서는 정확한 사용자 식별 불가              |
| ❌ **개인정보 문제**   | 사용자 계정 노출로 인한 프라이버시 침해 우려            |

📌 **따라서:**

→ 현대의 웹 환경에서는 거의 사용되지 않습니다.

→ Apache에서도 `IdentityCheck on` 설정으로 켤 수 있지만, 대부분 비활성화(default off) 상태입니다.

**Apache 설정 예:**

```apache
IdentityCheck on
```

* ident 결과가 없으면 로그의 해당 필드는 `-` (하이픈)으로 표시됨.
* 일반 로그 포맷(Common Log Format)의 두 번째 필드가 바로 이 값임.



예시 로그:

```
192.168.0.5 - frank [10/Oct/2025:13:55:36 +0900] "GET /index.html HTTP/1.1" 200 2326
```

→ 여기서 두 번째 `-` 가 ident 필드.



**5️⃣ 요약 정리**

| 항목        | 내용                                     |
| --------- | -------------------------------------- |
| **단계명**   | 클라이언트 커넥션 수락                           |
| **핵심 역할** | TCP 커넥션을 받아들이고, 클라이언트 식별 및 관리          |
| **주요 기능** | ① 새 커넥션 수락 ② 호스트명 확인 ③ 사용자 식별 (ident)  |
| **보안 고려** | IP/호스트 기반 접근 제어, 악의적 요청 차단             |
| **성능 고려** | DNS Lookup 및 ident는 지연 발생 → 일반적으로 비활성화 |

**부가 해설 — 현대적 맥락에서의 이해**

| 항목             | 과거               | 현재                        |
| -------------- | ---------------- | ------------------------- |
| **커넥션 처리**     | 단일 프로세스가 요청마다 처리 | 이벤트 기반 (NGINX, Node.js 등) |
| **DNS Lookup** | 요청 시마다 수행        | CDN·Proxy 단에서 캐시 처리       |
| **사용자 식별**     | ident, IP 기반     | 토큰 기반(OAuth, JWT), 쿠키 인증  |
| **보안**         | 단순 IP 차단         | WAF, SSL 인증서, 방화벽 규칙 등    |

{% hint style="success" %}
🔍 즉, 지금의 웹 서버들은 “연결 수락” 자체를 **논블로킹(비동기 I/O)** + **보안 계층(TLS)** + **프록시 계층(LB)** 으로 분리하여 처리한다. 이거에 대한 설명
{% endhint %}

<figure><img src="../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

> **HTTP 서버는 클라이언트의 요청을 수락하면서 IP·호스트·사용자 정보를 식별하지만, 성능과 보안을 위해 대부분의 식별 기능(DNS·ident)은 제한적으로 사용된다.**

