---
description: HTTP 메시지의 모든 것(어떻게 메시지를 만들고 이해하는지)에 대해 말해준다.
---

# 3장 HTTP 메세지

## 1. 메시지의 흐름

* **HTTP 메시지**: 클라이언트, 서버, 프락시 사이 즉, **애플리케이션  사이에서 주고받는 데이터 블록.**
  * 이 데이터 블록들은 메시지의 내용과 의미를 설명하는 **텍스트 메타 정보로 시작**하고 **그 다음에 선택적으로 데이터가 올 수 있다.**

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption><p><a href="https://velog.io/@hogu8159/3.HTTP-%EB%A9%94%EC%84%B8%EC%A7%80">https://velog.io/@hogu8159/3.HTTP-%EB%A9%94%EC%84%B8%EC%A7%80</a></p></figcaption></figure>

* 메시지는 항상 **원 서버 → 클라이언트 방향**으로 이동하며, 다음과 같은 용어로 방향성을 설명함:
  * **인바운드 (Inbound)**: 원 서버로 향하는 메시지 (예: 클라이언트 → 서버의 요청).
  * **아웃바운드 (Outbound)**: 사용자 에이전트(클라이언트)로 되돌아가는 메시지 (서버 → 클라이언트의 응답).
  * **업스트림 (Upstream)**: 메시지를 보내는 쪽.
  * **다운스트림 (Downstream)**: 메시지를 받는 쪽.

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="danger" %}
→ 요청/응답 구분 없이 **모든 메시지는 다운스트림으로 흐른다.**
{% endhint %}

&#x20;**📡 "모든 메시지는 다운스트림으로 흐른다"의 의미**

HTTP 메시지를 강물처럼 생각하면 이해하기 쉽다.

* 강물은 항상 한 방향으로 흐르듯,
* **HTTP 메시지도 “보내는 쪽 → 받는 쪽” 방향으로만 흐른다**는 것이다.

여기서 중요한 건, **요청이든 응답이든 상관없이** “수신자 입장에서는 다운스트림”이라는 사실이다.

**🔼 업스트림 / 🔽 다운스트림**

* **업스트림 (Upstream)**: 메시지를 **보내는 쪽** (발송자).
* **다운스트림 (Downstream)**: 메시지를 **받는 쪽** (수신자).

> 즉, “누가 누구한테 메시지를 보내냐”에 따라 달라지는 상대적인 개념

**예시: 프락시(Proxy) 체인**

```
클라이언트 → 프락시1 → 프락시2 → 프락시3 → 원 서버
```

1. 요청(Request) 메시지의 경우

* 클라이언트가 `/index.html` 요청을 보냄.
* 이 메시지는 계속 서버 쪽으로 흘러감
* 따라서 **프락시1은 프락시3의 업스트림** (보내는 쪽),\
  프락시3은 프락시1의 다운스트림 (받는 쪽).

2. 응답(Response) 메시지의 경우

* 원 서버가 `200 OK` 응답을 보냄.
* 이 메시지는 반대로 클라이언트 쪽으로 흘러가죠.
* 이때는 **프락시3이 응답을 받아서 프락시1 쪽으로 내려보내므로**,\
  응답에서는 **프락시3이 프락시1의 업스트림**이 되고,\
  프락시1은 다운스트림이 됨.



**핵심 정리**

* **모든 HTTP 메시지는 다운스트림으로 흐른다.**
  * 요청: 클라이언트 → 서버 방향으로 다운스트림.
  * 응답: 서버 → 클라이언트 방향으로 다운스트림.
* 업스트림/다운스트림은 절대적인 방향이 아니라 **발송자와 수신자의 관계**에 따라 정해진다.

> 👉 즉, "업스트림/다운스트림"은 **위에서 아래로 흐르는 데이터의 물줄기 같은 개념**이다.\
> 서버든 클라이언트든, 그 순간 메시지를 받는 쪽은 항상 **다운스트림**이 되는 것



***

## 2. HTTP 메시지 구조 (3가지 구성 요소)

HTTP 메시지는 크게 **시작줄(Start Line) + 헤더(Header) + 본문(Body)** 로 구성된다.

{% hint style="success" %}
**시작줄**은 <mark style="color:red;">**이것이 어떤 메시지인지 서술**</mark>하며 **헤더 블록**은 <mark style="color:red;">**속성**</mark>을 **본문**은 <mark style="color:red;">**데이터**</mark>를 담고\
있다. 본문은 아예 없을 수도 있다
{% endhint %}

### 1) 시작줄 (Start Line)

* **요청 메시지**: `메서드(Method) + 요청 URL + HTTP 버전`
  * 예) `GET /index.html HTTP/1.1`
* **응답 메시지**: `HTTP 버전 + 상태 코드(Status Code) + 사유 구절(Reason-Phrase)`
  * 예) `HTTP/1.1 200 OK`

### 2) 헤더 (Headers)

> 시작과 헤더는 그냥 줄 단위로 분리된 아스키 문자열

* 이름:값 형태의 메타데이터 집합.
* 종류:
  * **일반 헤더**: 요청/응답 모두 사용 (예: `Date`)
  * **요청 헤더**: 클라이언트가 서버에 전달하는 부가정보 (예: `Accept`, `Host`)
  * **응답 헤더**: 서버가 클라이언트에 제공하는 부가정보 (예: `Server`)
  * **엔터티 헤더**: 본문 데이터에 대한 정보 (예: `Content-Length`, `Content-Type`)
* 헤더는 반드시 **빈 줄(CRLF)** 로 끝나며, 이후 본문이 시작됨.

### 3) 엔터티 본문 (Body)

* 실제 데이터(payload)를 담음.
* HTML, JSON, 이미지, 비디오 등 다양한 형태 가능.
* 모든 메시지가 본문을 가지는 것은 아님 (예: `GET` 요청은 보통 없음).

***

## 3. HTTP 메시지 문법 정리

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption><p><a href="https://velog.io/@twomanyzero/01.-%EC%9B%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%9D%B4%ED%95%B43">https://velog.io/@twomanyzero/01.-%EC%9B%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EC%9D%B4%ED%95%B43</a></p></figcaption></figure>

### 1) HTTP 메시지의 종류

* **요청 메시지(Request)**: 클라이언트가 서버에게 어떤 동작을 요구.
* **응답 메시지(Response)**: 서버가 요청 결과를 클라이언트에게 반환.

### 2) 메시지 기본 구조

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

> 이 그림은 **HTTP 트랜잭션(요청과 응답)**&#xC774; 실제로 어떻게 이루어지는지를 보여주는 예시

1️⃣ 왼쪽: 클라이언트(웹 브라우저)

* 사용자가 웹 브라우저에서 `www.joes-hardware.com` 서버에 있는 `/specials/saw-blade.gif` 파일을 요청했다고 가정.
*   브라우저가 서버로 보낸 **HTTP 요청 메시지**는 다음과 같음:

    ```
    GET /specials/saw-blade.gif HTTP/1.0
    Host: www.joes-hardware.com
    ```

    * **GET** → 서버에 리소스를 달라는 요청 메서드.
    * **/specials/saw-blade.gif** → 요청하는 파일의 경로.
    * **HTTP/1.0** → 사용하는 프로토콜 버전.
    * **Host** 헤더 → 어느 서버(호스트)인지 지정.



2️⃣ 가운데: 인터넷(네트워크 전송)

* 요청은 인터넷을 통해 원 서버(`www.joes-hardware.com`)로 전달됨.
* 서버가 요청을 처리한 뒤 응답 메시지를 다시 인터넷을 거쳐 클라이언트로 돌려보냄.



3️⃣ 오른쪽: 서버

* 서버는 요청받은 파일 `saw-blade.gif`를 찾음.
*   찾은 후 클라이언트에게 **HTTP 응답 메시지**를 보냄:

    ```
    HTTP/1.0 200 OK
    Content-Type: image/gif
    Content-Length: 8572
    ```

    * **HTTP/1.0** → 응답도 같은 프로토콜 버전 사용.
    * **200 OK** → 요청이 성공적으로 처리되었음을 나타내는 상태 코드.
    * **Content-Type: image/gif** → 응답 본문이 GIF 이미지라는 정보.
    * **Content-Length: 8572** → 응답 본문의 크기(바이트 단위).
    * 그리고 실제 데이터(바이너리 GIF 파일)가 본문에 포함됨.

4️⃣ 결과

* 클라이언트(브라우저)는 응답 본문을 받아서 화면에 `saw-blade.gif` 이미지를 표시할 수 있게 됨.
* 따라서 그림은 **요청(Request) → 서버 처리 → 응답(Response)** 의 전형적인 HTTP 메시지 흐름을 나타냄.



✅ **정리**

* **왼쪽(요청)**: 클라이언트가 서버에 “이 파일 주세요!”라고 요청.
* **오른쪽(응답)**: 서버가 “여기 있습니다. GIF 이미지고 크기는 8572바이트예요” 하고 응답.

> 이 한 사이클이 바로 **HTTP 트랜잭션**

**🍕 HTTP 트랜잭션 = 피자 주문 과정**

<figure><img src="../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

1. **클라이언트 → 주문 넣기 (HTTP 요청)**

* **클라이언트(웹 브라우저)** = 배고픈 손님
*   손님이 피자집(서버)에 전화해서 말해요:

    ```
    GET /specials/pepperoni-pizza HTTP/1.0
    Host: www.pizza-shop.com
    ```

    👉 "저 [www.pizza-shop.com에서](http://www.pizza-shop.xn--com-k94n91q/) 페퍼로니 피자 하나 주문이요!"

여기서:

* `GET` = "주문합니다!"
* `/specials/pepperoni-pizza` = "페퍼로니 피자 메뉴"
* `Host` = "이 주문은 피자샵 본점에 하는 거예요"
* `HTTP/1.0` = "제가 주문할 때 쓰는 프로토콜 버전(말투)"



2. &#x20;**인터넷 → 주문 전달**

* 전화망(= 인터넷)을 통해 피자집에 주문이 전달돼요.
* 이게 바로 **요청 메시지(Request Message)**.



3. **서버(피자집) → 주문 확인 & 피자 굽기**

* 피자집(서버)이 주문서를 확인하고 피자를 굽기 시작합니다.
* 다 구운 뒤 배달 상자에 넣고, 배달원에게 넘기죠.

이때 배달 상자 안에는 \*\*응답 메시지(Response Message)\*\*가 들어있어요:

```
HTTP/1.0 200 OK
Content-Type: pizza/pepperoni
Content-Length: 8572
```

👉 해석하면:

* `200 OK` = "주문 잘 받았고, 피자 다 구워서 문제 없이 준비됐습니다!"
* `Content-Type: pizza/pepperoni` = "안에 들어 있는 건 페퍼로니 피자예요"
* `Content-Length: 8572` = "피자의 크기는 이 정도예요 (8,572바이트)"



4. &#x20;클라이언트(손님) → 응답 받기

* 손님(브라우저)은 배달 온 피자를 받아서 박스를 열고 맛있게 먹습니다.
* 웹 브라우저는 응답 본문에 들어 있던 **GIF 이미지(피자)**&#xB97C; 꺼내 화면에 띄우는 거죠.



핵심

* **요청(Request) = 손님이 피자 주문 넣기**
* **응답(Response) = 피자집이 피자를 배달하기**
* **HTTP 트랜잭션 = 주문 \~ 배달까지의 한 사이클**



#### 요청 메시지

```
<메서드> <요청 URL> <버전>
<헤더>
<엔터티 본문>
```

#### 응답 메시지

```
<버전> <상태 코드> <사유 구절>
<헤더>
<엔터티 본문>
```

***

### 3. 주요 구성 요소

#### (1) 메서드 (Method)

* 서버에게 어떤 동작을 할지 지정.
*   대표적인 메서드:

    | 메서드     | 설명              | 본문 |
    | ------- | --------------- | -- |
    | GET     | 서버에서 문서 가져오기    | 없음 |
    | HEAD    | 문서의 헤더만 가져오기    | 없음 |
    | POST    | 서버가 처리할 데이터 전송  | 있음 |
    | PUT     | 서버에 데이터 저장      | 있음 |
    | DELETE  | 문서 삭제           | 없음 |
    | OPTIONS | 서버가 지원하는 메서드 확인 | 없음 |
    | TRACE   | 메시지 경로 추적       | 없음 |

※ 모든 서버가 모든 메서드를 구현하지는 않음. 필요에 따라 확장 메서드 존재.

***

#### (2) 요청 URL

* 요청 대상 리소스를 지칭하는 URL 또는 경로.
* 절대 경로 형태만 맞다면 서버는 자신의 호스트/포트로 간주.

***

#### (3) 버전 (Version)

* `HTTP/<메이저>.<마이너>` 형식.
* 예: `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`.
* 숫자는 분리해서 비교해야 함 → `HTTP/2.22` > `HTTP/2.3`.

***

#### (4) 상태 코드 (Status Code)

* 응답의 결과를 나타내는 3자리 숫자.
*   범위별 의미:

    | 범위      | 의미       | 예시                        |
    | ------- | -------- | ------------------------- |
    | 100–199 | 정보       | 100 Continue              |
    | 200–299 | 성공       | 200 OK                    |
    | 300–399 | 리다이렉션    | 301 Moved Permanently     |
    | 400–499 | 클라이언트 오류 | 404 Not Found             |
    | 500–599 | 서버 오류    | 500 Internal Server Error |

***

#### (5) 사유 구절 (Reason Phrase)

* 상태 코드에 대한 사람이 읽기 쉬운 설명.
* 예: `HTTP/1.0 200 OK` → 상태코드=200, 사유구절=OK.
* 기계적 의미는 숫자가 담당, 문구는 참고용.

***

#### (6) 헤더 (Header)

* 이름:값 형식의 메타데이터.
* 종류:
  * **일반 헤더**: 요청/응답 모두 사용 가능.
  * **요청 헤더**: 요청 관련 부가정보 (예: `Accept`, `Host`).
  * **응답 헤더**: 응답 관련 부가정보 (예: `Server`).
  * **엔터티 헤더**: 본문 데이터 설명 (`Content-Length`, `Content-Type`).
  * **확장 헤더**: 표준 외의 추가 헤더.
*   예시:

    ```
    Date: Tue, 3 Oct 1997 02:16:03 GMT
    Content-Length: 15040
    Content-Type: image/gif
    Accept: image/gif, image/jpeg, text/html
    ```

***

#### (7) 엔터티 본문 (Entity Body)

* 실제 전송되는 데이터(payload).
* HTML, JSON, 이미지, 비디오 등 다양.
* 모든 메시지가 본문을 갖는 것은 아님.

***

### 4. HTTP/0.9 (초기 버전)

* 요청: `GET /file`
* 응답: 엔터티 본문만 반환.
* 버전 정보, 상태 코드, 헤더 없음.
* 너무 단순해 현대 웹 환경에 맞지 않음.

***

## ✅ 핵심 요약

1. HTTP 메시지는 **요청**과 **응답**으로 나뉨.
2. 구조는 `시작줄 + 헤더 + 본문`.
3. 메서드는 `GET`, `POST`, `PUT` 등으로 동작 정의.
4. 상태 코드는 3자리 숫자로 결과 의미 전달.
5. 헤더는 메타데이터, 본문은 실제 데이터.
6. 초기 HTTP/0.9는 단순했으나 현재는 더 복잡한 구조로 발전.
