# 4장 커넥션 관리

{% hint style="success" %}
Key Point
{% endhint %}

* Http는 어떻게 TCP 커넥션을 사용하는가?
* TCP 커넥션의 지연, 병목, 막힘
* 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
* 커넥션 관리를 위해 따라야 할 규칙들



## TCP 커넥션

> 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.

### 1. 패킷 교환 네트워크 프로토콜이란?

{% hint style="success" %}
패킷 교환 네트워크 프로토콜은 데이터를 일정 크기의 작은 단위인 '패킷(Packet)'으로 분할해서, 각 **패킷이 네트워크를 통해 개별적으로 전송되는 방식을 따르는 통신 방법에서 사용하는 규약**이다.
{% endhint %}

#### 1) 패킷 교환 네트워크의 구조와 동작 원리

* 데이터를 송신 측에서 패킷으로 분할한다.
* 각 패킷에는 목적지 주소 등 제어 정보가 담긴 헤더가 붙는다.
* 패킷들은 서로 다른 경로로 독립적으로 전달될 수 있다.
* 수신 측에서는 패킷을 원래의 데이터로 재조립한다.

#### 2) 대표적인 패킷 교환 네트워크 프로토콜

* IP(Internet Protocol): 패킷의 전달 경로 지정과 목표지 주소 부여 등, 가장 근본적인 패킷 처리 규약.
* TCP(Transmission Control Protocol): 신뢰성 보장(데이터의 순서, 오류 검출 및 재전송 등)을 담당하며, IP 위에서 동작하는 상위 계층 프로토콜.
* UDP(User Datagram Protocol): 오류 제어나 순서 보장은 하지 않고 빠른 전송을 중시하는 비연결형 프로토콜.
* X.25: 전화망 기반 공중 데이터 교환망에서 사용된 초기 패킷 교환 프로토콜.

#### 3) 패킷 교환 프로토콜의 주요 특징

* 네트워크 자원을 효율적으로 공유할 수 있다.
* 대역폭을 여러 사용자가 효율적으로 나눠쓰기 적합하다.
* 장애 시 다른 경로로 **우회가 가능해 신뢰성이 높다.**
* 오늘날의 인터넷, 사설망(LAN/WAN) 등 거의 모든 컴퓨터 네트워크에서 표준으로 사용된다

> 즉, 패킷 교환 네트워크 프로토콜은 인터넷과 같은 네트워크에서 데이터를 쪼개어 전송·전달하고 재조합하는 규칙(대표적으로 TCP, IP, UDP, X.25 등)을 의미한다는 점이 핵심이다.

### 2. 커넥션이 맺어지고 난 후

#### 1)  3방향 핸드셰이크와 4방향 핸드셰이크

일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받은 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

1. 브라우저가 www.joes-hardware.com라는   &#x20;호스트 명을 추출한다.
2. 브라우저가 이 호스트 명에 대한 IP 주소를 찾는다.&#x20;
3. 브라우저가 포트 번호(80)을 얻는다.
4. 브라우저가 202.43.78.3의 80포트로   &#x20;`TCP 커넥션을 생성`한다.
5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.
6. 브라우저가 서버에서 온 HTTP 응답 메세지를 읽는다.
7. 브라우저가 커넥션을 끊는다.

{% hint style="danger" %}
우리는 이걸 3방향 핸드셰이크와 4방향 핸드셰이크라고 한다.
{% endhint %}

> TCP는 `3방향 핸드셰이크(3-way handshake)`라는 방식을 사용해 연결을 수립한다.&#x20;

세 가지 방식의 악수인데, 말 그대로 세 번의 메시지 교환을 통해 클라이언트와 서버가 서로 데이터를 주고받을 준비를 하는 과정을 말한다.

<figure><img src="../../../../.gitbook/assets/image (390).png" alt=""><figcaption></figcaption></figure>

Q. 주고받는 내용만 파악하면 될 것 같은데, 왜 상태까지 함께 확인하는&#x20;걸까?&#x20;

그 이유는 나중에 **실제 데이터를 송수신할 때 이 상태를 보고 전송 가능 여부를&#x20;파악**하기 때문이다. 마치 가게에서 밥을 먹으려고 하는데 문 앞에 ‘영업 종료’ 또는 ‘브레이크 타임’이라고 적혀 있으면 출입할 수 없고 ‘영업 중’이라고 적혀 있어야만 밥을 먹을 수 있는 것과 같다.



> TCP의 연결 종료 방식을 4방향 핸드셰이크(4-way handshake)

TCP 또한 더 이상 보낼 데이터가 없는데 연결을 지속하는 것은 비효율적이라고 생각해 데이터 통신이 끝나면 **연결을 끊는 과정**을 거친다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (391).png" alt=""><figcaption></figcaption></figure>



#### 2) 신뢰할 수 있는 데이터 전송 통로인 TCP

HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하다. 그렇기에 TCP를 제대로 알아야 하는데 TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다.&#x20;

**Q1. 그렇다면 신뢰성 있는 통신이란 무엇일까?**

컴퓨터 세상에서 신뢰성이 있다는 것은 **오류가 없다는 뜻**이다. 즉, 언제 어디서든 데이터를 온전히 가져다줄 거라는 믿음이 있는 것이다.

**Q2. TCP는 패킷의 유실 문제를 해결해주는데.. 어떤 방식으로 해결해줄까?**

어떤 패킷이 사라졌는지 파악하기 위해 **패킷마다 번호를 붙이고** 정확히 목적지에 도착했는지 확인하기 위해 **하나의 확인 절차**를 추가했다. ⇒ 이로 인해 충돌 없이 순서에 맞게 HTTP 데이터를 전달한다.

**Q3. 데이터를 받았다라는 의사소통이 가능한 방법은?**

`TCP 헤더`이다. IP를 포함해 모든 프로토콜은 데이터의 앞에 헤더(header)라는 정보를 추가해 전송하는데 헤더 안에는 **해당 데이터에 대한 정보가 담겨 있다.**![](../../../../.gitbook/assets/image.png)

비유하자면 택배 상자에 붙어 있는 운송장 스티커이며, 프로토콜에 따라 필요한 정보가 다르다 보니 출발지. 도착지 같은 공통 부분을 제외하면&#x20;헤더는 프로토콜마다 조금씩 다른 형태와 크기를 가지고 있다.

#### 3) TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

TCP는 IP 패킷이라는 작은 조각을 통해 데이터를 전송하는데.. HTTP가 최상위 계층으로 HTTP가 메세지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.

**HTTP에 보안(S)을 더한 HTTPS**&#x20;

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

암호화는 사실 HTTTPS가 아닌 다른 곳에서 담당하는데, 바로 `SSL(Secure Sockets Layer)`이다. SSL은 클라이언트와 서버가 서로 데이터를 암호화해 통신할 수 있게 돕는 보안 계층

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

> 여기서 TLS이란?&#x20;

당시 공개된 SSL 2.0에 몇 가지 취약점이 발견되어 이를 해결하기 위해 아예 구조를 재설계해 SSL 3.0을 배포했는데, 그 이후 **기존 버전과 구분하기 위해** 3.0 다\
음부터 등장한 SSL의 이름을 TLS로 변경했다.

**세그먼테이션**

1. TCP는 `세그먼트`라는 단위로 데이터 스   트림을 잘게 나누고, 세그먼트를 `IP 패킷`라고 불리는 봉투에 담아서 인터넷을 통해   &#x20;데이터를 전달한다.

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

2. 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.   \
   이 IP 패킷들 각각은 다음을 포함한다.
   1. IP 패킷 헤더 : 발신지, 목적지 IP 주소, 크기, 기타 플래그
   2. TCP 세그먼트 헤더 : TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성 검사하기 위해 사용되는 숫자값
   3. TCP 데이터 조각

#### 4) TCP 커넥션 유지하기

{% hint style="success" %}
TCP는 **포트 번호**를 통해서 여러 개의 커넥션을 유지한다.
{% endhint %}

포트번호

* 회사 직원의 내선전화와 같다.
* `IP 주소`는 **해당 컴퓨터에 연결**되고, `포트번호`는 **해당 애플리케이션으로 연결**

**TCP 커넥션의 네 가지 값으로 식별 : 유일한 커넥션 생성**

* 발신지 IP 주소
* 발신지 포트
* 수신지 IP 주소
* 수신지 포트

{% hint style="danger" %}
서로 다른 두 개의 TCP 커넥션은 <mark style="color:red;">네 가지 주소 구성요소의 값이 모두 같을 수 없다.</mark> 다만 일부가 같을 수는 있다.
{% endhint %}

<figure><img src="../../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

#### 5) TCP 소켓 프로그래밍

> 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.

**TCP 프로그래밍 인터페이스**&#x20;

* 소켓 API의 주요 인터페이스&#x20;
  * HTTP 프로그래머에게 <mark style="color:orange;">TCP와 IP의 세부사항들을 숨긴다.</mark>
  * 소켓 API는 유닉스 운영체제용으로 먼저 개발&#x20;
  * TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

{% hint style="warning" %}
TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다는 의미
{% endhint %}

* TCP 종단 데이터 구조: 컴퓨터에서 네트워크 통신을 할 때, TCP 소켓을 생성하면 해당 소켓에 연결된 <mark style="color:red;">다양한 버퍼(데이터 저장 공간), 시퀀스 번호, 연결 관리 정보 등, 데이터를 송수신하기 위한 구조체가 운영체제 내부에서 구성</mark>됨.
* 원격 서버 TCP 종단: TCP는 항상 송신자와 수신자(클라이언트와 서버) 양쪽 종단(endpoint) 간에 연결이 형성됨
* 연결: TCP 프로토콜은 `세 방향 핸드셰이크 과정`을 거쳐 두 종단에 논리적으로 연결을 만드는 과정이다. 이 연결을 통해 양쪽 컴퓨터는 신뢰성 있게 데이터를 주고받을 수 있다.

**동작 방식**

* 애플리케이션(예: 웹 브라우저, 서버 프로그램)이 소켓 API를 통해 TCP 연결을 요청하면 운영체제는 해당 TCP 종단점(Endpoint) 구조를 만들고 관리한다.
* 연결이 성립되면, 프로그램은 이 소켓(TCP 연결) 통해 데이터를 '스트림' 형태로 읽고 쓸 수 있다. 즉, 파일을 다루듯이 TCP 연결 상에서 데이터를 쪽쪽 읽거나 쓸 수 있게 됨.
* TCP는 전송 순서 보장, 오류 검출 및 재전송 등으로 신뢰성을 제공하며 `스트림(이어진 데이터 흐름) 형태`로 동작한다.

> 즉, 운영체제가 TCP 연결을 위해 내부적으로 데이터를 송수신할 수 있는 구조(버퍼 등)를 만들고, 이 구조를 원격 서버의 TCP와 연결해, 서로 실시간으로 데이터를 주고받을 수 있다는 뜻이다. 프로그래밍에서는 소켓을 통해 이 연결을 다루고, 결과적으로 TCP 연결을 통해 파일이나 문자열 스트림처럼 네트워크 데이터를 읽고 쓸 수 있다.

* TCP API
  * 기본적인 네트워크 프로토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.

<figure><img src="../../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

그림에 대한 부가설명

{% hint style="success" %}
클라이언트와 **서버가 TCP 소켓 인터페이스를 사용하여 상호작용하는 방법**을 순서도로 나타낸 것이다.
{% endhint %}

* TCP 3-way Handshake
  * &#x20;**클라이언트(C3: 서버의 IP:포트로 연결한다(connect))**&#xC640; 서버(S4: 커넥션을 기다린다(accept)) 사이에 `연결(connection)`을 수립하는 과정
  * 이미지의 C3와 S4 과정은 이 3-way Handshake가 성공적으로 완료되어 연결이 맺어지는 순간을 포괄적으로 나타낸다.&#x20;
  * 3-way Handshake 자체는 순서도에 명시된 C3-S4 사이에 SYN-SYN/ACK-ACK의 패킷 교환으로 이루어진다.
* TCP 4-way Handshake
  * 클라이언트와 서버가 연결(connection)을 `종료(close)`하는 과정입니다. 이미지의 C8(커넥션을 닫는다(close))와 S9(커넥션을 닫는다(close)) 과정은 이 4-way Handshake를 포괄적으로 나타냄
  * 4-way Handshake 자체는 FIN-ACK-FIN-ACK의 패킷 교환으로 이루어진다.

{% hint style="warning" %}
이미지의 순서도는 TCP 소켓 통신을 이용한 일반적인 HTTP 요청/응답의 흐름을 클라이언트와 서버의 역할 분담과 소켓 함수 호출(socket, bind, listen, accept, connect, read, write, close) 중심으로 보여주는 것이며, **그 과정 속에 TCP 3-way Handshake (연결 수립)와 TCP 4-way Handshake (연결 종료)가 포함되어 있다.**
{% endhint %}

### 3. TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 <mark style="color:blue;">HTTP 트랙잭션의 성능은 그 아래&#x20;계층인 TCP 성능에 영향을 받는다.</mark>

#### 1) HTTP 트랜잭션 지연

HTTP 요청 과정에서 어떤 네트워크 지연이 발생하는지 살펴보면서 TCP 성능에 대한 이야기를 알아볼 예정이라고 한다.

<figure><img src="../../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

이 그림은 HTTP의 주요 커넥션, 전송, 처리의 지연을 보여준다. **트랜잭션을 처리하는 시간**은 TCP 커넥션을 설정하고, 요청하고, 응답 메세지를 보내는 것에 비하면 **상당히 짧다.**

대부분의 HTTP 지연은 <mark style="color:red;">TCP 네트워크 지연</mark> 때문에 발생한다.



**🔍 HTTP 트랜잭션에서 발생하는 4가지 주요 지연**

| 단계            | 발생 원인                             | 주요 지연 요인                   | 소요 시간 (과거 기준)                |
| ------------- | --------------------------------- | -------------------------- | ---------------------------- |
| 1. 이름 분석      | URI의 호스트명을 IP 주소로 변환해야 함.         | DNS 이름 분석 (DNS Resolution) | 수십 초 (현재는 밀리초 단위로 매우 빠름)     |
| 2. 연결 수립      | 클라이언트가 서버에 TCP 커넥션을 요청하고 응답을 기다림. | TCP 3-way Handshake        | 1\~2초 (현재는 1초 미만으로 빠름)       |
| 3. 요청 전송 및 처리 | 클라이언트의 HTTP 요청 메시지가 서버에 전달되고 처리됨. | 요청 메시지 전송 시간 및 서버 처리 시간    | 메시지 크기, 거리, 네트워크 속도 등에 따라 다름 |
| 4. 응답 전송      | 웹 서버가 HTTP 응답 메시지를 클라이언트에게 보냄.    | 응답 메시지 전송 시간               | 메시지 크기, 거리, 네트워크 속도 등에 따라 다름 |

HTTP 요청을 보내고 응답을 받기까지의 총 시간은 다음의 4가지 주요 네트워크 지연 시간의 합이다.&#x20;

1. DNS 찾기 (호스트명 $$→$$ IP 주소)
2. TCP 연결 (3-way Handshake)
3. 요청 처리 (요청 전송 및 서버 처리)
4. 응답 전송 (서버 $$→$$ 클라이언트 응답 전송)

> 💡 참고: 텍스트에 언급된 지연 시간(수십 초, 1\~2초)은 과거 인터넷 환경 기준이며, 현재는 DNS 캐싱과 인프라 발전 덕분에 대부분 훨씬 빠르게 처리된다.

#### 2) TCP 3-way Handshake 지연

> TCP 3-way Handshake에 의한 지연은 현재 HTTP/2를 사용하더라도 여전히 존재한다.

HTTP/2는 HTTP 프로토콜 계층의 성능을 획기적으로 개선했지만, 전송 계층(Transport Layer)인 TCP 위에서 동작하기 때문에 TCP 자체의 특성에서 오는 지연을 완전히 없애지는 못한다.

**1. TCP Handshake 지연의 원인**

TCP 연결을 새로 설정할 때마다 다음과 같은 `왕복 시간(RTT: Round-Trip Time)`이 발생한다.

| 순서  | 주체         | 패킷 (플래그)               | 지연 발생         |
| --- | ---------- | ---------------------- | ------------- |
| 1단계 | 클라이언트 → 서버 | SYN (커넥션 생성 요청)        | 1 RTT (왕복 시간) |
| 2단계 | 서버 → 클라이언트 | SYN + ACK (요청 수락 및 응답) |               |
| 3단계 | 클라이언트 → 서버 | ACK (커넥션 완료 확인)        |               |

* TCP 3-way Handshake: 연결을 수립하기 위해 3번의 패킷 교환(SYN - SYN/ACK - ACK)이 필요하며, 이는 최소 1 RTT의 지연을 발생시킨다.
* TLS/SSL Handshake (필수): 대부분의 HTTP/2 통신은 보안상의 이유로 TLS 위에서 이루어지며, 이는 다시 1\~2 RTT의 지연을 추가로 발생시킨다.

따라서 새로운 연결을 수립할 때는 최소 2\~3 RTT의 지연이 발생한다. 사실 이 책에서는 이미 존재하는 커넥션을 재활용하는 것이 해결책이라고 했는데 **이미 2, 3에서 해결책이 나오기 했다.**



**2. HTTP/2의 해결책**

HTTP/2는 이 지연 자체를 제거하지는 못하지만, 지연의 영향을 최소화하도록 설계되었다.

| 지연 최소화 전략 | 설명                                                                                                     |
| --------- | ------------------------------------------------------------------------------------------------------ |
| 단일 연결 유지  | HTTP/1.1은 여러 요청을 위해 여러 개의 TCP 연결을 생성했지만, HTTP/2는 하나의 TCP 연결만 사용하여 모든 요청과 응답을 다중화(Multiplexing)하여 전송한다. |
| 재연결 최소화   | 이 단일 연결을 오랫동안 유지(Connection Persistency)하여, 매번 요청 시마다 새로운 3-way Handshake를 수행하는 것을 방지한다.               |

3. **완전한 지연 해결 (HTTP/3의 등장)**

이 TCP Handshake 지연 문제를 근본적으로 해결하기 위해 등장한 것이 바로 HTTP/3이다.&#x20;

* HTTP/3는 TCP 대신 UDP 기반의 `QUIC 프로토콜`을 사용합니다.
* QUIC은 자체적으로 연결 수립 및 TLS 핸드셰이크를 통합하여 최초 연결 시 1 RTT로 줄이고, 재연결 시 0 RTT (즉시 데이터 전송 가능)를 목표로 하여 Handshake 지연을 거의 제거한다.

4. **Chrome의 HTTP 버전 사용 전략**

Chrome은 최고의 성능을 위해 가장 최신 버전을 우선적으로 시도하며, 서버 환경에 따라 자동으로 전환된다.

**우선순위 (가장 빠른 것부터 시도)**

| 우선순위 | 버전       | 기반 프로토콜    | 지연 감소 방법                                         |
| ---- | -------- | ---------- | ------------------------------------------------ |
| 1순위  | HTTP/3   | UDP (QUIC) | TCP Handshake 지연 자체를 제거 (새 연결 1 RTT, 재연결 0 RTT). |
| 2순위  | HTTP/2   | TCP        | 하나의 연결을 오래 유지하여 반복적인 Handshake 회피.               |
| 3순위  | HTTP/1.1 | TCP        | 최종 대체 버전.                                        |

**작동 방식**

* Chrome은 서버가 HTTP/3를 지원하는지 확인 후, 가능하면 가장 빠른 HTTP/3로 연결을 시도한다.
* HTTP/3 연결이 안 되면 HTTP/2로, 그것도 안 되면 HTTP/1.1로 자동 전환된다.

> 결론: Chrome을 사용하면 웹사이트가 지원하는 가장 최신 버전(HTTP/3)을 이용해 TCP 연결 지연을 최소화한 환경에서 웹을 이용할 수 있다.

&#x20;$$TCP$$ **신뢰성 기능이** $$HTTP$$ **성능을 저해하는 요인**

| 요인                                  | 작동 원리                                                               | $\text{HTTP}$에 미치는 영향                                                              |
| ----------------------------------- | ------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| 1. 확인응답 지연 ($$Delayed ACK$$)        | ACK를 즉시 보내지 않고, 0.1\~0.2초 대기하며 같은 방향으로 나갈 데이터 패킷에 ACK를 '편승' 시키려 함.  | 요청-응답 패턴인 HTTP에서는 편승 기회가 적어 ACK가 지연되면서 성능 저하를 유발.                                  |
| 2. 느린 시작 ($$Slow Start$$)           | 새 커넥션은 초기 전송 속도($$혼잡 윈도우$$)를 낮게 제한하고, 성공적인 전송을 확인하며 속도를 점진적으로 높여나감. | 새 커넥션마다 초기 전송이 느려져 $$HTTP$$ 트랜잭션의 성능을 저해.                                          |
| 3. 네이글 알고리즘 ($$Nagle’s Algorithm$$) | 작은 데이터를 최대 크기가 될 때까지 버퍼링하거나, 모든ACK를 받을 때까지 전송을 지연시켜 네트워크 효율을 높임.    | 작은 $$HTTP$$ 메시지가 지연되며, 확인응답 지연과 결합 시 성능 저하가 심해짐. (성능 향상을 위해 TCP\_NODELAY로 비활성화 가능) |
| 4. $$TIME_WAIT$$ 지연                 | 커넥션 종료 후 $$2MSL$$ (최대 세그먼트 수명주기의 2배, 보통 2분) 동안 해당 포트 재사용을 제한함.      | 부하 테스트 등 특정 상황에서 포트 고갈을 일으켜 새로운 커넥션 생성을 막아 성능을 제한함.                                |

**🌐** $$HTTP/2$$ **및 HTTP/3의 대응 전략**

HTTP의 최신 버전들은 $$TCP$$ 자체를 수정할 수 없으므로<mark style="color:red;">, 상위 계층에서</mark> $$TCP$$ <mark style="color:red;">문제의 영향을 최소화하거나</mark> $$TCP$$ <mark style="color:red;">자체를 대체한다.</mark>

**1. HTTP/2 (TCP 기반)**

* 대응: $$TCP$$ 연결을 하나만 맺고 오래 유지하는 `지속 커넥션`과 `다중화(Multiplexing)`를 사용한다.
* 효과: 느린 시작과 핸드셰이크 지연을 한 번만 겪고, 이후에는 연결을 재활용하므로 위 세 가지 $$TCP$$ 지연 요인의 반복적인 발생을 차단한다.

**2. HTTP/3 (UDP/QUIC 기반)**

* 대응: 전송 프로토콜을 UDP 기반의 QUIC으로 교체했다.
* 효과: TCP를 사용하지 않으므로 TCP **핸드셰이크, 느린 시작, TIME\\\_WAIT 지연 문제**가 근본적으로 사라진다. QUIC은 자체적으로 효율적인 혼잡 제어 및 신뢰성을 확보하여 $$HTTP$$ 성능을 극대화다.

{% hint style="success" %}
HTTP/3의UDP를 쓰면... 신뢰성이 없지 않나라는 의문..
{% endhint %}

전통적으로 신뢰성 있는 통신을 담당했던 TCP와 달리, UDP는 패킷의 순서, 손실 여부 등을 확인하지 않고 단순히 데이터를 전송한다.

하지만 HTTP/3는 UDP 위에서 동작하는 **QUIC**이라는 프로토콜을 사용하며, QUIC이 TCP가 제공했던 **신뢰성 기능을 자체적으로 내장하고 있기 때문에 문제가 없다.**



### 4. HTTP 커넥션 관리

#### 1) $$Connection$$ 헤더와 '홉별' 통제

HTTP는 클라이언트와 서버 사이에 프락시/캐시 서버와 같은 `중개 서버(홉)`를 허용한다.

* $$Connection$$ 헤더의 역할: 현재 인접한 두 $$HTTP$$ 애플리케이션(홉) 사이의 커넥션에만 적용될 옵션(예: `close`)을 지정.
* 헤더 보호 (Header Safeguarding): $$Connection$$ 헤더에 나열된 헤더 필드들은 다음 중개 서버로 전달되지 않도록 메시지 전달 시 삭제되어야 ㅎ\
  다. 이는 특정 커넥션 옵션이 다른 커넥션에 영향을 미치는 것을 방지합니다.

####


