# 4장 커넥션 관리

{% hint style="success" %}
Key Point
{% endhint %}

* Http는 어떻게 TCP 커넥션을 사용하는가?
* TCP 커넥션의 지연, 병목, 막힘
* 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
* 커넥션 관리를 위해 따라야 할 규칙들



## TCP 커넥션

> 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.

### 1. 패킷 교환 네트워크 프로토콜이란?

{% hint style="success" %}
패킷 교환 네트워크 프로토콜은 데이터를 일정 크기의 작은 단위인 '패킷(Packet)'으로 분할해서, 각 **패킷이 네트워크를 통해 개별적으로 전송되는 방식을 따르는 통신 방법에서 사용하는 규약**이다.
{% endhint %}

#### 1) 패킷 교환 네트워크의 구조와 동작 원리

* 데이터를 송신 측에서 패킷으로 분할한다.
* 각 패킷에는 목적지 주소 등 제어 정보가 담긴 헤더가 붙는다.
* 패킷들은 서로 다른 경로로 독립적으로 전달될 수 있다.
* 수신 측에서는 패킷을 원래의 데이터로 재조립한다.

#### 2) 대표적인 패킷 교환 네트워크 프로토콜

* IP(Internet Protocol): 패킷의 전달 경로 지정과 목표지 주소 부여 등, 가장 근본적인 패킷 처리 규약.
* TCP(Transmission Control Protocol): 신뢰성 보장(데이터의 순서, 오류 검출 및 재전송 등)을 담당하며, IP 위에서 동작하는 상위 계층 프로토콜.
* UDP(User Datagram Protocol): 오류 제어나 순서 보장은 하지 않고 빠른 전송을 중시하는 비연결형 프로토콜.
* X.25: 전화망 기반 공중 데이터 교환망에서 사용된 초기 패킷 교환 프로토콜.

#### 3) 패킷 교환 프로토콜의 주요 특징

* 네트워크 자원을 효율적으로 공유할 수 있다.
* 대역폭을 여러 사용자가 효율적으로 나눠쓰기 적합하다.
* 장애 시 다른 경로로 **우회가 가능해 신뢰성이 높다.**
* 오늘날의 인터넷, 사설망(LAN/WAN) 등 거의 모든 컴퓨터 네트워크에서 표준으로 사용된다

> 즉, 패킷 교환 네트워크 프로토콜은 인터넷과 같은 네트워크에서 데이터를 쪼개어 전송·전달하고 재조합하는 규칙(대표적으로 TCP, IP, UDP, X.25 등)을 의미한다는 점이 핵심이다.

### 2. 커넥션이 맺어지고 난 후

#### 1)  3방향 핸드셰이크와 4방향 핸드셰이크

일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받은 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

1. 브라우저가 www.joes-hardware.com라는   &#x20;호스트 명을 추출한다.
2. 브라우저가 이 호스트 명에 대한 IP 주소를 찾는다.&#x20;
3. 브라우저가 포트 번호(80)을 얻는다.
4. 브라우저가 202.43.78.3의 80포트로   &#x20;`TCP 커넥션을 생성`한다.
5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.
6. 브라우저가 서버에서 온 HTTP 응답 메세지를 읽는다.
7. 브라우저가 커넥션을 끊는다.

{% hint style="danger" %}
우리는 이걸 3방향 핸드셰이크와 4방향 핸드셰이크라고 한다.
{% endhint %}

> TCP는 `3방향 핸드셰이크(3-way handshake)`라는 방식을 사용해 연결을 수립한다.&#x20;

세 가지 방식의 악수인데, 말 그대로 세 번의 메시지 교환을 통해 클라이언트와 서버가 서로 데이터를 주고받을 준비를 하는 과정을 말한다.

<figure><img src="../../../../.gitbook/assets/image (390).png" alt=""><figcaption></figcaption></figure>

Q. 주고받는 내용만 파악하면 될 것 같은데, 왜 상태까지 함께 확인하는&#x20;걸까?&#x20;

그 이유는 나중에 **실제 데이터를 송수신할 때 이 상태를 보고 전송 가능 여부를&#x20;파악**하기 때문이다. 마치 가게에서 밥을 먹으려고 하는데 문 앞에 ‘영업 종료’ 또는 ‘브레이크 타임’이라고 적혀 있으면 출입할 수 없고 ‘영업 중’이라고 적혀 있어야만 밥을 먹을 수 있는 것과 같다.



> TCP의 연결 종료 방식을 4방향 핸드셰이크(4-way handshake)

TCP 또한 더 이상 보낼 데이터가 없는데 연결을 지속하는 것은 비효율적이라고 생각해 데이터 통신이 끝나면 **연결을 끊는 과정**을 거친다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (391).png" alt=""><figcaption></figcaption></figure>



#### 2) 신뢰할 수 있는 데이터 전송 통로인 TCP

HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하다. 그렇기에 TCP를 제대로 알아야 하는데 TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다.&#x20;

**Q1. 그렇다면 신뢰성 있는 통신이란 무엇일까?**

컴퓨터 세상에서 신뢰성이 있다는 것은 **오류가 없다는 뜻**이다. 즉, 언제 어디서든 데이터를 온전히 가져다줄 거라는 믿음이 있는 것이다.

**Q2. TCP는 패킷의 유실 문제를 해결해주는데.. 어떤 방식으로 해결해줄까?**

어떤 패킷이 사라졌는지 파악하기 위해 **패킷마다 번호를 붙이고** 정확히 목적지에 도착했는지 확인하기 위해 **하나의 확인 절차**를 추가했다. ⇒ 이로 인해 충돌 없이 순서에 맞게 HTTP 데이터를 전달한다.

**Q3. 데이터를 받았다라는 의사소통이 가능한 방법은?**

`TCP 헤더`이다. IP를 포함해 모든 프로토콜은 데이터의 앞에 헤더(header)라는 정보를 추가해 전송하는데 헤더 안에는 **해당 데이터에 대한 정보가 담겨 있다.**![](../../../../.gitbook/assets/image.png)

비유하자면 택배 상자에 붙어 있는 운송장 스티커이며, 프로토콜에 따라 필요한 정보가 다르다 보니 출발지. 도착지 같은 공통 부분을 제외하면&#x20;헤더는 프로토콜마다 조금씩 다른 형태와 크기를 가지고 있다.

#### 3) TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

TCP는 IP 패킷이라는 작은 조각을 통해 데이터를 전송하는데.. HTTP가 최상위 계층으로 HTTP가 메세지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.

**HTTP에 보안(S)을 더한 HTTPS**&#x20;

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

암호화는 사실 HTTTPS가 아닌 다른 곳에서 담당하는데, 바로 `SSL(Secure Sockets Layer)`이다. SSL은 클라이언트와 서버가 서로 데이터를 암호화해 통신할 수 있게 돕는 보안 계층

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

> 여기서 TLS이란?&#x20;

당시 공개된 SSL 2.0에 몇 가지 취약점이 발견되어 이를 해결하기 위해 아예 구조를 재설계해 SSL 3.0을 배포했는데, 그 이후 **기존 버전과 구분하기 위해** 3.0 다\
음부터 등장한 SSL의 이름을 TLS로 변경했다.

**세그먼테이션**

1. TCP는 `세그먼트`라는 단위로 데이터 스   트림을 잘게 나누고, 세그먼트를 `IP 패킷`라고 불리는 봉투에 담아서 인터넷을 통해   &#x20;데이터를 전달한다.

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

2. 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.   \
   이 IP 패킷들 각각은 다음을 포함한다.
   1. IP 패킷 헤더 : 발신지, 목적지 IP 주소, 크기, 기타 플래그
   2. TCP 세그먼트 헤더 : TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성 검사하기 위해 사용되는 숫자값
   3. TCP 데이터 조각

#### 4) TCP 커넥션 유지하기

{% hint style="success" %}
TCP는 **포트 번호**를 통해서 여러 개의 커넥션을 유지한다.
{% endhint %}

포트번호

* 회사 직원의 내선전화와 같다.
* `IP 주소`는 **해당 컴퓨터에 연결**되고, `포트번호`는 **해당 애플리케이션으로 연결**

**TCP 커넥션의 네 가지 값으로 식별 : 유일한 커넥션 생성**

* 발신지 IP 주소
* 발신지 포트
* 수신지 IP 주소
* 수신지 포트

{% hint style="danger" %}
서로 다른 두 개의 TCP 커넥션은 <mark style="color:red;">네 가지 주소 구성요소의 값이 모두 같을 수 없다.</mark> 다만 일부가 같을 수는 있다.
{% endhint %}

<figure><img src="../../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

#### 5) TCP 소켓 프로그래밍

> 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.

**TCP 프로그래밍 인터페이스**&#x20;

* 소켓 API의 주요 인터페이스&#x20;
  * HTTP 프로그래머에게 <mark style="color:orange;">TCP와 IP의 세부사항들을 숨긴다.</mark>
  * 소켓 API는 유닉스 운영체제용으로 먼저 개발&#x20;
  * TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

{% hint style="warning" %}
TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다는 의미
{% endhint %}

* TCP 종단 데이터 구조: 컴퓨터에서 네트워크 통신을 할 때, TCP 소켓을 생성하면 해당 소켓에 연결된 <mark style="color:red;">다양한 버퍼(데이터 저장 공간), 시퀀스 번호, 연결 관리 정보 등, 데이터를 송수신하기 위한 구조체가 운영체제 내부에서 구성</mark>됨.
* 원격 서버 TCP 종단: TCP는 항상 송신자와 수신자(클라이언트와 서버) 양쪽 종단(endpoint) 간에 연결이 형성됨
* 연결: TCP 프로토콜은 `세 방향 핸드셰이크 과정`을 거쳐 두 종단에 논리적으로 연결을 만드는 과정이다. 이 연결을 통해 양쪽 컴퓨터는 신뢰성 있게 데이터를 주고받을 수 있다.

**동작 방식**

* 애플리케이션(예: 웹 브라우저, 서버 프로그램)이 소켓 API를 통해 TCP 연결을 요청하면 운영체제는 해당 TCP 종단점(Endpoint) 구조를 만들고 관리한다.
* 연결이 성립되면, 프로그램은 이 소켓(TCP 연결) 통해 데이터를 '스트림' 형태로 읽고 쓸 수 있다. 즉, 파일을 다루듯이 TCP 연결 상에서 데이터를 쪽쪽 읽거나 쓸 수 있게 됨.
* TCP는 전송 순서 보장, 오류 검출 및 재전송 등으로 신뢰성을 제공하며 `스트림(이어진 데이터 흐름) 형태`로 동작한다.

> 즉, 운영체제가 TCP 연결을 위해 내부적으로 데이터를 송수신할 수 있는 구조(버퍼 등)를 만들고, 이 구조를 원격 서버의 TCP와 연결해, 서로 실시간으로 데이터를 주고받을 수 있다는 뜻이다. 프로그래밍에서는 소켓을 통해 이 연결을 다루고, 결과적으로 TCP 연결을 통해 파일이나 문자열 스트림처럼 네트워크 데이터를 읽고 쓸 수 있다.

* TCP API
  * 기본적인 네트워크 프로토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.

<figure><img src="../../../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

그림에 대한 부가설명

{% hint style="success" %}
클라이언트와 **서버가 TCP 소켓 인터페이스를 사용하여 상호작용하는 방법**을 순서도로 나타낸 것이다.
{% endhint %}

* TCP 3-way Handshake
  * &#x20;**클라이언트(C3: 서버의 IP:포트로 연결한다(connect))**&#xC640; 서버(S4: 커넥션을 기다린다(accept)) 사이에 `연결(connection)`을 수립하는 과정
  * 이미지의 C3와 S4 과정은 이 3-way Handshake가 성공적으로 완료되어 연결이 맺어지는 순간을 포괄적으로 나타낸다.&#x20;
  * 3-way Handshake 자체는 순서도에 명시된 C3-S4 사이에 SYN-SYN/ACK-ACK의 패킷 교환으로 이루어진다.
* TCP 4-way Handshake
  * 클라이언트와 서버가 연결(connection)을 `종료(close)`하는 과정입니다. 이미지의 C8(커넥션을 닫는다(close))와 S9(커넥션을 닫는다(close)) 과정은 이 4-way Handshake를 포괄적으로 나타냄
  * 4-way Handshake 자체는 FIN-ACK-FIN-ACK의 패킷 교환으로 이루어진다.

{% hint style="warning" %}
이미지의 순서도는 TCP 소켓 통신을 이용한 일반적인 HTTP 요청/응답의 흐름을 클라이언트와 서버의 역할 분담과 소켓 함수 호출(socket, bind, listen, accept, connect, read, write, close) 중심으로 보여주는 것이며, **그 과정 속에 TCP 3-way Handshake (연결 수립)와 TCP 4-way Handshake (연결 종료)가 포함되어 있다.**
{% endhint %}

### 3. TCP의 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 <mark style="color:blue;">HTTP 트랙잭션의 성능은 그 아래&#x20;계층인 TCP 성능에 영향을 받는다.</mark>

#### 1) HTTP 트랜잭션 지연

HTTP 요청 과정에서 어떤 네트워크 지연이 발생하는지 살펴보면서 TCP 성능에 대한 이야기를 알아볼 예정이라고 한다.

<figure><img src="../../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

이 그림은 HTTP의 주요 커넥션, 전송, 처리의 지연을 보여준다. **트랜잭션을 처리하는 시간**은 TCP 커넥션을 설정하고, 요청하고, 응답 메세지를 보내는 것에 비하면 **상당히 짧다.**

대부분의 HTTP 지연은 <mark style="color:red;">TCP 네트워크 지연</mark> 때문에 발생한다.



🔍 HTTP 트랜잭션에서 발생하는 4가지 주요 지연

| 단계            | 발생 원인                             | 주요 지연 요인                   | 소요 시간 (과거 기준)                |
| ------------- | --------------------------------- | -------------------------- | ---------------------------- |
| 1. 이름 분석      | URI의 호스트명을 IP 주소로 변환해야 함.         | DNS 이름 분석 (DNS Resolution) | 수십 초 (현재는 밀리초 단위로 매우 빠름)     |
| 2. 연결 수립      | 클라이언트가 서버에 TCP 커넥션을 요청하고 응답을 기다림. | TCP 3-way Handshake        | 1\~2초 (현재는 1초 미만으로 빠름)       |
| 3. 요청 전송 및 처리 | 클라이언트의 HTTP 요청 메시지가 서버에 전달되고 처리됨. | 요청 메시지 전송 시간 및 서버 처리 시간    | 메시지 크기, 거리, 네트워크 속도 등에 따라 다름 |
| 4. 응답 전송      | 웹 서버가 HTTP 응답 메시지를 클라이언트에게 보냄.    | 응답 메시지 전송 시간               | 메시지 크기, 거리, 네트워크 속도 등에 따라 다름 |

***

#### 핵심 요약

HTTP 요청을 보내고 응답을 받기까지의 총 시간은 다음의 4가지 주요 네트워크 지연 시간의 합입니다.

1. DNS 찾기 (호스트명 $$→$$ IP 주소)
2. TCP 연결 (3-way Handshake)
3. 요청 처리 (요청 전송 및 서버 처리)
4. 응답 전송 (서버 $$→$$ 클라이언트 응답 전송)

💡 참고: 텍스트에 언급된 지연 시간(수십 초, 1\~2초)은 과거 인터넷 환경 기준이며, 현재는 DNS 캐싱과 인프라 발전 덕분에 대부분 훨씬 빠르게 처리됩니다.

