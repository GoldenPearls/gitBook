# 2장 URL과 리소스

## 1. URL과 리소스: 주소가 있는 인터넷 도시를 탐험한다

### 1) 도시는 크다. 표준 이름이 질서를 만든다

인터넷을 거대한 도시로 본다. 사람들은 **공통 작명 규칙**을 쓴다.

* 길 찾기엔 **거리 주소**(집·가게 위치)
* 통화엔 **전화번호**(연락 경로)
* 책·버스·계좌 같은 리소스엔 각기 **ISBN/노선번호/계좌번호**

그래서 “맥엘리스터 거리 246번지로 간다”, “공항 31번 출구로 간다”가 통한다.

> **모두가 같은 이름 체계를 공유하기 때문에** 정보를 **정확히 가리키고, 쉽게 공유**한다.

### 2) URL: 인터넷 도시의 표준 주소

{% hint style="success" %}
URL은 애플리케이션이 리소스에 접근할 수 있는 방법을 제공
{% endhint %}

**URL(Uniform Resource Locator)** 은 인터넷 리소스의 **표준 주소**다.

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p><a href="https://hanamon.kr/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EB%B3%B8-url-uri-urn-%EC%B0%A8%EC%9D%B4%EC%A0%90/">https://hanamon.kr/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EB%B3%B8-url-uri-urn-%EC%B0%A8%EC%9D%B4%EC%A0%90/</a></p></figcaption></figure>

* **어디에** 있고(**위치**)
* **어떻게** 접근하는지(**방법/프로토콜**)를 한 줄로 표현한다.

예:

```
http://www.joes-hardware.com/seasonal/index-fall.html
```

* `http` = **스킴**(접근 방법: HTTP)
* `www.joes-hardware.com` = **호스트**(서버 위치)
* `/seasonal/index-fall.html` = **경로**(서버 내부에서 무엇을)

> URL은 **URI**(통합 자원 식별자)의 부분집합이다.\
> URI = **URL(위치 기반)** + **URN(이름 기반, 위치 독립)**.\
> HTTP 명세는 보통 URI를 쓰지만, 실무에선 URL을 주로 말한다.

***

### 3) 브라우저는 주소만 주면 알아서 간다

<figure><img src="../../../../.gitbook/assets/image (374).png" alt=""><figcaption></figcaption></figure>

사용자가 브라우저에 URL을 넣는다. 브라우저는 **적절한 프로토콜**(HTTP, FTP, mailto, RTSP 등)을 골라 메시지를 보낸다.

* `http://…` → HTTP로 문서/이미지 가져온다
* `ftp://…` → FTP 서버에서 파일을 내려받는다
* `mailto:…` → 메일 작성 흐름을 연동한다
* `rtsp://…` → 스트리밍 서버에 연결한다

> 오늘날 브라우저는 다양한 리소스 접근을 **하나의 인터페이스**로 통합한다.

***

### 4) URL이 없던 시절은 불편했다

예전에는 “익명(anonymous)으로 FTP 접속 → 디렉터리 이동 → 바이너리 전환 → 파일 다운로드” 같은 장황한 절차를 구두로 전달했다.

> URL이 있기 전에 친구와 complete-catalog.xls이라는 파일을 공유하려고 했다면> \
> 이렇게 말해야 했을 것이다.&#x20;
>
> “ftp.joes-hardware.com에 FIP로 접속해.&#x20;
>
> 익명 사용자> 로 로그인한 다음 비밀번호로 네 이름을 입력해.&#x20;
>
> pub 디렉터리로 이동한 다음, 바> 이너리 형식으로 전환해.&#x20;
>
> 이제 complete-catalog.xls란 이름의 파일을 너의 로컬 파> 일 시스템에 내려 받은 다음 보면 될 거야."

URL이 등장하면서 “`ftp://ftp.example.com/pub/file.xls`를 열어라”라고 **한 줄**로 끝낸다.\
→ **접근 방법**과 **위치 정보**를 주소에 포함했기 때문이다.

***

### 5) URL의 일반 문법(큰 그림)

<figure><img src="../../../../.gitbook/assets/image (375).png" alt=""><figcaption></figcaption></figure>

대부분의 스킴은 아래 **일반 문법**을 공유한다.

```
<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

<figure><img src="../../../../.gitbook/assets/image (376).png" alt=""><figcaption></figcaption></figure>

실제로 **모든 컴포넌트를 다 쓰지는 않는다**. 핵심은 보통 **스킴·호스트·경로**다.

#### 필수/주요 컴포넌트

* **스킴**: 어떤 프로토콜로 접근하는지 지정한다.
  * 문자로 시작한다. 대소문자 구분하지 않는다(`http`=`HTTP`).
* **호스트**: 리소스를 **호스팅하는 서버**(도메인 또는 IP).
* **포트**: 서버의 **프로세스가 열어둔 문**(기본 HTTP 80, HTTPS 443).
* **경로**: 서버 내부의 **리소스 위치**(유닉스 파일 경로처럼 `/`로 구분).
  * [http://www.joes-hardware.com:80/seasonal/index-fall.html](http://www.joes-hardware.com/seasonal/index-fall.html)
  * 이 URL의 경로는 '/seasonal/index-fall.html'로 유닉스 파일 시스템의 파일 경로와    \
    유사하다.

#### 선택 컴포넌트

*   **사용자이름/비밀번호**: 접근 자격이 필요한 스킴(주로 FTP).

    ```
    ftp://anonymous:passwd@ftp.example.org/pub/gnu
    ```
*   **파라미터(경로 세그먼트 파라미터)**: 경로 조각마다 붙는 추가 정보(세미콜론 `;` 사용).

    ```
    http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
    ```
* **질의(Query)**: 게이트웨이/앱에 전달할 **이름=값** 집합(보통 `&`로 연결).

<figure><img src="../../../../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

* 데이터베이스 같은 서비스들은 요청받을 **리소스 형식의 범위를 좁히기 위해서** 질  \
  문이나 질의를 받을 수 있다.
* **질의 컴포넌트 :** 물음표(?)의 우측에 있는  &#x20;값들
* `질의컴포넌트`는  **게이트웨이를  &#x20;가리키는 URL의 경로 컴포넌트**와 함께 전달하고 있다
  *   게이트웨이는, 다른 애      플리케이션에 접근하려고 할 때 거치는 통로라고 할 수 있다

      ```
      http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=blue&size=large
      ```
* **프래그먼트(Fragment)**: 문서 내부 **하위 조각** 식별(`drills` 절 등).

```
http://www.joes-hardware.com/tools.html#drills
```

프래그먼트는 **서버로 가지 않는다**. 브라우저가 전체 문서를 받은 뒤 **클라이언트 측에서 스크롤/포커스**에 사용한다.

### 6) 예제로 보는 컴포넌트 분해

```
http://www.joes-hardware.com:80/seasonal/index-fall.html
└─ 스킴: http
                         └─ 호스트: www.joes-hardware.com
                             └─ 포트: 80
                                  └─ 경로: /seasonal/index-fall.html
```

다른 스킴 예:

```
mailto:president@whitehouse.gov           ← 메일 주소
ftp://ftp.lots-o-books.com/pub/price.xls  ← FTP 파일
rtsp://media.example.com:554/movie        ← 스트리밍
```

### 7) 질의(Query)와 게이트웨이 흐름

브라우저는 아래 URL을 요청한다.

```
http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=blue&size=large
```

서버의 **게이트웨이 애플리케이션**(CGI 등)은 `item=12731`, `color=blue`, `size=large`를 받아서 데이터베이스를 조회한다.\


→ URL은 **선택/검색 조건**을 주소에 싣는다.

### 8) 프래그먼트(Fragment)는 왜 서버로 안 가나

1\. 프래그먼트의 역할

* 프래그먼트(`#뒤의 부분`)는 **문서 내 위치를 가리키는 표시자**
* 즉, “어떤 문서 안에서 어디를 보여줄지”를 정할 뿐이지, **어떤 문서를 가져올지**에는 영향이 없다.

```
http://example.com/manual.html#chapter5
```

* `manual.html` 👉 서버에 요청할 **실제 리소스**
* `#chapter5` 👉 브라우저가 문서 안에서 “챕터5로 스크롤해라”라는 **클라이언트 전용 지시어**



**2. 서버가 받을 필요가 없는 이유**

1. **리소스 자체는 동일하기 때문**
   * 서버 입장: “manual.html 전체를 보내면 끝”
   * 서버가 “#chapter5”를 안 받아도, 그건 문서 내용 안에 이미 존재하는 요소이니까 서버 입장에서는 할 일이 없음.
2. **효율성**
   * 프래그먼트는 순전히 **클라이언트 UI 동작**을 위한 것.
   * 서버로 보낼 필요 없이 네트워크 트래픽을 줄이고, 서버 처리도 단순화.
3. **역할 분리**
   * 서버: “무엇을 줄까?” (리소스 제공)
   * 브라우저: “어디를 보여줄까?” (UI 제어)



**3. 실제 동작 흐름**

1. 브라우저: `GET /manual.html HTTP/1.1` 요청
2. 서버: `manual.html` 전체 파일을 응답
3. 브라우저: 응답 HTML 안에서 `id="chapter5"` 위치를 찾아 스크롤 이동

👉 즉, **프래그먼트는 요청 메시지에 포함되지 않는다.**



**4. 비유**

* 서버는 “책”을 보내주는 도서관 📚
* 프래그먼트는 “책 받아서 50쪽부터 읽어라”라는 **책갈피** 📑
* 책갈피는 도서관에 줄 필요 없고, 책을 다 받은 읽는 `사람(브라우저)`만 알면 되는 정보

{% hint style="success" %}
그래서 **“프래그먼트는 왜 서버로 안 가나?” → 서버는 문서 전체만 책임지고, 프래그먼트는 브라우저가 내부적으로만 쓰기 때문**이다.
{% endhint %}

### 9) 실무 팁

* **대소문자**: 스킴·호스트는 관례상 대소문자 무시, **경로는 서버에 따라 다를 수 있다(대소문자 민감)**.
* **포트 기본값**: 생략하면 스킴 기본값(HTTP 80, HTTPS 443).
* **인증정보 포함 URL**: 보안에 취약하므로 지양한다(로그/히스토리 노출).
* **인코딩**: 공백·한글·특수문자는 **퍼센트 인코딩**(`%20`, `%EA%B0%80` 등)을 사용한다.
* **질의 문자열 포맷**: 백엔드 프레임워크마다 다르다. 일반적으로 `?a=1&b=2`.
* **프래그먼트**: SEO/클라이언트 라우팅에서 의미가 다를 수 있다(서버 미전달).

### 10) 요약

* URL은 인터넷 도시의 **표준 주소**다.
* **스킴/호스트/경로**가 핵심이고, 필요 시 **포트/자격/파라미터/질의/프래그먼트**를 더한다.
* 브라우저는 URL만 주면 **적절한 프로토콜로** 리소스를 가져온다.
* 프래그먼트는 **클라이언트 전용**이고, 질의는 **게이트웨이/앱으로 전달**한다.
* URL 덕분에 우리는 “복잡한 접근 절차” 대신 **한 줄 주소**로 리소스를 공유한다.



## 2. URL을 더 짧고, 안전하게 쓰는 법

### 1) 상대 URL vs 절대 URL

URL에는 두 가지 방식이 있다.

* **절대 URL**: 리소스에 접근하는 데 필요한 모든 정보를 담고 있는 "완전한 주소"\
  👉 예: `http://www.joes-hardware.com/tools.html`
* **상대 URL**: 일부만 쓰고, 나머지는 **기저 URL(base URL)** 을 기준으로 추측해서 채워 넣는 "간단한 주소"\
  👉 예: `./hammers.html`

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

> **J oe’s Hardware 웹사이트의 `/tools.html` 문서 안에 `./hammers.html` 링크가 있다면?**
>
> 브라우저는 `http://www.joes-hardware.com/tools.html`을 기저 URL로 삼아
>
> → 최종적으로 `http://www.joes-hardware.com/hammers.html`을 만든다.

➡️ **상대 URL은 HTML 작성자가 긴 주소를 매번 다 쓰지 않도록 도와준다.**



### 2) 기저 URL(Base URL) 찾는 법

<figure><img src="../../../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

상대 URL을 절대 URL로 바꾸려면 "기저(base)"가 필요하다. 기저는 이렇게 결정된다:

1. **HTML에서 명시적으로 `<BASE>` 태그로 설정**
2. **현재 문서의 URL이 기저 URL 역할**
3. **없으면 절대 URL만 사용 가능**

즉, 기저 URL은 상대 URL이 어디로 향할지를 결정하는 나침반 🧭 같은 역할을 한다.



### 3) 🔗 상대 URL → 절대 URL 변환하기

우리는 흔히 웹 문서 안에서 이런 코드를 본다:

```html
<a href="./hammers.html">망치 보러가기</a>
```

언뜻 보면 **주소가 불완전**해 보이죠. 스킴(http)도 없고, 호스트([www.joes-hardware.com)도](http://www.joes-hardware.xn--com\)-el1q/) 없다.

\
하지만 브라우저는 당황하지 않는다. 👉 바로 \*\*기저 URL(Base URL)\*\*을 참고해 절대 URL로 완성해내기  때문이다.



**1. URL 분해하기 (Parsing)**

브라우저는 먼저 **기저 URL**과 **상대 URL**을 작은 조각(컴포넌트)으로 나눈다.\


예를 들어:

*   기저 URL:

    ```
    http://www.joes-hardware.com/tools.html
    ```
*   상대 URL:

    ```
    /hammers.html
    ```



**2. 상속 규칙**

이제 브라우저는 “비어 있는 부분은 기저 URL에서 가져온다”는 규칙을 적용

1. **스킴(scheme)**
   * 상대 URL에는 없음 → 기저 URL(`http`)을 상속
2. **호스트(host)와 포트(port)**
   * 상대 URL에는 없음 → 기저 URL(`www.joes-hardware.com`, `:80`) 상속
3. **경로(path)**
   * 상대 URL에는 `/hammers.html`이 있음 → 그대로 사용
4.  **파라미터, 질의, 프래그먼트**

    * 상대 URL이 비어 있으면 → 기저 URL에서 상속
    * 상대 URL이 지정하면 → 상대 URL 값 사용



**3. 합치기**

이제 모든 조각을 합쳐서 새로운 절대 URL을 얻는다:

```
http://www.joes-hardware.com/hammers.html
```

**비유**

*   기저 URL은 **“집 주소”**

    ```
    서울시 강남구 테헤란로 123, 5층
    ```
*   상대 URL은 **“회의실 A호”**

    ```
    A호
    ```

👉 두 개를 합치면:\
**서울시 강남구 테헤란로 123, 5층 A호**



정리

* **상대 URL만으론 리소스를 찾을 수 없다.**
* **기저 URL을 기준으로 필요한 정보를 상속**한다.
* **최종적으로는 항상 절대 URL**이 만들어진다.

{% hint style="warning" %}
즉, “상대 참조 해석하기”는 **비어 있는 부분은 기저 URL에서 채워 넣고, 상대 URL이 제공하는 부분은 그대로 사용해서 완전한 절대 URL을 조합하는 과정**
{% endhint %}

### 4) URL 확장 (자동 보정)

브라우저는 사용자가 주소를 조금만 써도 알아서 완성해주는 기능을 제공한다.

* **호스트 명 확장**\
  사용자가 `yahoo`만 입력 → 브라우저가 `www.` + `.com` 붙여서 `www.yahoo.com`으로 확장
* **히스토리 확장**\
  사용자가 예전에 갔던 주소를 기억했다가, 입력 도중 자동완성 제공\
  👉 `http://www.joes`까지만 쳐도 `http://www.joes-hardware.com` 제안

➡️ **사용자는 더 빨리, 더 편하게 웹에 접근할 수 있다.**



### 5) 안전하지 않은 문자와 인코딩

URL은 네트워크를 통해 안전하게 전달돼야 한다. 그런데 문제는…

* 어떤 문자들은 **특별한 의미**를 가지거나,
* 어떤 문자들은 **아예 출력이 안 되거나(제어 문자)**,
* 어떤 문자들은 **언어권에 따라 달라서 호환이 어렵다.**

이런 문자가 URL에 그대로 들어가면 전송 중 깨질 수 있다.

#### 그래서 등장한 것 👉 **이스케이프 인코딩**

* `퍼센트(%)` + 16진수 두 자리로 변환한다.
* 예:
  * `공백(space)` → `%20`
  * `~` → `%7E`
  * `%` → `%25`

📌 예시

```
http://www.joes-hardware.com/more%20tools.html
```

→ 원래는 `more tools.html`이지만, 공백이 `%20`으로 인코딩된 것.



### 6) 예약 문자

어떤 문자들은 URL에서 이미 특별한 의미로 예약되어 있다.

* `#` → 프래그먼트 구분
* `?` → 질의(Query String) 시작
* `/` → 경로 구분
* `:` → 스킴 구분 (`http:` 처럼)

이 문자들을 다른 용도로 쓰고 싶으면 반드시 인코딩해야 한다.

### 정리

* **상대 URL**은 짧게 쓰기 위한 방법, **기저 URL**이 기준이 된다.
* 브라우저는 편의 기능으로 **URL 확장**을 지원한다.
* URL에는 **안전하지 않은 문자**가 있어, `%` 인코딩으로 표현한다.
* 일부 문자는 **예약되어 있어(URL 내부에서 특별한 의미)** 반드시 인코딩해야 한다.

{% hint style="success" %}
👉 한마디로 말하면 **URL은 사람에겐 짧고 간단하게, 네트워크에겐 안전하게** 설계된 주소 체계다.
{% endhint %}



## 3. URL, 안전하지 않은 문자 그리고 URN의 등장

### 1) 왜 안전하지 않은 문자가 문제일까?

옛날에는 `http://www.joes-hardware.com/~joe` 같은 주소도 그냥 잘 동작했다.\
여기서 `~` 문자는 사실 **URL 규격상 ‘안전하지 않은 문자’인데, 어떤 프로토콜에서는 문제 없이 지나가기도 했죠.**

그럼에도 불구하고, `“애플리케이션은 반드시 표준을 지켜야 한다”`는 원칙이 있다.

\
왜냐하면:

* 어떤 전송 경로에서는 문자가 잘려나가거나 변형될 수 있고,
* 일부 애플리케이션은 `~` 같은 문자를 **특수한 의미**로 오해할 수 있기 때문

> 👉 그래서 **클라이언트(브라우저 등)는 URL을 입력받을 때 안전하지 않은 문자를 인코딩**하는 게 원칙이다.

예:

* `~` → `%7E`
* 공백(space) → `%20`

### 2) 인코딩의 역할

**모든 문자를 다 인코딩해버리는 극단적인 방법도 있다.**\
하지만 그렇게 하면 원래 안전한 문자까지 인코딩되므로 URL이 복잡해지고, 일부 애플리케이션은 오히려 해석에 실패할 수 있음.

즉, **“정말 필요한 문자만 인코딩”**&#xD558;는 게 바람직.\


이렇게 하면:

* URL 원형을 유지하면서도,
* 애플리케이션 간 혼동을 줄이고,
* 악의적인 인코딩(필터 우회 같은)을 막을 수 있다.



### 3) URL 스킴의 바다

URL에는 정말 많은 스킴이 존재

* `http://` → 웹 페이지 접근
* `https://` → SSL 암호화된 안전한 웹 페이지
* `mailto:` → 이메일 주소
* `ftp://` → 파일 전송
* `rtsp://` → 스트리밍
* `file://` → 로컬/네트워크 파일
* `news:` → 뉴스 그룹
* `telnet://` → 원격 접속

👉 URL은 **주소 역할**을 하며, “어떤 리소스를, 어디서, 어떻게 가져올지”를 알려주는 표준 규칙



### 4) 그런데 URL은 이름(Name)이 아니다

URL은 어디까지나 `주소(Address)`에 불과하다.\
즉, 리소스가 어디에 “위치”하는지를 알려줄 뿐이다.

> **하지만 만약 리소스가 다른 서버로 옮겨가 버린다면?**\
> → 기존 URL은 더 이상 동작하지 않는다 ❌

이게 URL의 가장 큰 한계..



### 5️) URN의 등장&#x20;

그래서 연구자들은 “위치와 무관하게 변하지 않는 이름”을 고민했다. 그게 바로 **URN (Uniform Resource Name)** 이다.

* 예: `urn:ietf:rfc:2141`
  * 이건 RFC 문서 2141을 가리키는 이름
  * 어디에 저장돼 있든, 몇 군데 복사돼 있든 **이름 자체로 동일한 리소스**를 식별할 수 있다.

### 6️) PURL – 임시 다리

URN이 본격적으로 자리 잡기 전까지는 `PURL (Persistent URL)`이라는 방식이 쓰였다.

작동 원리는 간단다.

1. 사용자는 `http://purl.oclc.org/hardware/` 같은 **영구 URL**로 접근
2. PURL 서버(위치 중개자)가 현재 리소스의 실제 위치를 찾아줌
3. 사용자를 실제 URL (`http://www.joes-hardware.com/`)로 리다이렉트

👉 즉, **“내가 직접 바뀌는 주소를 기억할 필요 없이, 항상 PURL만 부르면 된다”**&#xB294; 개념

### 정리

* URL은 강력하지만 **주소**일 뿐 → 리소스 위치가 바뀌면 무용지물
* 안전하지 않은 문자는 반드시 인코딩해야 함 → 애플리케이션 간 호환성 보장
* URN은 “위치 독립적인 이름”을 제공 → 리소스 이동에도 흔들리지 않음
* PURL은 URN의 아이디어를 흉내 낸 임시 해법



