# 11장 클라이언트 식별과 쿠키

`웹 서버`는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다. 이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 **서버와 통신하고 있는 클라이언트를 추적해야 할 수도 있다.**

<figure><img src="../../../../.gitbook/assets/image (425).png" alt=""><figcaption></figcaption></figure>

## 1. 개별 접촉

### 🍪 HTTP 클라이언트 식별 및 상태 유지 기술

#### 1) HTTP의 기본 특성: 무상태 (Stateless)

* 정의: HTTP는 기본적으로 **상태가 없는(Stateless) 프로토콜**입니다. 각 요청(Request)과 응답(Response)은 서로 독립적이며, 서버는 클라이언트가 보낸 이전 요청에 대한 정보를 유지하지 않습니다.
* 문제점: 이러한 무상태 특성 때문에, 웹사이트는 사용자의 연속적인 상호작&#xC6A9;**(예: 온라인 쇼핑몰의 장바구니 기능)**&#xC744; 추적하거나, 개인 맞춤형 서비스를 제공하기 어렵습니다.

#### 2) 개인화된 서비스의 필요성 (현대 웹의 목표)

현대 웹사이트들은 다음과 같은 개인화된 경험을 제공하기 위해 사용자를 식별해야 합니다.

* 개별 인사: 사용자 이름이 포함된 환영 메시지 등 맞춤형 페이지 제공.
* 사용자 맞춤 추천: 과거 행동 및 관심사를 분석하여 예상되는 제품이나 콘텐츠 추천.
* 저장된 사용자 정보 활용: 주소, 신용카드 정보 등을 저장하여 매번 재입력할 필요 없이 편리한 쇼핑 환경 제공.

#### 3) 사용자 식별을 위한 주요 기술 (최신화 포함)

HTTP의 무상태 문제를 극복하고 사용자를 식별하기 위해 고안된 기술들입니다.

**1️⃣ HTTP 쿠키 (Cookies) — 가장 널리 쓰이는 표준**

* 원리: 서버가 <mark style="color:red;">클라이언트에 작은 데이터를 저장</mark>하게 한 뒤, 클라이언트가 매 요청마다 이 데이터를 서버로 다시 전송하게 하여 상태를 유지합니다.
* 특징: 강력하면서도 효율적으로 식별 정보를 지속 유지할 수 있는 사실상의 표준입니다.
* 2025년 현황:
  * 프라이버시 강화: 쿠키는 여전히 널리 쓰이지만, 개인정보 보호 강화 추세(GDPR, CCPA 등)와 브라우저 정책(Chrome의 서드파티 쿠키 단계적 폐지)으로 인해 서드파티 쿠키 사용은 대폭 축소되거나 금지되고 있습니다.
  * 대체 기술: 마케팅 목적으로는 퍼스트파티 쿠키와 더불어, 서버에서 사용자 ID를 생성하고 트래킹하는 <mark style="color:red;">서버사이드 트래킹 기술</mark>이 부상하고 있습니다.



**2️⃣ 클라이언트 IP 주소 추적 (IP Address Tracking)**

* 원리: 요청을 보낸 클라이언트의 IP 주소를 통해 사용자를 식별합니다.
* 단점:
  * IP 주소가 자주 바뀔 수 있습니다. (예: 모바일 네트워크, ISP)
  * 여러 사용자(예: 회사, 학교)가 하나의 NAT를 통해 동일한 공인 IP를 공유할 수 있습니다.
  * 프록시 서버 뒤에 있는 사용자는 서버에 프록시의 IP만 보입니다.
* 2025년 현황: 단독으로는 사용자 식별의 정확도가 낮아, `지리적 위치 파악(Geo-location)`이나 보안 목적으로만 보조적으로 활용됩니다.



**3️⃣ 사용자 로그인 인증 (Authentication)**

* 원리: 사용자가 이름/비밀번호를 제출하여 서버로부터 인증을 받습니다.
* 특징: 인증 후에는 쿠키나 `토큰(Token)`을 사용하여 상태를 유지합니다.
* 2025년 현황: 로그인 시 <mark style="color:red;">OAuth 2.0이나 OpenID Connect</mark> 같은 표준 인증 프레임워크와 JWT(JSON Web Token) 같은 기술을 사용하여 안전하고 **효율적으로 세션을 관리하는 것이 일반적**입니다.



**4️⃣ URL에 식별자 포함 (Fat URLs)**

* 원리: URL 자체에 세션 ID와 같은 식별자 정보를 추가하여, 클라이언트가 링크를 클릭할 때마다 서버로 정보를 전달합니다.
  * 예: `http://example.com/page.html;sessionid=12345`
* 단점:
  * URL이 지저분해집니다.
  * 사용자가 링크를 공유하거나 저장할 때 식별 정보도 함께 유출될 위험이 있습니다.
  * 사이트를 벗어나면 추적이 끊어집니다.
* 2025년 현황: 보안 및 편의성 문제로 인해 일반적인 웹사이트에서는 거의 사용되지 않으며, `특정 추적 링크(Tracker Link)`나 임시적인 세션 유지 목적으로 제한적으로 사용됩니다.



**5️⃣ 사용자 식별 관련 HTTP 헤더**

* 원리: HTTP 요청 헤더 필드에 클라이언트 정보를 포함하여 전달합니다.
  * 예: `From`, `User-Agent`, `Referer`, `Cookie` 헤더 등이 있습니다.
* 2025년 현황:
  * `User-Agent`는 여전히 사용되지만, 브라우저가 개인 정보 보호를 위해 정보를 축소(User-Agent Reduction)하고 있습니다.
  * `Referer`는 `Referrer-Policy`를 통해 어떤 정보를 보낼지 제어하는 방향으로 강화되었습니다.
  * `Cookie` 헤더는 쿠키 기술의 핵심입니다.



### 🤝 상태 유지(Stateful) 프로토콜의 특징(http와  반대되는  개념)

{% hint style="success" %}
상태를 가진다는 것은 이전 통신(트랜잭션)의 맥락이나 데이터를 기억하고, 이를 바탕으로 다음 통신을 처리한다는 의미입니다.
{% endhint %}

#### 1) 상태 유지(Stateful) 프로토콜의 특징

상태 유지 프로토콜은 연결이 지속되는 동안 서버가 클라이언트의 상태 정보를 기억하고 유지합니다.

* 기억 장치: 서버는 클라이언트와의 연결에 대한 세션(Session) 또는 상태(State) 정보를 메모리나 데이터베이스에 저장합니다.
* 맥락 유지: 클라이언트가 새로운 요청을 보낼 때마다 서버는 저장된 상태 정보를 참조하여, 이 요청이 이전 요청의 연속선상에 있음을 인식합니다.
* 효율성 (일부 측면): 연결이 유지되는 동안 매번 새로운 인증이나 초기 설정을 할 필요가 없어 효율적일 수 있습니다.
* 단점: 서버 자원(메모리 등)을 많이 사용하며, 서버 장애 발생 시 저장된 세션 정보가 유실될 위험이 있습니다. 또한, 여러 서버가 하나의 세션을 공유해야 할 때 복잡해집니다.

#### 2) 주요 상태 유지(Stateful) 프로토콜 예시

상태 유지 프로토콜은 일반적으로 지속적인 연결과 상호작용이 필요한 분야에서 사용됩니다.

**1. TCP (Transmission Control Protocol)**

* 역할: 인터넷에서 데이터 전송을 보장하는 프로토콜입니다. HTTP와 같은 상위 프로토콜의 기반이 됩니다.
* 상태 유지 방식: TCP는 데이터를 보내기 전 클라이언트와 서버 간에 <mark style="color:orange;">3-way handshake를 통해 연결</mark>(세션)을 설정하고, 데이터의 순서, 재전송 여부 등을 지속적으로 관리합니다. 이 연결 상태가 바로 TCP 세션 상태입니다.



**2. FTP (File Transfer Protocol)**

* 역할: 파일 전송에 사용됩니다.
* 상태 유지 방식: FTP는 파일을 전송하기 위해 **클라이언트가 서버에 로그인하고 세션을 시작**합니다. 이 세션이 유지되는 동안 서버는 클라이언트의 현재 작업 디렉토리, 권한, 전송 모드 등의 상태를 기억합니다.



**3. Telnet / SSH (Secure Shell)**

* 역할: 원격 터미널 접속에 사용됩니다.
* 상태 유지 방식: 사용자가 **로그인하여** `세션`을 열면, 서버는 사용자의 셸 환경, 현재 명령 상태, 사용자 권한 등을 **세션이 종료될 때까지 유지합니다.**



**4. WebSocket**

* 역할: 웹 브라우저와 서버 간에 지속적인 양방향 통신 채널을 제공합니다.
* 상태 유지 방식: WebSocket은 한 번 연결이 수립되면 서버와 클라이언트가 서로 메시지를 주고받을 수 있는 영구적인 연결 상태를 유지합니다. 이는 채팅, 실시간 게임, 푸시 알림 등 실시간 상호작용이 필수적인 곳에 사용됩니다.



**5. SMTP (Simple Mail Transfer Protocol)**

* 역할: 이메일 전송에 사용됩니다.
* 상태 유지 방식: SMTP 서버는 메일을 전송하는 동안 발신자, 수신자, 데이터 전송 단계 등의 상태를 순차적으로 처리하고 기억합니다.



### 💡 더 알면 좋을 것들: 최신 상태 관리 기술

2025년 현재, 쿠키 외에도 브라우저에 데이터를 저장하고 상태를 유지하는 더 많은 기술이 사용됩니다.

* **로컬 스토리지 & 세션 스토리지 (Web Storage):** 브라우저에 대용량의 데이터를 저장할 수 있도록 HTML5에서 도입되었습니다. <mark style="color:red;">쿠키처럼 매 요청마다 서버로 전송되지 않아 성능상 이점이 있으며, 비민감한 데이터 저장에 널리 쓰입니다.</mark>
* **인덱스드DB (IndexedDB):** 브라우저 내부에 구조화된 대용량 데이터를 저장하기 위한 **로컬 데이터베이스**입니다.
* **토큰 기반 인증 (JWT):** 사용자 인증 정보를 암호화된 토큰 형태로 클라이언트에 저장하고, 이 토큰을 매 요청의 `Authorization` 헤더에 넣어 서버와 통신하는 방식입니다. 이는 무상태 서비스(API 서버)를 구축하는 데 매우 적합한 현대적인 방법입니다.



## 2. 사용자 정보를 전달하는 초기 HTTP 요청 헤더

표 11-1에 언급된 헤더 중 `From`, `User-Agent`, `Referer` 헤더는 초기에 사용자 정보를 전달하는 목적으로 사용되었으나, 현재는 그 역할과 보안 제약이 크게 달라졌습니다.

### From 헤더 (From Header)

| **항목**   | **내용**                                                                                          |
| -------- | ----------------------------------------------------------------------------------------------- |
| 목적       | 사용자의 **이메일 주소를 포함하여 사용자 식별**을 시도.                                                               |
| 문제점      | 악의적인 서버가 이메일 주소를 수집하여 <mark style="background-color:$primary;">스팸 발송에 악용하는 문제 발생.</mark>        |
| 2025년 현황 | 사용되지 않음. 개인정보 보호 문제로 인해 대부분의 최신 브라우저는 이 헤더를 전송하지 않습니다. 로봇/스파이더도 이메일 주소 대신 다른 식별자나 연락 수단을 사용합니다. |

### User-Agent 헤더 (User-Agent Header)

| **항목**   | **내용**                                                                                                                                                                                                                 |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목적       | 사용자가 사용하는 **브라우저 이름, 버전, 운영체제 등의 정보를 서버**에 전달.                                                                                                                                                                         |
| 용도       | 서버가 클라이언트의 기능에 맞게 콘텐츠를 최적화하거나, 버그 방지 등을 위해 사용됨.                                                                                                                                                                        |
| 식별 한계    | 여러 사용자가 같은 브라우저와 OS를 사용하므로, 특정 사용자를 식별하는 데는 큰 도움 안 됨 (지문(Fingerprinting)에는 사용될 수 있음).                                                                                                                                  |
| 2025년 현황 | 정보 축소(User-Agent Reduction): 개인 정보 보호 및 브라우저 지문 방지 목적으로, Google Chrome을 비롯한 주요 브라우저는 이 헤더를 통해 전달하는 정보를 점진적으로 축소하고 있습니다. 대신 <mark style="color:red;">Client Hints와 같은 더 세분화된 방법을 통해 필요한 정보만 서버에 전달하도록 유도하고 있습니다.</mark> |

### Referer 헤더 (Referer Header)

| **항목**   | **내용**                                                                                                                                                                 |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목적       | 사용자가 현재 페이지로 **유입된 직전 웹페이지의 URI**를 가리킴.                                                                                                                                |
| 용도       | 사용자의 이전 방문 경로를 파악하여 웹 사용 행태나 취향을 유추 (예: 야구 애호가 유추).                                                                                                                    |
| 오타 수정    | 헤더 이름은 원래 `Referrer`가 올바른 철자이지만, HTTP 명세 초기에 오타로 `Referer`로 기록되어 지금까지 유지되고 있습니다.                                                                                       |
| 2025년 현황 | Referrer Policy 강화: 개인 정보 보호를 위해 `Referrer-Policy` 헤더를 사용하여 Referer 정보를 언제, 얼마나 전송할지 통제합니다. 민감한 정보(예: HTTPS에서 HTTP로)나 긴 경로 정보의 유출을 막기 위해 기본적으로 전송되는 정보의 양을 제한하는 추세입니다. |

### 결론: 식별 정보의 한계와 진화

{% hint style="danger" %}
제시된 세 헤더는 모두 사용자의 환경이나 행동의 단편적인 정보만을 제공할 뿐, 특정 개인을 확실하게 식별하기에는 부족합니다.
{% endhint %}

이러한 한계 때문에 웹사이트 설계자들은 `Cookie`, `Authorization`, 그리고 IP 주소를 추적하는 `Client-ip` 및 `X-Forwarded-For`와 같은 더 정확하고 지속적인 식별 기술을 개발하게 되었으며, 이는 다음 절에서 다루게 될 내용입니다. 특히 `Cookie`는 현재까지도 웹의 상태 유지를 위한 가장 기본적인 메커니즘으로 사용되고 있습니다.

## 3. 클라이언트 IP 주소를 통한 사용자 식별의 약점과 현재

초기 웹에서 사용자 식별을 위해 클라이언트 IP 주소를 사용하려던 시도는 현대 웹 환경의 구조적 특성 때문에 효과적이지 못하며, 현재는 거의 사용되지 않는 방식입니다.&#x20;

> 이 방식은 개인이 아닌 **컴퓨터를 식별**하며, <mark style="color:red;">동적 IP 할당, NAT, 그리고 HTTP 프록시의 보편적 사용이라는 세 가지 주요 약점</mark> 때문에 실패했습니다.

클라이언트의 IP 주소를 통해 사용자를 식별하는 방식이 실패한 주요 약점들을 현재(2025년)의 관점에서 정리했습니다.

#### 1) 사용자의 부정확성: IP는 '컴퓨터'를 가리킨다

* 약점: IP 주소는 사용하는 컴퓨터를 가리키므로, 여러 사용자가 <mark style="color:red;">하나의 컴퓨터를 공유할 경우 개별 사용자를 식별할 수 없습니다.</mark>
* 현재 현황: 특히 공용 컴퓨터(도서관, PC방, 회사 공용 워크스테이션) 환경에서는 식별이 불가능하며, 개인화된 서비스에는 전혀 적합하지 않습니다.

#### 2) 동적 IP 주소 할당 (Dynamic IP)

* 약점: 대부분의 ISP(인터넷 서비스 제공자)는 비용 효율성을 위해 **사용자에게 접속할 때마다 IP 주소를 동적으로 할당**합니다. 사용자가 <mark style="color:red;">재로그인할 때마다 다른 IP를 받으면, 웹 서버는 동일한 사용자를 IP 주소만으로 추적할 수 없습니다.</mark>
* 현재 현황: 모바일 환경에서는 사용자가 이동하거나 네트워크를 전환할 때 IP가 자주 바뀌므로, IP 기반 식별의 신뢰도는 더욱 낮아졌습니다.

#### 3) 네트워크 주소 변환 (NAT) 방화벽의 확산

* 약점: NAT 장비는 사설 네트워크에 있는 여러 클라이언트의 실제 IP 주소를 숨기고, **외부에는 방화벽이 사용하는 하나의 공인 IP 주소로만 통신**합니다. 웹 서버는 실제 클라이언트 IP 대신 이 방화벽의 IP만 보게 됩니다.
* 현재 현황: 가정용 공유기부터 대규모 기업 네트워크까지 NAT는 보편적으로 사용되고 있어, 수많은 사용자가 하나의 공인 IP를 공유하게 되므로 IP 기반 식별을 불가능하게 만듭니다.

#### 4) HTTP 프록시 및 게이트웨이의 개입

<figure><img src="../../../../.gitbook/assets/image (426).png" alt=""><figcaption></figcaption></figure>

* 약점: 클라이언트와 원 서버 사이에 프록시(Proxy) 서버가 있는 경우, **원 서버는 클라이언트의 IP 주소 대신 프록시 서버의 IP 주소를 보게 됩니다.**
* 해결 시도: 이 문제를 해결하기 위해 일부 프록시는 `Client-ip`나 `X-Forwarded-For` 같은 확장 헤더를 추가하여 실제 클라이언트 IP를 전달하려 했으나, 모든 프록시가 이를 따르는 것은 아니었습니다.
  * 2025년 현황: `X-Forwarded-For` 헤더는 사실상 표준처럼 널리 사용되고 있으며, 더 공식적인 대체 헤더로 `Forwarded` 헤더도 사용됩니다. 그러나 이 헤더들은 조작이 가능하므로, 보안 목적으로는 최종 프록시나 방화벽의 IP만 신뢰하는 것이 일반적입니다.

### 💡 결론 및 현재의 활용

현재(2025년) 클라이언트 IP 주소를 이용한 사용자 식별은 주된 방법으로 사용되지 않습니다.

* 보안 목적의 제한적 사용: 여전히 일부 웹사이트나 인트라넷에서는 특정 IP 대역에서만 접근을 허용하는 접근 제어(Access Control) 기능으로 IP 주소를 사용합니다.
* 추적 및 분석의 보조 수단: 웹 분석에서는 IP 주소를 대략적인 지리적 위치 파악이나 악성 요청 탐지 등 보조적인 수단으로 활용합니다.

> 이러한 IP 기반 식별의 한계 때문에, 웹은 `쿠키(Cookie)`와 같은 더 정확하고 유연하며 애플리케이션 계층에서 동작하는 식별 기술로 발전하게 되었습니다.

## 4. HTTP 인증을 통한 사용자 식별 (로그인)

IP 주소 추적과 같은 수동적인 방식과 달리, HTTP 인증은 **사용자 이름과 비밀번호를 사용하여 사용자에게 명시적인 식별 요청을 하는 방식**입니다.

### 1) HTTP 인증의 기본 작동 단계

<figure><img src="../../../../.gitbook/assets/image (427).png" alt=""><figcaption></figcaption></figure>

1. 클라이언트 요청 (a): 브라우저가 보호된 리소스(`GET /index.html`)를 요청합니다.
2. 서버의 인증 요청 (b): 서버가 사용자 식별 정보를 알지 못하면, `401 Login Required` 응답 코드와 함께 `WWW-Authenticate` 헤더를 반환하여 로그인하라고 요청합니다. (`WWW-Authenticate: Basic realm="..."`)
3. 클라이언트의 재요청 (c): 브라우저는 사용자에게 로그인 대화 상자를 띄우고, 사용자가 입력한 정보를 바탕으로 기존 요청에 `Authorization` 헤더를 추가하여 재전송합니다. (`Authorization: Basic [인증 정보]`)
   * 인증 정보: 일반적으로 사용자 이름과 비밀번호를 `:`로 연결한 후 Base64로 인코딩한 문자열입니다.
4. 서버의 성공 응답 (d): 서버가 인증 정보를 확인하고 사용자 식별에 성공하면, 요청한 리소스와 함께 `200 OK` 응답을 반환합니다.

### 2) HTTP 인증의 특징 및 한계

| **특징**      | **내용**                                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 지속적인 식별     | 일단 로그인하면, 브라우저는 해당 사이트로 보내는 모든 후속 요청에 `Authorization` 헤더를 자동으로 포함하여 보내므로, 세션 내내 사용자 식별이 유지됩니다.                               |
| 보안 문제 (취약점) | HTTP 기본 인증(Basic Authentication)에서 `Authorization` 헤더의 내용은 Base64로 인코딩될 뿐, 암호화되지 않습니다. 네트워크상의 관찰자가 쉽게 해독할 수 있어 보안에 매우 취약합니다. |
| 사용자 불편      | 사용자가 사이트마다 별도의 로그인을 해야 하며, 각 사이트별로 다른 계정 정보를 기억해야 하는 불편함이 있습니다.                                                              |

### 3) 2025년의 HTTP 인증과 보안 강화

제시된 텍스트의 HTTP 기본 인증은 현재(2025년) 단독으로 사용되지 않습니다. 보안 취약점과 사용자 경험 문제가 심각하기 때문입니다.

**1. 전송 보안의 필수화 (HTTPS)**

* 보안 강화: HTTP 기본 인증이 가진 근본적인 문제(쉽게 해독되는 Base64 인코딩)를 해결하기 위해, 모든 웹사이트는 TLS/SSL 암호화를 사용하는 <mark style="color:red;">HTTPS를 필수적으로 적용</mark>합니다. HTTPS를 사용하면 `Authorization` 헤더를 포함한 전체 통신이 암호화되어 중간자 공격으로부터 보호됩니다.

**2. 현대 웹에서의 인증 대체 기술**

사용자 편의성과 보안을 개선하기 위해 더 발전된 인증 및 세션 관리 방식이 주로 사용됩니다.

* 세션 쿠키 (Session Cookies): 로그인 후 사용자 ID나 세션 토큰을 암호화된 쿠키에 저장하여, 매 요청마다 이 쿠키를 서버로 전송해 세션을 유지하는 방식이 가장 일반적입니다.
* 토큰 기반 인증 (JWT): API 서버나 마이크로서비스 환경에서 로그인 후 **JSON Web Token (JWT)**&#xC744; 발급하고, 클라이언트가 이 토큰을 `Authorization: Bearer <Token>` 형태로 전송하여 인증하는 방식이 널리 사용됩니다.
* SSO (Single Sign-On): "프레드가 사이트를 옮겨다닐 때마다 로그인해야 하는 문제"를 해결하기 위해, OAuth 2.0 및 OpenID Connect와 같은 표준 프로토콜을 사용하여 구글, 네이버, 카카오 등 하나의 계정으로 여러 사이트에 로그인할 수 있는 <mark style="color:red;">SSO 방식이 대세입니다.</mark>
* 2단계 인증 (2FA/MFA): 비밀번호 외에 추가적인 인증 수단(SMS, 앱 토큰 등)을 요구하여 보안을 극대화합니다.

## 5.  뚱뚱한 URL (Fat URLs)을 통한 사용자 식별

> 뚱뚱한 URL은 HTTP가 무상태(Stateless)인 문제를 해결하기 위해 URL 자체에 사용자 상태 정보(식별자)를 삽입하여 세션을 유지하려 했던 초기 웹 기술입니다.

### 1) 작동 원리

* 식별자 추가: 사용자가 웹사이트에 처음 방문하면 **고유한 ID가 생성**됩니다.
* URL 확장: 이 ID(예: `002-1145265-8016838`)를 모든 하이퍼링크의 URL 경로 뒤에 동적으로 추가합니다.
* 상태 유지: 사용자가 사이트 내 링크를 클릭할 때마다 ID가 포함된 뚱뚱한 URL이 서버로 전송되고, 서버는 이 ID를 통해 사용자 정보(장바구니, 프로필 등)를 조회하여 세션을 유지합니다.\


```
<a href="/exec/obidos/wishlist/ref=gr_pl1_/002-1145265-8016838">Wish Listc</a><br>
```

### 2) 뚱뚱한 URL의 심각한 문제점 (사용하지 않는 이유)

| **문제점**       | **상세 설명**                                                                                                                             | **2025년 현황에 미치는 영향**                                   |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| 못생긴 URL (혼란)  | 브라우저 주소창에 <mark style="color:red;">긴 식별자가 노출</mark>되어 새로운 사용자에게 혼란을 주고 URL의 가독성을 해칩니다.                                                | 사용자 경험(UX)을 크게 저해하여 현대 웹에서는 용인되지 않습니다.                 |
| 공유하지 못하는 URL  | URL에 특정 사용자의 개인 세션 정보가 포함되어 있어, <mark style="color:red;">이 URL을 타인에게 공유하면 개인 정보가 유출</mark>되거나, 공유 받은 사람이 원래 사용자의 세션 상태를 그대로 물려받게 됩니다. | 개인 정보 보호 및 보안 관점에서 용납될 수 없는 치명적인 문제입니다.                |
| 캐시를 사용할 수 없음  | 식별자가 추가되어 URL이 매번 달라지기 때문에, 서버는 이미 콘텐츠를 저장하고 있는 기존 캐시(Cache)에 접근할 수 없습니다.                                                             | 서버 부하 가중을 초래하고 웹 성능을 심각하게 저하시켜 대규모 트래비스 처리 능력을 떨어뜨립니다. |
| 서버 부하 가중      | URL이 바뀔 때마다 서버는 HTML 페이지를 다시 그려야 하므로 서버 자원 소모가 큽니다.                                                                                   | 성능과 확장성이 중요한 현대 웹 환경에서 비효율적입니다.                        |
| 이탈 (Breakage) | 사용자가 세션 정보가 추가되지 않은 링크를 클릭하거나, 외부 사이트로 이동했다가 되돌아오면 세션 정보가 손실되어 처음부터 다시 시작해야 합니다.                                                      | 서비스 사용의 연속성을 해쳐 사용자 이탈률을 높입니다.                         |
| 세션 간 지속성의 부재  | 사용자가 로그아웃하거나 브라우저를 닫으면, 북마크된 뚱뚱한 URL을 제외하고는 모든 정보를 잃게 되어 세션 정보를 영구적으로 유지할 수 없습니다.                                                     |                                                        |

### 💡 현재의 대체 기술 (2025년)

뚱뚱한 URL의 모든 문제점은 HTTP 쿠키와 토큰 기반 인증 기술을 통해 해결되었습니다.

* HTTP 쿠키 (Cookies):
  * 해결: 사용자 식별자를 URL 대신 클라이언트의 브라우저에 저장하고 자동으로 요청 헤더를 통해 전송합니다. URL은 깨끗하게 유지되고, 캐시 효율이 높아집니다.
  * 현황: 여전히 세션 관리에 가장 널리 쓰이는 표준입니다.
* 토큰 기반 인증 (JWT / Session Tokens):
  * 해결: URL과는 별도로 암호화된 토큰을 사용하여 안전하게 사용자 세션을 식별합니다.
  * 현황: 보안 및 확장성이 요구되는 API 및 모바일 환경에서 선호됩니다.

{% hint style="success" %}
결론적으로, 뚱뚱한 URL은 한때 사용자를 추적하는 방법이었으나, **보안, 성능, 사용자 경험 등 모든 측면에서 현대 웹의 요구 사항을 충족하지 못하여 역사 속으로 사라진 기술**입니다.
{% endhint %}

