# 11장 클라이언트 식별과 쿠키

`웹 서버`는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다. 이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 **서버와 통신하고 있는 클라이언트를 추적해야 할 수도 있다.**

<figure><img src="../../../../.gitbook/assets/image (425).png" alt=""><figcaption></figcaption></figure>

## 1. 개별 접촉

### 🍪 HTTP 클라이언트 식별 및 상태 유지 기술

#### 1) HTTP의 기본 특성: 무상태 (Stateless)

* 정의: HTTP는 기본적으로 **상태가 없는(Stateless) 프로토콜**입니다. 각 요청(Request)과 응답(Response)은 서로 독립적이며, 서버는 클라이언트가 보낸 이전 요청에 대한 정보를 유지하지 않습니다.
* 문제점: 이러한 무상태 특성 때문에, 웹사이트는 사용자의 연속적인 상호작&#xC6A9;**(예: 온라인 쇼핑몰의 장바구니 기능)**&#xC744; 추적하거나, 개인 맞춤형 서비스를 제공하기 어렵습니다.

#### 2) 개인화된 서비스의 필요성 (현대 웹의 목표)

현대 웹사이트들은 다음과 같은 개인화된 경험을 제공하기 위해 사용자를 식별해야 합니다.

* 개별 인사: 사용자 이름이 포함된 환영 메시지 등 맞춤형 페이지 제공.
* 사용자 맞춤 추천: 과거 행동 및 관심사를 분석하여 예상되는 제품이나 콘텐츠 추천.
* 저장된 사용자 정보 활용: 주소, 신용카드 정보 등을 저장하여 매번 재입력할 필요 없이 편리한 쇼핑 환경 제공.

#### 3) 사용자 식별을 위한 주요 기술 (최신화 포함)

HTTP의 무상태 문제를 극복하고 사용자를 식별하기 위해 고안된 기술들입니다.

**1️⃣ HTTP 쿠키 (Cookies) — 가장 널리 쓰이는 표준**

* 원리: 서버가 <mark style="color:red;">클라이언트에 작은 데이터를 저장</mark>하게 한 뒤, 클라이언트가 매 요청마다 이 데이터를 서버로 다시 전송하게 하여 상태를 유지합니다.
* 특징: 강력하면서도 효율적으로 식별 정보를 지속 유지할 수 있는 사실상의 표준입니다.
* 2025년 현황:
  * 프라이버시 강화: 쿠키는 여전히 널리 쓰이지만, 개인정보 보호 강화 추세(GDPR, CCPA 등)와 브라우저 정책(Chrome의 서드파티 쿠키 단계적 폐지)으로 인해 서드파티 쿠키 사용은 대폭 축소되거나 금지되고 있습니다.
  * 대체 기술: 마케팅 목적으로는 퍼스트파티 쿠키와 더불어, 서버에서 사용자 ID를 생성하고 트래킹하는 <mark style="color:red;">서버사이드 트래킹 기술</mark>이 부상하고 있습니다.



**2️⃣ 클라이언트 IP 주소 추적 (IP Address Tracking)**

* 원리: 요청을 보낸 클라이언트의 IP 주소를 통해 사용자를 식별합니다.
* 단점:
  * IP 주소가 자주 바뀔 수 있습니다. (예: 모바일 네트워크, ISP)
  * 여러 사용자(예: 회사, 학교)가 하나의 NAT를 통해 동일한 공인 IP를 공유할 수 있습니다.
  * 프록시 서버 뒤에 있는 사용자는 서버에 프록시의 IP만 보입니다.
* 2025년 현황: 단독으로는 사용자 식별의 정확도가 낮아, `지리적 위치 파악(Geo-location)`이나 보안 목적으로만 보조적으로 활용됩니다.



**3️⃣ 사용자 로그인 인증 (Authentication)**

* 원리: 사용자가 이름/비밀번호를 제출하여 서버로부터 인증을 받습니다.
* 특징: 인증 후에는 쿠키나 `토큰(Token)`을 사용하여 상태를 유지합니다.
* 2025년 현황: 로그인 시 <mark style="color:red;">OAuth 2.0이나 OpenID Connect</mark> 같은 표준 인증 프레임워크와 JWT(JSON Web Token) 같은 기술을 사용하여 안전하고 **효율적으로 세션을 관리하는 것이 일반적**입니다.



**4️⃣ URL에 식별자 포함 (Fat URLs)**

* 원리: URL 자체에 세션 ID와 같은 식별자 정보를 추가하여, 클라이언트가 링크를 클릭할 때마다 서버로 정보를 전달합니다.
  * 예: `http://example.com/page.html;sessionid=12345`
* 단점:
  * URL이 지저분해집니다.
  * 사용자가 링크를 공유하거나 저장할 때 식별 정보도 함께 유출될 위험이 있습니다.
  * 사이트를 벗어나면 추적이 끊어집니다.
* 2025년 현황: 보안 및 편의성 문제로 인해 일반적인 웹사이트에서는 거의 사용되지 않으며, `특정 추적 링크(Tracker Link)`나 임시적인 세션 유지 목적으로 제한적으로 사용됩니다.



**5️⃣ 사용자 식별 관련 HTTP 헤더**

* 원리: HTTP 요청 헤더 필드에 클라이언트 정보를 포함하여 전달합니다.
  * 예: `From`, `User-Agent`, `Referer`, `Cookie` 헤더 등이 있습니다.
* 2025년 현황:
  * `User-Agent`는 여전히 사용되지만, 브라우저가 개인 정보 보호를 위해 정보를 축소(User-Agent Reduction)하고 있습니다.
  * `Referer`는 `Referrer-Policy`를 통해 어떤 정보를 보낼지 제어하는 방향으로 강화되었습니다.
  * `Cookie` 헤더는 쿠키 기술의 핵심입니다.



### 🤝 상태 유지(Stateful) 프로토콜의 특징(http와  반대되는  개념)

{% hint style="success" %}
상태를 가진다는 것은 이전 통신(트랜잭션)의 맥락이나 데이터를 기억하고, 이를 바탕으로 다음 통신을 처리한다는 의미입니다.
{% endhint %}

#### 1) 상태 유지(Stateful) 프로토콜의 특징

상태 유지 프로토콜은 연결이 지속되는 동안 서버가 클라이언트의 상태 정보를 기억하고 유지합니다.

* 기억 장치: 서버는 클라이언트와의 연결에 대한 세션(Session) 또는 상태(State) 정보를 메모리나 데이터베이스에 저장합니다.
* 맥락 유지: 클라이언트가 새로운 요청을 보낼 때마다 서버는 저장된 상태 정보를 참조하여, 이 요청이 이전 요청의 연속선상에 있음을 인식합니다.
* 효율성 (일부 측면): 연결이 유지되는 동안 매번 새로운 인증이나 초기 설정을 할 필요가 없어 효율적일 수 있습니다.
* 단점: 서버 자원(메모리 등)을 많이 사용하며, 서버 장애 발생 시 저장된 세션 정보가 유실될 위험이 있습니다. 또한, 여러 서버가 하나의 세션을 공유해야 할 때 복잡해집니다.

#### 2) 주요 상태 유지(Stateful) 프로토콜 예시

상태 유지 프로토콜은 일반적으로 지속적인 연결과 상호작용이 필요한 분야에서 사용됩니다.

**1. TCP (Transmission Control Protocol)**

* 역할: 인터넷에서 데이터 전송을 보장하는 프로토콜입니다. HTTP와 같은 상위 프로토콜의 기반이 됩니다.
* 상태 유지 방식: TCP는 데이터를 보내기 전 클라이언트와 서버 간에 <mark style="color:orange;">3-way handshake를 통해 연결</mark>(세션)을 설정하고, 데이터의 순서, 재전송 여부 등을 지속적으로 관리합니다. 이 연결 상태가 바로 TCP 세션 상태입니다.



**2. FTP (File Transfer Protocol)**

* 역할: 파일 전송에 사용됩니다.
* 상태 유지 방식: FTP는 파일을 전송하기 위해 **클라이언트가 서버에 로그인하고 세션을 시작**합니다. 이 세션이 유지되는 동안 서버는 클라이언트의 현재 작업 디렉토리, 권한, 전송 모드 등의 상태를 기억합니다.



**3. Telnet / SSH (Secure Shell)**

* 역할: 원격 터미널 접속에 사용됩니다.
* 상태 유지 방식: 사용자가 **로그인하여** `세션`을 열면, 서버는 사용자의 셸 환경, 현재 명령 상태, 사용자 권한 등을 **세션이 종료될 때까지 유지합니다.**



**4. WebSocket**

* 역할: 웹 브라우저와 서버 간에 지속적인 양방향 통신 채널을 제공합니다.
* 상태 유지 방식: WebSocket은 한 번 연결이 수립되면 서버와 클라이언트가 서로 메시지를 주고받을 수 있는 영구적인 연결 상태를 유지합니다. 이는 채팅, 실시간 게임, 푸시 알림 등 실시간 상호작용이 필수적인 곳에 사용됩니다.



**5. SMTP (Simple Mail Transfer Protocol)**

* 역할: 이메일 전송에 사용됩니다.
* 상태 유지 방식: SMTP 서버는 메일을 전송하는 동안 발신자, 수신자, 데이터 전송 단계 등의 상태를 순차적으로 처리하고 기억합니다.



### 💡 더 알면 좋을 것들: 최신 상태 관리 기술

2025년 현재, 쿠키 외에도 브라우저에 데이터를 저장하고 상태를 유지하는 더 많은 기술이 사용됩니다.

* **로컬 스토리지 & 세션 스토리지 (Web Storage):** 브라우저에 대용량의 데이터를 저장할 수 있도록 HTML5에서 도입되었습니다. <mark style="color:red;">쿠키처럼 매 요청마다 서버로 전송되지 않아 성능상 이점이 있으며, 비민감한 데이터 저장에 널리 쓰입니다.</mark>
* **인덱스드DB (IndexedDB):** 브라우저 내부에 구조화된 대용량 데이터를 저장하기 위한 **로컬 데이터베이스**입니다.
* **토큰 기반 인증 (JWT):** 사용자 인증 정보를 암호화된 토큰 형태로 클라이언트에 저장하고, 이 토큰을 매 요청의 `Authorization` 헤더에 넣어 서버와 통신하는 방식입니다. 이는 무상태 서비스(API 서버)를 구축하는 데 매우 적합한 현대적인 방법입니다.



## 2. 사용자 정보를 전달하는 초기 HTTP 요청 헤더

표 11-1에 언급된 헤더 중 `From`, `User-Agent`, `Referer` 헤더는 초기에 사용자 정보를 전달하는 목적으로 사용되었으나, 현재는 그 역할과 보안 제약이 크게 달라졌습니다.

### From 헤더 (From Header)

| **항목**   | **내용**                                                                                          |
| -------- | ----------------------------------------------------------------------------------------------- |
| 목적       | 사용자의 **이메일 주소를 포함하여 사용자 식별**을 시도.                                                               |
| 문제점      | 악의적인 서버가 이메일 주소를 수집하여 <mark style="background-color:$primary;">스팸 발송에 악용하는 문제 발생.</mark>        |
| 2025년 현황 | 사용되지 않음. 개인정보 보호 문제로 인해 대부분의 최신 브라우저는 이 헤더를 전송하지 않습니다. 로봇/스파이더도 이메일 주소 대신 다른 식별자나 연락 수단을 사용합니다. |

### User-Agent 헤더 (User-Agent Header)

| **항목**   | **내용**                                                                                                                                                                                                                 |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목적       | 사용자가 사용하는 **브라우저 이름, 버전, 운영체제 등의 정보를 서버**에 전달.                                                                                                                                                                         |
| 용도       | 서버가 클라이언트의 기능에 맞게 콘텐츠를 최적화하거나, 버그 방지 등을 위해 사용됨.                                                                                                                                                                        |
| 식별 한계    | 여러 사용자가 같은 브라우저와 OS를 사용하므로, 특정 사용자를 식별하는 데는 큰 도움 안 됨 (지문(Fingerprinting)에는 사용될 수 있음).                                                                                                                                  |
| 2025년 현황 | 정보 축소(User-Agent Reduction): 개인 정보 보호 및 브라우저 지문 방지 목적으로, Google Chrome을 비롯한 주요 브라우저는 이 헤더를 통해 전달하는 정보를 점진적으로 축소하고 있습니다. 대신 <mark style="color:red;">Client Hints와 같은 더 세분화된 방법을 통해 필요한 정보만 서버에 전달하도록 유도하고 있습니다.</mark> |

### Referer 헤더 (Referer Header)

| **항목**   | **내용**                                                                                                                                                                 |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목적       | 사용자가 현재 페이지로 **유입된 직전 웹페이지의 URI**를 가리킴.                                                                                                                                |
| 용도       | 사용자의 이전 방문 경로를 파악하여 웹 사용 행태나 취향을 유추 (예: 야구 애호가 유추).                                                                                                                    |
| 오타 수정    | 헤더 이름은 원래 `Referrer`가 올바른 철자이지만, HTTP 명세 초기에 오타로 `Referer`로 기록되어 지금까지 유지되고 있습니다.                                                                                       |
| 2025년 현황 | Referrer Policy 강화: 개인 정보 보호를 위해 `Referrer-Policy` 헤더를 사용하여 Referer 정보를 언제, 얼마나 전송할지 통제합니다. 민감한 정보(예: HTTPS에서 HTTP로)나 긴 경로 정보의 유출을 막기 위해 기본적으로 전송되는 정보의 양을 제한하는 추세입니다. |

### 결론: 식별 정보의 한계와 진화

{% hint style="danger" %}
제시된 세 헤더는 모두 사용자의 환경이나 행동의 단편적인 정보만을 제공할 뿐, 특정 개인을 확실하게 식별하기에는 부족합니다.
{% endhint %}

이러한 한계 때문에 웹사이트 설계자들은 `Cookie`, `Authorization`, 그리고 IP 주소를 추적하는 `Client-ip` 및 `X-Forwarded-For`와 같은 더 정확하고 지속적인 식별 기술을 개발하게 되었으며, 이는 다음 절에서 다루게 될 내용입니다. 특히 `Cookie`는 현재까지도 웹의 상태 유지를 위한 가장 기본적인 메커니즘으로 사용되고 있습니다.

## 3. 클라이언트 IP 주소를 통한 사용자 식별의 약점과 현재

초기 웹에서 사용자 식별을 위해 클라이언트 IP 주소를 사용하려던 시도는 현대 웹 환경의 구조적 특성 때문에 효과적이지 못하며, 현재는 거의 사용되지 않는 방식입니다.&#x20;

> 이 방식은 개인이 아닌 **컴퓨터를 식별**하며, <mark style="color:red;">동적 IP 할당, NAT, 그리고 HTTP 프록시의 보편적 사용이라는 세 가지 주요 약점</mark> 때문에 실패했습니다.

클라이언트의 IP 주소를 통해 사용자를 식별하는 방식이 실패한 주요 약점들을 현재(2025년)의 관점에서 정리했습니다.

#### 1) 사용자의 부정확성: IP는 '컴퓨터'를 가리킨다

* 약점: IP 주소는 사용하는 컴퓨터를 가리키므로, 여러 사용자가 <mark style="color:red;">하나의 컴퓨터를 공유할 경우 개별 사용자를 식별할 수 없습니다.</mark>
* 현재 현황: 특히 공용 컴퓨터(도서관, PC방, 회사 공용 워크스테이션) 환경에서는 식별이 불가능하며, 개인화된 서비스에는 전혀 적합하지 않습니다.

#### 2) 동적 IP 주소 할당 (Dynamic IP)

* 약점: 대부분의 ISP(인터넷 서비스 제공자)는 비용 효율성을 위해 **사용자에게 접속할 때마다 IP 주소를 동적으로 할당**합니다. 사용자가 <mark style="color:red;">재로그인할 때마다 다른 IP를 받으면, 웹 서버는 동일한 사용자를 IP 주소만으로 추적할 수 없습니다.</mark>
* 현재 현황: 모바일 환경에서는 사용자가 이동하거나 네트워크를 전환할 때 IP가 자주 바뀌므로, IP 기반 식별의 신뢰도는 더욱 낮아졌습니다.

#### 3) 네트워크 주소 변환 (NAT) 방화벽의 확산

* 약점: NAT 장비는 사설 네트워크에 있는 여러 클라이언트의 실제 IP 주소를 숨기고, **외부에는 방화벽이 사용하는 하나의 공인 IP 주소로만 통신**합니다. 웹 서버는 실제 클라이언트 IP 대신 이 방화벽의 IP만 보게 됩니다.
* 현재 현황: 가정용 공유기부터 대규모 기업 네트워크까지 NAT는 보편적으로 사용되고 있어, 수많은 사용자가 하나의 공인 IP를 공유하게 되므로 IP 기반 식별을 불가능하게 만듭니다.

#### 4) HTTP 프록시 및 게이트웨이의 개입

<figure><img src="../../../../.gitbook/assets/image (426).png" alt=""><figcaption></figcaption></figure>

* 약점: 클라이언트와 원 서버 사이에 프록시(Proxy) 서버가 있는 경우, **원 서버는 클라이언트의 IP 주소 대신 프록시 서버의 IP 주소를 보게 됩니다.**
* 해결 시도: 이 문제를 해결하기 위해 일부 프록시는 `Client-ip`나 `X-Forwarded-For` 같은 확장 헤더를 추가하여 실제 클라이언트 IP를 전달하려 했으나, 모든 프록시가 이를 따르는 것은 아니었습니다.
  * 2025년 현황: `X-Forwarded-For` 헤더는 사실상 표준처럼 널리 사용되고 있으며, 더 공식적인 대체 헤더로 `Forwarded` 헤더도 사용됩니다. 그러나 이 헤더들은 조작이 가능하므로, 보안 목적으로는 최종 프록시나 방화벽의 IP만 신뢰하는 것이 일반적입니다.

### 💡 결론 및 현재의 활용

현재(2025년) 클라이언트 IP 주소를 이용한 사용자 식별은 주된 방법으로 사용되지 않습니다.

* 보안 목적의 제한적 사용: 여전히 일부 웹사이트나 인트라넷에서는 특정 IP 대역에서만 접근을 허용하는 접근 제어(Access Control) 기능으로 IP 주소를 사용합니다.
* 추적 및 분석의 보조 수단: 웹 분석에서는 IP 주소를 대략적인 지리적 위치 파악이나 악성 요청 탐지 등 보조적인 수단으로 활용합니다.

> 이러한 IP 기반 식별의 한계 때문에, 웹은 `쿠키(Cookie)`와 같은 더 정확하고 유연하며 애플리케이션 계층에서 동작하는 식별 기술로 발전하게 되었습니다.

## 4. HTTP 인증을 통한 사용자 식별 (로그인)

IP 주소 추적과 같은 수동적인 방식과 달리, HTTP 인증은 **사용자 이름과 비밀번호를 사용하여 사용자에게 명시적인 식별 요청을 하는 방식**입니다.

### 1) HTTP 인증의 기본 작동 단계

<figure><img src="../../../../.gitbook/assets/image (427).png" alt=""><figcaption></figcaption></figure>

1. 클라이언트 요청 (a): 브라우저가 보호된 리소스(`GET /index.html`)를 요청합니다.
2. 서버의 인증 요청 (b): 서버가 사용자 식별 정보를 알지 못하면, `401 Login Required` 응답 코드와 함께 `WWW-Authenticate` 헤더를 반환하여 로그인하라고 요청합니다. (`WWW-Authenticate: Basic realm="..."`)
3. 클라이언트의 재요청 (c): 브라우저는 사용자에게 로그인 대화 상자를 띄우고, 사용자가 입력한 정보를 바탕으로 기존 요청에 `Authorization` 헤더를 추가하여 재전송합니다. (`Authorization: Basic [인증 정보]`)
   * 인증 정보: 일반적으로 사용자 이름과 비밀번호를 `:`로 연결한 후 Base64로 인코딩한 문자열입니다.
4. 서버의 성공 응답 (d): 서버가 인증 정보를 확인하고 사용자 식별에 성공하면, 요청한 리소스와 함께 `200 OK` 응답을 반환합니다.

### 2) HTTP 인증의 특징 및 한계

| **특징**      | **내용**                                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 지속적인 식별     | 일단 로그인하면, 브라우저는 해당 사이트로 보내는 모든 후속 요청에 `Authorization` 헤더를 자동으로 포함하여 보내므로, 세션 내내 사용자 식별이 유지됩니다.                               |
| 보안 문제 (취약점) | HTTP 기본 인증(Basic Authentication)에서 `Authorization` 헤더의 내용은 Base64로 인코딩될 뿐, 암호화되지 않습니다. 네트워크상의 관찰자가 쉽게 해독할 수 있어 보안에 매우 취약합니다. |
| 사용자 불편      | 사용자가 사이트마다 별도의 로그인을 해야 하며, 각 사이트별로 다른 계정 정보를 기억해야 하는 불편함이 있습니다.                                                              |

### 3) 2025년의 HTTP 인증과 보안 강화

제시된 텍스트의 HTTP 기본 인증은 현재(2025년) 단독으로 사용되지 않습니다. 보안 취약점과 사용자 경험 문제가 심각하기 때문입니다.

**1. 전송 보안의 필수화 (HTTPS)**

* 보안 강화: HTTP 기본 인증이 가진 근본적인 문제(쉽게 해독되는 Base64 인코딩)를 해결하기 위해, 모든 웹사이트는 TLS/SSL 암호화를 사용하는 <mark style="color:red;">HTTPS를 필수적으로 적용</mark>합니다. HTTPS를 사용하면 `Authorization` 헤더를 포함한 전체 통신이 암호화되어 중간자 공격으로부터 보호됩니다.

**2. 현대 웹에서의 인증 대체 기술**

사용자 편의성과 보안을 개선하기 위해 더 발전된 인증 및 세션 관리 방식이 주로 사용됩니다.

* 세션 쿠키 (Session Cookies): 로그인 후 사용자 ID나 세션 토큰을 암호화된 쿠키에 저장하여, 매 요청마다 이 쿠키를 서버로 전송해 세션을 유지하는 방식이 가장 일반적입니다.
* 토큰 기반 인증 (JWT): API 서버나 마이크로서비스 환경에서 로그인 후 **JSON Web Token (JWT)**&#xC744; 발급하고, 클라이언트가 이 토큰을 `Authorization: Bearer <Token>` 형태로 전송하여 인증하는 방식이 널리 사용됩니다.
* SSO (Single Sign-On): "프레드가 사이트를 옮겨다닐 때마다 로그인해야 하는 문제"를 해결하기 위해, OAuth 2.0 및 OpenID Connect와 같은 표준 프로토콜을 사용하여 구글, 네이버, 카카오 등 하나의 계정으로 여러 사이트에 로그인할 수 있는 <mark style="color:red;">SSO 방식이 대세입니다.</mark>
* 2단계 인증 (2FA/MFA): 비밀번호 외에 추가적인 인증 수단(SMS, 앱 토큰 등)을 요구하여 보안을 극대화합니다.

## 5.  뚱뚱한 URL (Fat URLs)을 통한 사용자 식별

> 뚱뚱한 URL은 HTTP가 무상태(Stateless)인 문제를 해결하기 위해 URL 자체에 사용자 상태 정보(식별자)를 삽입하여 세션을 유지하려 했던 초기 웹 기술입니다.

### 1) 작동 원리

* 식별자 추가: 사용자가 웹사이트에 처음 방문하면 **고유한 ID가 생성**됩니다.
* URL 확장: 이 ID(예: `002-1145265-8016838`)를 모든 하이퍼링크의 URL 경로 뒤에 동적으로 추가합니다.
* 상태 유지: 사용자가 사이트 내 링크를 클릭할 때마다 ID가 포함된 뚱뚱한 URL이 서버로 전송되고, 서버는 이 ID를 통해 사용자 정보(장바구니, 프로필 등)를 조회하여 세션을 유지합니다.\


```
<a href="/exec/obidos/wishlist/ref=gr_pl1_/002-1145265-8016838">Wish Listc</a><br>
```

### 2) 뚱뚱한 URL의 심각한 문제점 (사용하지 않는 이유)

| **문제점**       | **상세 설명**                                                                                                                             | **2025년 현황에 미치는 영향**                                   |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| 못생긴 URL (혼란)  | 브라우저 주소창에 <mark style="color:red;">긴 식별자가 노출</mark>되어 새로운 사용자에게 혼란을 주고 URL의 가독성을 해칩니다.                                                | 사용자 경험(UX)을 크게 저해하여 현대 웹에서는 용인되지 않습니다.                 |
| 공유하지 못하는 URL  | URL에 특정 사용자의 개인 세션 정보가 포함되어 있어, <mark style="color:red;">이 URL을 타인에게 공유하면 개인 정보가 유출</mark>되거나, 공유 받은 사람이 원래 사용자의 세션 상태를 그대로 물려받게 됩니다. | 개인 정보 보호 및 보안 관점에서 용납될 수 없는 치명적인 문제입니다.                |
| 캐시를 사용할 수 없음  | 식별자가 추가되어 URL이 매번 달라지기 때문에, 서버는 이미 콘텐츠를 저장하고 있는 기존 캐시(Cache)에 접근할 수 없습니다.                                                             | 서버 부하 가중을 초래하고 웹 성능을 심각하게 저하시켜 대규모 트래비스 처리 능력을 떨어뜨립니다. |
| 서버 부하 가중      | URL이 바뀔 때마다 서버는 HTML 페이지를 다시 그려야 하므로 서버 자원 소모가 큽니다.                                                                                   | 성능과 확장성이 중요한 현대 웹 환경에서 비효율적입니다.                        |
| 이탈 (Breakage) | 사용자가 세션 정보가 추가되지 않은 링크를 클릭하거나, 외부 사이트로 이동했다가 되돌아오면 세션 정보가 손실되어 처음부터 다시 시작해야 합니다.                                                      | 서비스 사용의 연속성을 해쳐 사용자 이탈률을 높입니다.                         |
| 세션 간 지속성의 부재  | 사용자가 로그아웃하거나 브라우저를 닫으면, 북마크된 뚱뚱한 URL을 제외하고는 모든 정보를 잃게 되어 세션 정보를 영구적으로 유지할 수 없습니다.                                                     |                                                        |

### 💡 현재의 대체 기술 (2025년)

뚱뚱한 URL의 모든 문제점은 HTTP 쿠키와 토큰 기반 인증 기술을 통해 해결되었습니다.

* HTTP 쿠키 (Cookies):
  * 해결: 사용자 식별자를 URL 대신 클라이언트의 브라우저에 저장하고 자동으로 요청 헤더를 통해 전송합니다. URL은 깨끗하게 유지되고, 캐시 효율이 높아집니다.
  * 현황: 여전히 세션 관리에 가장 널리 쓰이는 표준입니다.
* 토큰 기반 인증 (JWT / Session Tokens):
  * 해결: URL과는 별도로 암호화된 토큰을 사용하여 안전하게 사용자 세션을 식별합니다.
  * 현황: 보안 및 확장성이 요구되는 API 및 모바일 환경에서 선호됩니다.

{% hint style="success" %}
결론적으로, 뚱뚱한 URL은 한때 사용자를 추적하는 방법이었으나, **보안, 성능, 사용자 경험 등 모든 측면에서 현대 웹의 요구 사항을 충족하지 못하여 역사 속으로 사라진 기술**입니다.
{% endhint %}

## 6. HTTP 쿠키 (Cookies)

{% hint style="success" %}
쿠키는 <mark style="color:red;">서버가 클라이언트 측에 데이터를 저장</mark>하게 하고, 클라이언트가 해당 서버에 요청할 때마다 저장된 데이터를 다시 서버로 전송하게 하여 **상태(State)**&#xB97C; 관리하는 메커니즘입니다.\
\
쿠키는 **캐시와 충돌**할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않습니다.
{% endhint %}

### 1) 쿠키의 유형 (Types of Cookies)

> 세션 쿠키와 지속 쿠키의 다른 점은 **파기되는 시점**뿐입니다.

| **유형**                    | **생명 주기**                                       | **저장 위치**                 | **주요 용도**                                    |
| ------------------------- | ----------------------------------------------- | ------------------------- | -------------------------------------------- |
| 세션 쿠키 (Session Cookie)    | 브라우저가 닫히면 삭제됩니다.                                | 메모리(임시 저장)                | 사용자가 사이트를 탐색하는 동안의 설정, 장바구니 내용 등 임시적인 상태 유지. |
| 지속 쿠키 (Persistent Cookie) | `Expires` 또는 `Max-Age` 파라미터로 지정된 파기 시점까지 유지됩니다. | 디스크 (브라우저를 닫거나 재시작해도 유지됨) | 로그인 상태 유지, 사용자 선호 사항, 장기간 사용자 식별(재방문 추적).    |

#### 2) 쿠키의 작동 방식

<figure><img src="../../../../.gitbook/assets/image (428).png" alt=""><figcaption></figcaption></figure>

1. 초기 방문 (a): 클라이언트가 서버에 처음 요청하면 서버는 클라이언트를 모릅니다.
2. 쿠키 할당 (b): 서버는 유일한 식별 값(예: `id="34294"`)을 포함한 `Set-Cookie` (또는 `Set-Cookie2`) 응답 헤더를 **클라이언트에 전송**합니다.
3. 쿠키 저장: 브라우저는 받은 **쿠키를 쿠키 데이터베이스(SQLite 파일 등)에 저장**합니다. 이 시스템을 `클라이언트 측 상태(Client-side State)`라고 합니다.
   1. creation\_utc      &#x20;: 쿠키가 생성된 시점
   2. host\_key : 쿠키의 도메인
   3. name : 쿠키의 이름
   4. value : 쿠키 값
   5. path : 쿠키와 관련된 도메인 경로
   6. expire\_utc : 쿠키 파기 시점으로 Jan 1, 1970 00:00:00 GMT로부터 파기될      시간을 초 단위로 기술
4. 재방문 및 전송 (c): 클라이언트가 이후 같은 사이트를 방문하면, 브라우저는 저장된 쿠키를 `Cookie` 요청 헤더에 담아 **서버로 전송**합니다.
5. 서버 식별: 서버는 전송된 쿠키 값으로 데이터베이스에서 사용자의 저장된 정보(프로필, 구매 내용 등)를 찾아 사용자를 식별하고 상태를 유지합니다.

### 3) 쿠키의 적용 범위 제어

브라우저는 성능 저하 및 개인 정보 문제 방지를 위해 쿠키를 생성한 서버에게만 해당 정보를 전달합니다. 서버는 `Set-Cookie` 헤더의 속성을 사용하여 쿠키의 적용 범위를 정교하게 제어할 수 있습니다.

| **속성**   | **역할**                                                   | **예시**                           |
| -------- | -------------------------------------------------------- | -------------------------------- |
| `Domain` | 쿠키를 전송할 수 있는 도메인 범위를 지정합니다. 하위 도메인에도 적용 가능합니다.           | `domain="airtravelbargains.com"` |
| `Path`   | 쿠키를 전송할 수 있는 URL 경로의 앞부분을 지정합니다.                         | `path=/autos/`                   |
| `Secure` | 이 속성이 있으면 **HTTPS(SSL 보안 연결)**&#xB97C; 사용할 때만 쿠키를 전송합니다. | `secure`                         |

### 4) 쿠키와 캐싱의 충돌 문제

{% hint style="danger" %}
쿠키가 있는 문서를 캐싱하는 것은 보안 및 사용자 추적의 일관성 문제 때문에 매우 주의해야 합니다.
{% endhint %}

* Set-Cookie 헤더 응답
  * 응답에 `Set-Cookie` 헤더가 있으면, 해당 응답 본문은 캐시할 수 있지만(`Cache-Control: Public`이 명시된 경우), `Set-Cookie` 헤더 자체를 캐시하면 안 됩니다.&#x20;
  * 캐시된 `Set-Cookie`가 여러 사용자에게 할당되면 사용자 추적에 실패하고 개인 정보가 노출될 수 있습니다.
* Cookie 헤더 요청
  * 요청에 `Cookie` 헤더가 포함되면, 그 응답 콘텐츠가 개인화된 정보(Private Data)일 가능성이 높다는 힌트입니다.&#x20;
  * 보수적인 캐시는 `Cookie` 헤더가 포함된 요청에 대한 응답을 아예 캐시하지 않습니다.

#### Cache-Control 활용:

서버는 캐시된 문서에 `Cache-Control: must-revalidate, max-age=0`을 추가하여 클라이언트가 쿠키를 사용했더라도 매번 원 서버와 재검사하도록 강제할 수 있습니다.

### 5) 쿠키 버전 및 최신 표준 (2025년) 🚀

제시된 텍스트는 **Version 0 (넷스케이프 쿠키)와 Version 1 (RFC 2965)**&#xC744; 다루고 있으나, Version 1은 널리 사용되지 않고 폐기되었습니다.

* 현재 표준: 2025년 현재 쿠키의 공식 표준은 RFC 6265 ("HTTP State Management Mechanism")입니다. 이는 Version 0의 실제 구현을 바탕으로 단순화하고 보안을 강화한 것입니다.
* 주요 최신 속성:
  * `Max-Age`: `Expires` 대신 쿠키의 수명을 초 단위의 상대 시간으로 지정하는 방식입니다. (Version 1에서 도입되어 RFC 6265에서 표준화됨)
  * `HttpOnly`: 쿠키를 자바스크립트(`document.cookie`)로 접근할 수 없도록 설정하여 XSS(Cross-Site Scripting) 공격을 방어합니다. (보안 필수 요소)
  * `SameSite`: 쿠키가 `다른 사이트 간 요청(Cross-Site Request)`에 어떻게 첨부되어야 하는지를 정의하여 CSRF(Cross-Site Request Forgery) 공격을 방어합니다. (현재 기본값으로 설정되는 경우가 많음)

### 6) 보안과 개인 정보 (프라이버시)

* 핵심: 쿠키 자체는 데이터를 클라이언트와 서버 사이에 전달하는 메커니즘일 뿐, 보안 위험은 쿠키에 민감한 정보를 직접 저장하거나, 서드파티 쿠키를 오용할 때 발생합니다.
* 서드파티 쿠키 문제: 타사 광고사가 여러 웹사이트에서 동일한 지속 쿠키를 사용하여 사용자의 프로필과 웹 사용 습관에 대한 방대한 데이터를 구축하는 행위는 가장 큰 개인 정보 오용 사례였습니다.
  * 2025년 현황: Chrome을 포함한 주요 브라우저들은 서드파티 쿠키에 대한 지원을 단계적으로 중단하고 있으며, 이는 웹 추적(Tracking)의 방식에 혁명적인 변화를 가져오고 있습니다.
* 권고: 클라이언트와 서버 간의 데이터 유출을 막기 위해 민감한 정보는 쿠키가 아닌 서버 데이터베이스에 저장하고, 쿠키에는 그 데이터를 조회할 수 있는 \*\*임의의 식별 키(세션 ID)\*\*만 저장하는 것이 표준적인 보안 관행입니다.



### 7)  SSE의 주요 활용 예시 (2025년 기준)

SSE는 클라이언트가 서버로부터 일방적으로 데이터를 수신하는 통신이 필요할 때 매우 효율적이며, HTTP/1.1을 기반으로 하기 때문에 **WebSocket보다 가볍고 구현이 간단하다는 장점이 있습니다.**

**1. 실시간 알림 서비스 🔔**

SSE의 가장 고전적이고 일반적인 활용 분야입니다. 서버는 사용자에게 발생한 새로운 이벤트(알림)를 즉시 클라이언트로 푸시합니다.

* 키워드/주제 알림: 사용자가 설정한 특정 키워드나 관심 주제에 대한 새로운 뉴스 기사, 게시물, 댓글 등이 등록되었을 때 실시간으로 알립니다. (예: 주식 종목, 특정 인물 이름)
* 댓글/메시지 알림: 사용자 계정의 게시물에 새로운 댓글이 달렸거나, 개인 메시지가 도착했을 때 브라우저에 표시합니다.
* 시스템 알림: 사용자가 예약한 작업(예: 파일 변환, 백업 완료)이 완료되었을 때 알립니다.



**2. 라이브 데이터 스트리밍 📈**

데이터가 지속적으로 생성되고 업데이트되는 환경에서 클라이언트 측의 데이터 새로고침 없이 실시간으로 정보를 표시할 때 사용됩니다.

* 주식/암호화폐 시세: 주식 시장이나 암호화폐 거래소의 현재 가격, 거래량 등의 변동 정보를 실시간으로 차트나 테이블에 업데이트합니다.
* 스포츠 경기 라이브 스코어: 진행 중인 스포츠 경기의 점수, 시간, 주요 이벤트 등을 실시간으로 업데이트합니다.
* 센서/IoT 데이터 모니터링: 공장, 설비, 기상 관측소 등에서 수집되는 센서 데이터를 대시보드에 실시간으로 표시하여 모니터링합니다.



**3. 진행 상황 업데이트 🔄**

시간이 오래 걸리는 백엔드 작업의 현재 상태를 사용자에게 투명하게 보여줄 때 유용합니다.

* 파일 업로드/변환 진행률: 클라이언트가 대용량 파일을 업로드하거나 서버에서 비디오를 변환할 때 `진행률(%)`을 실시간으로 표시합니다.
* 긴 백엔드 작업 상태: 서버에서 대규모 데이터 처리나 보고서 생성 같은 시간이 오래 걸리는 작업을 시작했을 때, 작업 완료나 오류 발생 등의 상태 변화를 즉시 알립니다.**🔄 Polling, SSE, WebSocket 통신 흐름 비교**

SSE를 이해하는 데 도움이 되도록, 유사한 실시간 통신 방식인 Polling 및 WebSocket과의 통신 흐름을 간략히 비교하면 다음과 같습니다.

| **방식**    | **통신 흐름**             | **주요 특징**                                   | **적합한 상황**                             |
| --------- | --------------------- | ------------------------------------------- | -------------------------------------- |
| Polling   | 클라이언트 -> 서버 (주기적인 요청) | 매번 새로운 HTTP 요청/응답 발생. 서버 부하가 높음.            | 실시간성이 덜 중요하고 업데이트 주기가 긴 경우.            |
| SSE       | 서버 -> 클라이언트 (단방향 푸시)  | 한 번의 연결로 서버가 클라이언트에 데이터를 지속적으로 푸시. 구현이 간단함. | 단방향 데이터 스트리밍, 알림 서비스.                  |
| WebSocket | 서버 <-> 클라이언트 (양방향)    | 영구적인 양방향 통신 채널. 오버헤드가 가장 낮고 가장 빠름.          | 실시간 상호작용(채팅, 온라인 게임) 등 양방향 통신이 필요한 경우. |

### 8) "Client-Sent Events"의 의미와 실제 기술

{% hint style="success" %}
**클라이언트가 서버로 정보를 전송하는 것은 웹 기술의 가장 기본적인 행위**입니다. 만약 클라이언트가 서버로 '이벤트'나 '데이터'를 보낸다는 아이디어를 통신 흐름의 관점에서 본다면, 이는 기존의 표준 기술들로 이미 구현되고 있습니다.
{% endhint %}

1\. HTTP POST/PUT/PATCH 요청 (기본 이벤트)

클라이언트가 서버에 데이터를 보내는 가장 기본적인 방법은 HTTP 요청입니다.

* 역할: 웹페이지에서 버튼을 클릭하거나 폼을 제출하여 서버에 새로운 데이터(댓글, 주문 정보, 로그인 요청 등)를 전송합니다.
* 통신 형태: 클라이언트가 요청을 보내면 서버가 응답을 보내는 요청-응답 (Request-Response) 모델입니다.
* 비교: 이는 단방향으로 서버가 클라이언트에게 데이터를 '푸시'하는 \*\*SSE (Server-Sent Events)\*\*와는 정반대의 방향입니다.



**2. WebSocket 메시지 (실시간 양방향 이벤트)**

실시간으로 클라이언트가 서버에 이벤트를 보내는 가장 적절하고 현대적인 기술입니다.

* 역할: 채팅 메시지 전송, 온라인 게임에서의 사용자 액션(키 입력, 마우스 클릭), 실시간 상태 업데이트 등을 서버에 전송합니다.
* 통신 형태: 영구적인 양방향 연결을 통해 클라이언트와 서버가 자유롭게 메시지(이벤트)를 주고받습니다.
* 비교: WebSocket은 클라이언트에서 서버로의 이벤트 전송과 서버에서 클라이언트로의 이벤트 전송을 모두 효율적으로 처리하며, SSE의 단방향성 한계를 극복합니다.

> 따라서, "Client-Sent Events"라는 개념이 필요하다면 상황에 따라 <mark style="color:red;">HTTP 요청이나 WebSocket 메시지 전송을 통해 구현된다고 이해하시면 됩니다.</mark>

