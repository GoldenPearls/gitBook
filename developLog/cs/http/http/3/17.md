# 17장 내용 협상과 트랜스코딩

{% hint style="success" %}
1. **“하나의 URL로 여러 버전의 리소스를 어떻게 잘 골라서 보내줄 것인가?” → 내용 협상(Content Negotiation)**
2. **“없는 버전은 어떻게든 만들어서 맞춰줄 수 없을까?” → 트랜스코딩(Transcoding)**
{% endhint %}

***

## 1. 내용 협상(Content Negotiation) 한눈에 보기

하나의 URL이 여러 리소스에 대응할 때(언어/포맷/디바이스 등),\
**서버·프록시·클라이언트가 협상해서 “어떤 버전(variant)을 줄지 정하는 과정”**&#xC774; 내용 협상입니다.

예:\
`https://www.joes-hardware.com/`

* 영어 HTML
* 프랑스어 HTML
* 모바일용 저용량 버전
* PDF 설명서

중에서, **클라이언트 상황에 맞는 것 하나를 골라 보내는 것**이 내용 협상.

***

### 1-1. 세 가지 협상 방식

| 기법                          | 누가 선택함?                     | 장점                        | 단점 / 한계                                            |
| --------------------------- | --------------------------- | ------------------------- | -------------------------------------------------- |
| **클라이언트 주도(Client-driven)** | **클라이언트**가 서버가 준 목록에서 직접 선택 | 구현이 단순, 사용자가 스스로 “최적” 선택  | 요청이 **최소 2번**(목록 + 실제 리소스), 느리고 번거로움               |
| **서버 주도(Server-driven)**    | **서버**가 헤더 보고 자동 선택         | 요청 1번에 끝나서 빠름, 오늘날 가장 일반적 | 서버 입장에서 “사용자가 뭘 더 좋아하는지” 완벽히 알 수 없음(추측 포함)         |
| **투명 협상(Transparent)**      | **중간 프록시/캐시**가 대신 선택        | 서버 부담 감소, 캐시가 똑똑하면 응답 빨라짐 | 구현 복잡, 표준화가 약하고 실무에서 널리 쓰이진 않음 (그래도 `Vary`로 부분 지원) |

***

### 1-2. 서버 주도 협상의 핵심: Accept 계열 헤더 + q 값

서버 주도 협상의 기본은 **클라이언트가 먼저 “이런 거 좋아해요”라고 요청 헤더로 알려주는 것**입니다.

#### ① 클라이언트 선호를 나타내는 헤더들

| 헤더                                 | 의미                          | 예시                                                     |
| ---------------------------------- | --------------------------- | ------------------------------------------------------ |
| `Accept`                           | 받고 싶은 **콘텐츠 타입(MIME type)** | `Accept: text/html, application/json;q=0.9, */*;q=0.1` |
| `Accept-Language`                  | 선호 **언어**                   | `Accept-Language: ko, en-US;q=0.9, en;q=0.8`           |
| `Accept-Charset` (요즘은 거의 UTF-8 고정) | 선호 **문자 인코딩**               | `Accept-Charset: utf-8, iso-8859-1;q=0.7`              |
| `Accept-Encoding`                  | 선호 **콘텐츠 인코딩(압축)**          | `Accept-Encoding: gzip, br`                            |

서버는 이 헤더들을 보고 **“내가 가진 variant들 중에서 가장 잘 맞는 것”**&#xC744; 골라 응답합니다.

***

#### ② 품질 값(q value)로 “선호도 순위” 표현

형식:\
`항목;q=0.8` (기본값은 `q=1.0`, 즉 가장 선호)

예:

```http
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```

뜻:

* **최애:** 네덜란드어 `nl;q=1.0`
* **차선:** 영어 `en;q=0.5`
* **절대 싫음 / 이해 못함:** 프랑스어, 터키어 `q=0.0`

서버는 자신의 variant 목록 (예: `en`, `fr`, `nl`)과 이 q 값을 비교해 **최고 점수인 언어**를 선택합니다.

***

#### ③ Accept 외의 헤더도 사용 가능 (User-Agent 등)

실무에서는 이런 것도 자주 씁니다:

* `User-Agent`\
  → 구형 브라우저(예: JS 미지원)면 **JS 없는 페이지**를 보내기\
  → 모바일이면 **모바일 전용 페이지** 응답

이 경우 **Formal한 q 값 계산은 없고**, 서버 로직이 “조건문”으로 판단하는 느낌입니다.

***

## 2. 캐시 & 투명 협상: Vary 헤더의 역할

내용 협상은 캐시가 끼어들면 더 복잡해집니다.

같은 URL이라도,

* `Accept-Language: fr`인 요청과
* `Accept-Language: en`인 요청

이 받는 응답이 다를 수 있죠.\
**캐시는 이 차이를 구분해서 각각 올바른 버전을 돌려줘야 합니다.**

***

### 2-1. Vary 헤더란?

서버 응답에 포함되는 헤더:

```http
Vary: Accept-Language, Accept-Encoding
```

의미:

> “이 응답은 `Accept-Language`와 `Accept-Encoding` 값에 따라 달라질 수 있어. 캐시야, 나중에 같은 URL에 대해 응답 줄 때 이 헤더들의 값도 같이 비교해 보고 맞을 때만 이걸 써.”

즉, **캐시에 저장된 variant**는

* URL **+**
* Vary에 명시된 요청 헤더들의 조합

이 세트로 식별되어야 합니다.

예시:

* 첫 요청: `Accept-Language: fr` → 프랑스어 페이지 캐시
* 둘째 요청: `Accept-Language: en` → 영어 페이지를 새로 받아 캐시

→ 캐시는 이 두 개를 **서로 다른 variant**로 저장, 이후 각 언어 요청에 맞게 반환.

***

### 2-2. User-Agent, Cookie까지 Vary에 들어가는 경우

```http
Vary: User-Agent, Cookie
```

라고 하면:

* 브라우저 종류별(User-Agent)
* 로그인/개인화 상태별(Cookie)

**조합마다 다른 페이지**가 나올 수 있다는 뜻이라,\
캐시 입장에선 variant가 폭발적으로 늘 수 있습니다.

그래서 실무에서는:

* `Vary: Accept-Encoding` 정도는 흔하지만
* `Vary: User-Agent, Cookie`는 **캐시 효율이 크게 떨어지는 상황**이므로 신중히 씁니다.

***

## 3. 클라이언트 주도 협상은 언제 쓰나?

클라이언트 주도 협상은 예전 스타일이고, 요즘은 **언어 선택 페이지** 정도로 남아 있는 패턴입니다.

#### 동작 흐름

1. 사용자가 `https://example.com/`에 접속
2. 서버가 “영어 / 한국어 / 일본어 중 고르세요” 라는 **선택 페이지**를 HTML로 응답
3. 사용자는 언어를 클릭 → `https://example.com/ko/`로 이동

장점:

* **사용자가 직접 선택** → “내가 원하는 게 확실히 나온다”\
  단점:
* 요청 두 번
* URL이 여러 개 (`/ko`, `/en` 등) → 북마크/공유 시 혼란

그래서 국제 웹 사이트는 보통:

1. **1차: 서버 주도 협상 (Accept-Language 기반 추측)**
2. **2차: 화면에서 언어 직접 선택 UI 제공**
3. 선택을 쿠키/로컬스토리지에 저장

이 패턴을 많이 씁니다.

***

## 4. 투명 협상(Transparent Negotiation) + 캐시

투명 협상은 **프록시 캐시가 서버 대신 “어떤 variant를 줄지” 결정**하는 모델입니다.

* 서버는 평소처럼 응답 + `Vary` 헤더를 보냄
* 프록시 캐시는 이 정보를 기반으로
  * 여러 variant를 캐시에 저장하고
  * 클라이언트의 요청 헤더를 보고 가장 잘 맞는 것을 골라줌

결국,

* **서버 부담 ↓**
* **캐시가 협상까지 담당**

다만 RFC 레벨에서 완전한 투명 협상 프로토콜이 정착된 건 아니고,\
실무에서는 **“Vary를 이용한 정교한 캐싱”** 정도로 이해해 두면 충분합니다.

***

## 5. 트랜스코딩(Transcoding): 없는 버전은 “만들어서 준다”

내용 협상은 “이미 존재하는 여러 버전 중에 하나 고르기”인데,\
**트랜스코딩은 “없는 버전을 동적으로 만들어서 준다”**&#xC5D0; 가깝습니다.

예:

* 서버에 **데스크톱용 HTML**만 있음
* 모바일 단말기가 “가벼운 WML/단순 HTML”을 원함\
  → 요청을 보고 서버나 프록시가 **기존 HTML을 변환해서** 모바일용으로 만들어 응답

***

### 5-1. 트랜스코딩의 세 가지 유형

| 유형                                | 설명                      | 예시                                            |
| --------------------------------- | ----------------------- | --------------------------------------------- |
| **포맷 변환 (Format Conversion)**     | 형식/포맷 자체를 바꿈            | HTML → WML, 고해상도 이미지 → 저해상도/흑백, 동영상 → GIF 썸네일 |
| **정보 합성 (Information Synthesis)** | 핵심 정보만 추출하거나 불필요한 요소 제거 | 문서 제목만 모아 목차 생성, 본문 요약, 광고/로고 제거              |
| **콘텐츠 주입 (Content Injection)**    | 문서에 새 내용을 동적으로 추가       | 중간 프록시에서 광고 삽입, 트래킹 스크립트 삽입, 사용자 맞춤 배너 추가     |

특징:

* 포맷 변환/정보 합성은 **보통 용량을 줄이는 방향**
* 콘텐츠 주입은 **오히려 용량을 늘리는 방향** (광고, 로그 등)

***

### 5-2. 왜 “미리 여러 버전” 안 만들고 트랜스코딩을 쓸까?

정적으로 미리 여러 사본을 만들면:

* **변경 관리가 지옥**
  * 페이지 내용이 조금만 바뀌어도\
    → HTML(PC), HTML(모바일), PDF, WML, 고해상도/저해상도… 전부 수정 필요
* 저장공간 증가
* 서버 로직도 복잡해짐 (각 URL에 여러 자식 버전 관리)

반면 트랜스코딩은:

* **원본은 1개 유지**
* 요청 시점에 필요한 형태로 변환
* 변환된 결과를 캐시에 저장해 재사용할 수도 있음

단점:

* `변환 비용(시간/CPU)`이 듦 → 응답 지연 가능
* 품질이 원본 전용 제작만큼 좋지는 않을 수 있음

그래서 보통:

* `핵심 버전(PC용 HTML/JSON)`은 정적으로 관리
* 일부 `특수 상황(저속 연결, 특수 단말)`에서만 트랜스코딩을 적용

하는 식으로 섞어서 씁니다.

***

## 6. 정리: 현대 HTTP 기준으로 기억하면 좋은 포인트

1. **서버 주도 협상 + `Accept` 계열 헤더 + `q` 값**
   * 오늘날 가장 기본적인 내용 협상 메커니즘
   * **언어(`Accept-Language`)**, **미디어 타입(`Accept`)**, \*\*인코딩(`Accept-Encoding`)\*\*가 핵심
2. **캐시와 `Vary` 헤더는 세트**
   * 같은 URL이라도, `Vary`에 나열된 헤더 값이 다르면 **각각 다른 variant**
   * 캐시는 이 조합을 기준으로 저장/반환해야 함
3. **클라이언트 주도 협상은 보조 수단**
   * 자동 추측(서버 주도) 후, 화면에서 “언어/테마 선택” 같은 형태로 사용
4. **트랜스코딩은 “없는 버전 만들어내기”**
   * 포맷 변환 / 정보 합성 / 콘텐츠 주입
   * 서버 or 프록시에서 수행, 비용·품질 트레이드오프 존재
5. **실무에서는**
   * 가능한 한 **UTF-8 + gzip** + 언어 협상 정도에 집중
   * `Vary`를 과도하게 복잡하게 쓰지 않고 (`User-Agent, Cookie`는 신중히)
   * 모바일/데스크톱은 URL/서브도메인/반응형 디자인으로 처리하는 패턴이 일반적
