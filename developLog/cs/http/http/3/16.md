# 16장 국제화

## 🌍 HTTP 국제화(i18n) 한 장 요약

> “서버는 **이 문서가 어떤 문자/언어로 쓰였는지**를 알려주고,\
> 클라이언트는 **내가 어떤 문자/언어를 선호하는지**를 알려준다.”

HTTP에서 국제화를 다루는 축은 딱 **네 가지 헤더**입니다.

| 축              | 서버 → 클라이언트                       | 클라이언트 → 서버        | 역할                                        |
| -------------- | -------------------------------- | ----------------- | ----------------------------------------- |
| **문자 집합(인코딩)** | `Content-Type: ...; charset=...` | `Accept-Charset`  | 바이트 ↔ 문자 변환 방식 지정                         |
| **언어**         | `Content-Language`               | `Accept-Language` | 이 콘텐츠가 “어떤 언어 사용자용인지” / 내가 “어떤 언어를 선호하는지” |

> 오늘날 웹에서는 사실상\
> &#xNAN;**“UTF-8 + 적절한 Language Tag”** 조합이 표준이라고 보면 됩니다.

***

### 1. 문자 집합(Character Set) & 인코딩

#### 1-1. 기본 용어 정리

* **문자(Character)**
  * ‘A’, ‘가’, ‘あ’ 같은 **추상적인 글자 단위**
  * 글꼴, 굵기와 상관없는 “의미 단위”
* **글리프(Glyph)**
  * 같은 ‘A’라도 굵게, 기울임, 필기체 등 **눈에 보이는 구체적인 모양**
  * 문자는 같고, 글리프만 여러 개일 수 있음
* **코딩된 문자 집합(Coded Character Set)**
  * 각 문자에 \*\*숫자 코드(코드 포인트)\*\*를 붙인 것
  * 예:
    * US-ASCII (0\~127)
    * ISO-8859-1 (서유럽 8비트 문자)
    * Unicode / UCS (전 세계 문자에 코드 부여)
* **문자 인코딩 구조(Character Encoding Scheme)**
  * 코드 포인트(예: U+AC00)를 실제 **바이트열**로 바꾸는 방식
  * 예: UTF-8, UTF-16, EUC-KR, ISO-2022-JP 등
* **MIME Charset (HTTP의 `charset`)**
  * “어떤 코딩된 문자 집합 + 어떤 인코딩 구조”인지 묶어서 부르는 **이름 라벨**
  * 예: `utf-8`, `iso-8859-1`, `euc-kr`
  *   HTTP에서는 `Content-Type`의 `charset` 파라미터로 실음

      ```http
      Content-Type: text/html; charset=utf-8
      ```

#### 1-2. 왜 `charset`이 중요할까?

서버가 `charset`을 잘못 보내면, 클라이언트는 **같은 바이트**를 놓고도\
전혀 다른 문자로 디코딩해서 화면이 **깨져 보이게** 됩니다.

* 같은 바이트 값 `0xE1 (225)`를
  * `iso-8859-1`로 해석 → á
  * `iso-8859-7`로 해석 → 그리스 문자 α
  * `iso-8859-6`로 해석 → 아랍 문자 FEH
* 서버가 실제 인코딩은 `iso-8859-6`인데, 헤더에 `iso-8859-1`이라고 보내면\
  → 브라우저는 완전히 틀린 글자를 보여주게 됨

#### 1-3. 과거 vs 현재

과거에는:

* 지역별 8비트 인코딩
  * `iso-8859-1` (서유럽)
  * `euc-kr` (한글)
  * `Shift_JIS`, `euc-jp`, `iso-2022-jp` (일본어) 등
* **문제점**: 인코딩이 섞이면 지옥, 데이터 이동/통합 시 깨짐 대잔치

현재는:

* **유니코드(Unicode, UCS) + UTF-8** 조합이 사실상 표준
* 장점
  * 전 세계 문자 대부분 표현 가능
  * ASCII와 하위 호환 (영문/숫자 영역은 동일 바이트)
  * 서버/DB/클라이언트 모두 UTF-8로 통일하면 인코딩 버그 크게 감소

> **실무 권장**
>
> * 서버/HTML/JSON/DB 모두 **UTF-8**로 통일
> * 항상 `Content-Type`에 `charset=utf-8` 명시
> * HTML5 문서라면 `<meta charset="UTF-8">`도 함께 넣기

#### 1-4. 클라이언트 측: `Accept-Charset`

```http
Accept-Charset: utf-8, iso-8859-1;q=0.8
```

* “나는 `utf-8`을 제일 선호하고, 안 되면 `iso-8859-1`도 이해할 수 있어요”
* 요즘은 대부분의 브라우저가 UTF-8을 기본으로 쓰고,\
  이 헤더는 실무에서 거의 신경 쓰지 않는 경우가 많지만,\
  **명세상**으로는 이런 식으로 표현하게 되어 있음.

***

### 2. 언어 태그(Language Tags)와 HTTP

문자 인코딩과 \*\*언어(language)\*\*는 별개의 개념입니다.

* 인코딩: "이 바이트들을 어떻게 문자로 읽을까"
* 언어: "이 텍스트는 **어떤 언어 사용자**를 대상으로 쓰였나"

#### 2-1. 서버 측: `Content-Language`

```http
Content-Language: ko
Content-Language: fr, en
```

* 이 콘텐츠가 **어떤 언어 사용자**를 대상으로 하나? 를 나타냄
* 텍스트만이 아니라 오디오, 비디오, 앱도 모두 대상 언어를 가질 수 있음
  * 예: 나바호어 오디오 → `Content-Language: i-navajo`
* 콘텐츠에 여러 언어가 쓰였다고 해서\
  항상 `Content-Language`에 여러 언어를 나열해야 하는 건 아님
  * 예: “라틴어 입문서” 텍스트는 **영어 사용자용**이므로 `en`이 맞음

#### 2-2. 클라이언트 측: `Accept-Language`

```http
Accept-Language: ko, en-US;q=0.9, en;q=0.8
```

* “나는 한국어를 제일 선호하고, 그 다음은 미국 영어, 그 다음은 일반 영어”
* 서버는 하나의 리소스에 여러 언어 버전이 있을 때\
  이 정보를 사용해서 **가장 적합한 언어 버전을 선택**할 수 있음\
  (콘텐츠 협상)

#### 2-3. 언어 태그 형식 (RFC 5646 기준, 최신)

언어 태그는 **하이픈(-)** 으로 나뉜 서브태그들의 조합입니다.

**기본 구조**

```
언어[-지역][-스크립트/방언/기타...]
```

* **언어 (primary subtag)** – ISO 639 코드, 소문자
  * 예: `ko`, `en`, `fr`, `ja`, `zh`
* **지역 (region)** – ISO 3166 국가 코드, 대문자
  * 예: `US`, `GB`, `KR`, `BR`
  * 예: `en-US`, `pt-BR`, `zh-CN`
* **기타 서브태그** – 스크립트, 방언, 변종 등 (필요시)

> 관례
>
> * 언어: `en`, `ko`, `ja` → **소문자**
> * 지역: `US`, `KR`, `BR` → **대문자**
> * 예: `en-us` (허용되지만) → 관례상 `en-US`로 쓰는 게 좋음

***

### 3. 국제화된 URI & IRI

#### 3-1. 왜 URI는 원래 ASCII만 썼을까?

* URI는 전 세계 사람들이
  * 이메일, 전화, 라디오, 인쇄물 등으로 쉽게 공유할 수 있어야 했음
* 그래서 **키보드/프로토콜이 거의 항상 지원하는 최소 문자집합**인\
  US-ASCII 일부만 허용 (알파벳, 숫자, 몇 특수 문자)

장점: 어디서나 입력 가능\
단점: 라틴 문자를 안 쓰는 사용자에게는 **읽기도, 기억하기도 어려움**

#### 3-2. Percent-Encoding (이스케이프)

ASCII에 없는 문자나 스페이스 등을 넣고 싶으면

```
% + 16진수 두 자리 (그 바이트 값)
```

* 스페이스(ASCII 32 = 0x20) → `%20`
* `%` 자체(ASCII 37 = 0x25) → `%25`

**원칙**

* 이스케이프는 “바이트” 수준에서 일어남
* 내부에서는 원래 문자 인코딩(요즘은 UTF-8)으로 문자열 → 바이트\
  → 필요한 바이트들만 `%XX`로 치환

#### 3-3. 국제 문자와 UTF-8 + Percent-Encoding

오늘날 표준 접근 (RFC 3986, IRI 관련 표준):

1. 문자열을 **UTF-8**로 인코딩 → 바이트열 만들기
2. URI에서 허용되지 않는 바이트를 `%XX` 형태로 인코딩

예:\
`https://example.com/검색?q=한글`

* 브라우저 내부에서 `검색`, `한글`을 UTF-8로 바이트 변환
* 각 바이트를 `%E3%85...` 이런 식으로 percent-encoding
* 네트워크에는 ASCII로만 구성된 URI가 흘러다님

#### 3-4. 국제 도메인 이름(IDN) & Punycode

도메인에 비-ASCII 문자를 쓰려면:

* `한글.com` → 브라우저는 내부적으로 **Punycode**로 변환
  * 예: `xn--bjobj06e.com` 이런 식의 ASCII 도메인
* 사용자에게는 “한글.com”으로 보이지만,
* DNS/HTTP 통신은 Punycode로 진행

***

### 4. 주의할 점 & 기타 국제화 이슈

#### 4-1. HTTP 헤더는 여전히 ASCII

* 헤더 필드 이름, 값은 **US-ASCII** 기준이 원칙
* 현실에서는 128 이상 코드가 섞여 들어오는 경우도 있어서\
  파서 구현 시 **너무 쉽게 죽지 않도록 관대하게 처리**해야 함
* C 라이브러리(예: `ctype`) 등을 쓸 때\
  ASCII 밖 문자를 넣으면 이상하게 동작하거나 크래시 나는 구현도 있으므로 주의

#### 4-2. HTTP 날짜 형식

* HTTP 날짜는 명세에 정의된 **GMT 기반 포맷**을 따라야 함
* 하지만 일부 서버가 로컬 언어로 월 이름을 쓰거나 엉뚱한 포맷을 쓰기도 함
  * 예: `Mon, 10 3월 2025 10:00:00 GMT` 같은 이상한 형태
* 클라이언트/프록시는:
  * 최대한 관대하게 파싱하되,
  * 도저히 파싱이 안 되면 **보수적으로(캐시 짧게 등)** 처리해야 함

#### 4-3. “추측” 대신 “명시”

* 서버가 `charset`을 안 보내면, 클라이언트는
  * HTML의 `<meta>` 태그나
  * 내용 패턴(히유리스틱)을 스캔해서 인코딩을 **추측**해야 함
* 이 과정에서 잘못 추측하면 **깨짐** 발생\
  → 실제로 가장 골치 아픈 버그들 중 하나

> **베스트 프랙티스**
>
> * **항상** 응답 헤더에 정확한 `Content-Type; charset=utf-8` 명시
> * 가능하면 HTML `<meta charset="UTF-8">`도 같이 설정
> * 서버/DB/템플릿 엔진/파일 저장 인코딩 통일

***

### 5. 실무용 초간단 요약

마지막으로, “실제로 구현할 때”만 기억해도 좋은 최소 세트만 뽑으면:

1. **문자 인코딩**
   * 서버/DB/템플릿/정적 파일 모두 **UTF-8**로 통일
   *   응답 헤더:

       ```http
       Content-Type: text/html; charset=utf-8
       ```
   *   HTML:

       ```html
       <meta charset="UTF-8">
       ```
2. **언어 태그**
   *   한국어 사이트라면:

       ```http
       Content-Language: ko
       ```
   * 브라우저는 자동으로 `Accept-Language`를 보냄\
     → 서버에서 다국어 지원 시 이 헤더로 협상
3. **URI & IRI**
   * URI 내부는 **UTF-8 → percent-encoding**이 기본
   * 도메인에 한글 쓰고 싶으면 → 브라우저가 자동으로 Punycode로 변환
   * 애플리케이션에서 URI 다룰 때:
     * **언이스케이프는 한 번만**
     * 이중 언이스케이프/인코딩에 주의
4. **헤더 & 날짜**
   * 헤더 값은 ASCII 기준으로 다루되,
   * 예상 밖의 문자나 이상한 날짜 포맷이 와도 **죽지 않게** 방어적으로 구현



## 실제 쓰임

### 1. 서버(백엔드) 쪽 UTF-8 세팅

#### 1-1 공통 원칙

1. **서버에서 보내는 모든 텍스트 응답은 `charset=utf-8`로 통일**
2. 실제 파일/소스 인코딩도 전부 UTF-8로 맞추기 (html, jsp, properties 등)
3. API 응답(JSON)도 그냥 전부 UTF-8 고정

***

#### 1-2 HTTP 응답 헤더

* 최소 이렇게는 항상 나가게 만들기:

```http
Content-Type: text/html; charset=utf-8
```

* JSON API라면:

```http
Content-Type: application/json; charset=utf-8
```

***

#### 1-3. Spring / Java (톰캣 기준)

**(1) 응답 인코딩 필터**

```java
import org.springframework.web.filter.CharacterEncodingFilter;

@Bean
public FilterRegistrationBean<CharacterEncodingFilter> characterEncodingFilter() {
    CharacterEncodingFilter filter = new CharacterEncodingFilter();
    filter.setEncoding("UTF-8");
    filter.setForceEncoding(true);

    FilterRegistrationBean<CharacterEncodingFilter> registrationBean = new FilterRegistrationBean<>();
    registrationBean.setFilter(filter);
    registrationBean.addUrlPatterns("/*");
    return registrationBean;
}
```

**(2) application.yml**

```yaml
spring:
  mvc:
    locale: ko_KR
  servlet:
    encoding:
      charset: UTF-8
      enabled: true
      force: true
```

**(3) JSP 사용 시**

```jsp
<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %>
```

* 그리고 IDE(인텔리J, 이클립스)에서 프로젝트/파일 인코딩도 “UTF-8”로 맞추기.

***

#### 1-4. Nginx / Apache 레벨

**Nginx**

```nginx
http {
    charset utf-8;
    # ...
}
```

**Apache**

```apache
AddDefaultCharset UTF-8
```

***

#### 1-5. Node.js / Express 예시

```js
app.use((req, res, next) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  next();
});

// JSON은 보통 이렇게 자동으로 UTF-8로 나감
app.get('/api', (req, res) => {
  res.json({ message: '안녕하세요' });
});
```

***

### 2. 프론트엔드(브라우저) 쪽 세팅

#### 2-1. HTML 기본 템플릿

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>사이트 제목</title>
</head>
<body>
  ...
</body>
</html>
```

* `lang="ko"` : 문서 기본 언어 (SEO + 접근성에 도움)
* `<meta charset="UTF-8">` : **문서 자체 인코딩 선언** (가능하면 `<head>` 맨 위에)

***

#### 2-2. 정적 파일 인코딩

* `.css`, `.js`, `.html`, `.jsp`, `.vue`, `.jsx` 등 **모든 텍스트 파일 UTF-8**
* 빌드 도구(webpack, Vite 등)도 보통 UTF-8 기본이라,\
  소스 파일만 UTF-8로 맞춰두면 문제 거의 없음.

***

#### 2-3. 폰트 & i18n 라이브러리

* 한국어/다국어 UI를 쓴다면:
  * 웹폰트(예: Noto Sans KR) 적용 시 `unicode-range`로 필요한 문자만 로딩하거나,
  * 기본 시스템 폰트 + 한글 폰트 fallback 전략 잡기
* 다국어 UI가 필요하다면:
  * React → `react-intl`, `react-i18next`
  * Vue → `vue-i18n`
  * 문자열 리소스를 `ko.json`, `en.json` 이런 식으로 관리\
    (**파일 인코딩도 UTF-8**!)

***

### 3. DB UTF-8 세팅

#### 3-1. MySQL / MariaDB

요즘은 **`utf8mb4` + 적절한 collation**이 정석.

(1) DB / 테이블 생성 시

```sql
CREATE DATABASE mydb
  DEFAULT CHARACTER SET utf8mb4
  DEFAULT COLLATE utf8mb4_general_ci;
```

테이블도 확실히:

```sql
CREATE TABLE user (
  id BIGINT PRIMARY KEY,
  name VARCHAR(100),
  ...
) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
```

(2) 서버 설정 (my.cnf)

```ini
[mysqld]
character-set-server = utf8mb4
collation-server     = utf8mb4_general_ci

[client]
default-character-set = utf8mb4

[mysql]
default-character-set = utf8mb4
```

(3) JDBC URL

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Seoul
```

> 요약:
>
> * **서버 기본 UTF-8**
> * **DB/테이블 UTF-8**
> * **커넥션도 UTF-8**\
>   셋 다 맞추면 한글 깨질 일 거의 없음.

***

#### 3-2. PostgreSQL

* DB 만들 때부터 UTF-8:

```sql
CREATE DATABASE mydb
  WITH ENCODING 'UTF8'
  LC_COLLATE='ko_KR.utf8'
  LC_CTYPE='ko_KR.utf8';
```

* JDBC URL은 보통 기본이 UTF-8이라 따로 안 써도 되는 경우가 많음.

***

### 4. 다국어/다국가 서비스에서 Language Tag 전략

“`ko`, `en`, `en-US`, `ja-JP`를 어떻게 쓸 것인가?” 정해두는 게 중요해.

#### 4-1. 기본 전략

1. **언어 단위 기준으로 먼저 생각**
   * 한국어, 영어, 일본어 정도면 → `ko`, `en`, `ja` 단위로만 관리해도 충분한 경우 많음
2. 특정 국가마다 문맥/표현이 많이 다르면:
   * `en-US`, `en-GB`, `pt-BR` 같은 **지역까지 포함한 태그** 사용
3. 태그는 관례적으로:
   * 언어: 소문자 (`ko`, `en`)
   * 지역: 대문자 (`KR`, `US`)
   * 예: `ko-KR`, `en-US`

***

#### 4-2. URL 설계 패턴

대표적인 패턴들:

1. **경로 프리픽스 방식(추천)**
   * `https://example.com/ko/...`
   * `https://example.com/en/...`
   * 장점: 명확, SEO 좋음, 구현 단순
2. **서브도메인 방식**
   * `https://ko.example.com/`
   * `https://en.example.com/`
3. **도메인 분리 (국가 서비스용)**
   * `example.co.kr`, `example.com`, `example.jp` …

대부분의 서비스에서는:

> **“기본 도메인 + /언어코드”** 방식이 가장 무난하고 관리하기 좋음\
> (예: `/ko`, `/en`)

***

#### 4-3. HTML & 헤더에서 언어 표시

1. **HTML 루트 태그에 `lang`**

```html
<html lang="ko">
...
</html>
```

2. **서버 응답 헤더에 `Content-Language`**

```http
Content-Language: ko
```

다국어 페이지에서는:

```http
Content-Language: ko, en
```

3. **SEO용 `hreflang` (다국어 페이지 서로 연결)**

```html
<link rel="alternate" href="https://example.com/ko" hreflang="ko" />
<link rel="alternate" href="https://example.com/en" hreflang="en" />
<link rel="alternate" href="https://example.com/"   hreflang="x-default" />
```

***

#### 4-4. 사용자 언어 선택 흐름

1. 최초 접속:
   * `Accept-Language` 참고해서 “예상 언어”를 고른다\
     예: `ko, en-US;q=0.8` → `ko` 우선
2. 그 언어 버전 페이지로 **리다이렉트 또는 렌더링**
3. 사용자가 직접 언어 변경시:
   * 언어 선택 드롭다운 (`KO | EN`) 제공
   * 선택 결과를 **쿠키 or 로컬스토리지 or DB 프로필**에 저장
4. 다음 접속부터는:
   * `Accept-Language`보다 **사용자 설정값** 우선

실무 팁:

* 서버 로직 우선순위:
  1. **사용자 설정 언어 (cookie / user profile)**
  2. `Accept-Language`
  3. 서비스 기본 언어 (예: `ko`)

***

### 5. 전체 KPT 요약

**✅ Keep (계속 유지할 것)**

* 웹 전체를 **UTF-8 통일**해서 운용하기
  * 서버 응답: `Content-Type: ...; charset=utf-8`
  * HTML: `<meta charset="UTF-8">`
  * DB: `utf8mb4`(MySQL/MariaDB), `UTF8`(Postgres)
* HTTP 국제화 기본 원칙:
  * 문자 인코딩: `charset`
  * 언어: `Content-Language` / `Accept-Language`

**⚠️ Problem (주의/문제 포인트)**

* 서버/DB/파일 인코딩이 **섞여 있는 경우**
  * 예: DB는 euc-kr, 서버는 UTF-8, JSP는 MS949 → 한글 깨짐 지옥
* `charset` 헤더를 안 보내거나 잘못 보내는 경우
  * 브라우저가 추측 모드로 들어가고, 같은 페이지도 상황 따라 다르게 깨질 수 있음
* URI/쿼리스트링을 잘못 인코딩/디코딩해서:
  * 두 번 언이스케이프 해서 데이터 깨짐
  * 서버/프론트 인코딩 방식이 안 맞아서 검색 파라미터 깨짐

**🧪 Try (시도해볼 것 / 정리할 과제)**

1. **현재 서비스 점검 체크리스트**
   * [ ] 서버 응답 헤더에 항상 `charset=utf-8` 붙는지
   * [ ] HTML 템플릿에 `<meta charset="UTF-8">` 있는지
   * [ ] DB/테이블/커넥션 모두 UTF-8(utf8mb4)인지
   * [ ] JSP/HTML/JS/CSS 파일 인코딩이 전부 UTF-8인지
2. **다국어 서비스 설계 시**
   * [ ] URL 구조: `/ko`, `/en` 방식으로 통일할지 결정
   * [ ] HTML `lang` + `Content-Language` + `hreflang` 패턴 정의
   * [ ] 언어 선택 전략:
     * 우선순위: **사용자 설정 → Accept-Language → 기본 언어**
     * 선택값 저장 위치: cookie / user profile
3. **새 프로젝트 템플릿 만들기**
   * 앞으로 새 프로젝트 시작할 때,\
     &#xNAN;**“UTF-8 + 언어 태그 세팅이 이미 들어 있는 스타터 템플릿”** 하나 만들어 두면\
     매번 같은 삽질 안 해도 됨 😎
