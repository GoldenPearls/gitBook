# 15장 엔터티와 인코딩

## 1. HTTP 엔터티의 역할과 보장 사항

HTTP는 이미지, 텍스트, 동영상 등 모든 종류의 미디어 객체(콘텐츠)를 전송하며, 이 콘텐츠는 엔터티라는 잘 라벨링된 컨테이너를 통해 운반됩니다.

<figure><img src="../../../../.gitbook/assets/image (430).png" alt=""><figcaption><p><a href="https://www.wallarm.com/what/http-headers">https://www.wallarm.com/what/http-headers</a></p></figcaption></figure>

### 1) HTTP가 보장하는 핵심 기능

<figure><img src="../../../../.gitbook/assets/image (429).png" alt=""><figcaption><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview</a></p></figcaption></figure>

* 객체의 올바른 식별 및 처리:
  * `Content-Type` (미디어 포맷) 및 `Content-Language` 헤더를 사용하여 객체를 정확하게 식별합니다.
  * 이를 통해 브라우저나 클라이언트가 콘텐츠를 올바르게 처리할 수 있습니다.
* 사용자 요구 충족 (콘텐츠 협상):
  * `Accept` 관련 헤더에 기반하여 사용자의 요구사항(선호하는 언어, 형식 등)을 만족하는 콘텐츠를 제공합니다.
* 빠르고 효율적인 네트워크 이동:
  * 범위 요청(Range Request), 델타 인코딩(Delta Encoding), 데이터 압축 등을 사용하여 효율적인 전송을 보장합니다.
* 객체의 무결성 및 온전한 도착:
  * `Transfer-Encoding` 헤더와 `Content-MD5` 체크섬을 사용하여 전송 과정에서 조작되지 않고 온전하게 도착하도록 합니다.
* 객체의 올바른 압축 해제:
  * `Content-Length`와 `Content-Encoding` 헤더를 사용하여 객체가 올바르게 압축이 풀릴 수 있도록 합니다.
* 항상 최신 상태 유지:
  * 엔터티 검사기 및 캐시 만료 제어를 사용하여 객체가 항상 최신 상태임을 보장합니다.

### 2) 엔터티 및 인코딩 관련 주요 기능

> 본 장에서 다루는 주요 내용은 HTTP 엔터티와 관련된 헤더 필드 및 전송 기술입니다.

**1. HTTP 메시지 엔터티 포맷 및 동작**

* HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 구조와 작동 방식.



**2. 콘텐츠 크기 및 식별 헤더**

* 엔터티 본문의 크기를 기술하고 측정하는 방법. (예: `Content-Length`)
* 클라이언트가 콘텐츠를 바르게 처리하도록 제공되는 식별 헤더들:
  * `Content-Type`: 콘텐츠의 포맷
  * `Content-Language`: 콘텐츠의 언어
  * `Content-Charset`: 콘텐츠의 문자 집합 (문맥상 `Content-Type`에 포함되거나 별도로 사용됨)



**3. 인코딩 기술**

* 콘텐츠 인코딩 (Content Encoding):
  * 발송자가 공간을 절약하고 **더 안전하게 만들기 위해 콘텐츠 데이터 포맷을 변형할 때 사용**합니다. (예: 압축)
  * 수신 시 디코딩 가능한 형태로 전송됩니다.
* 전송 인코딩 (Transfer Encoding):
  * HTTP가 데이터를 실어 나르는 방식을 수정하여 특정 종류의 콘텐츠 송수신을 개선합니다.
  * 청크 인코딩 (Chunked Encoding): 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 `조각(청크)`으로 쪼개 전달하는 방식.



**4. 캐싱 및 최신 버전 제어**

* 엔터티 검사기 (Validators):
  * 콘텐츠의 버전 번호처럼 동작하여, 웹 애플리케이션이 최신 콘텐츠를 가지고 있음을 확신하도록 돕습니다.
  * 태그(`ETag` 등), 라스트 수정 시간(`Last-Modified` 등) 같은 검사기들을 사용하여 클라이언트가 최신 버전을 가져올 수 있게 합니다.



**5. 효율적인 전송 기능**

* 범위 요청 (Range Request):
  * 중단되었던 다운로드를 중단된 지점부터 재개하고자 할 때 유용합니다. (부분 요청)
* 델타 인코딩 (Delta Encoding) 확장:
  * 클라이언트가 이전에 본 웹 페이지를 다시 볼 때, 이후 변경된 부분만 요청할 수 있게 해줍니다. (대역폭 절약)
* 요약 (Digest) / 체크섬:
  * 엔터티 본문의 체크섬을 사용하여, 엔터티 콘텐츠가 프록시 등을 지나는 과정에서 변경되지 않았는지 탐지합니다.

{% hint style="warning" %}
이러한 메커니즘을 통해 HTTP는 전 세계 웹 트래픽의 핵심을 이루는 미디어 객체 전송을 정확하고 안전하며 효율적으로 수행합니다.
{% endhint %}

## 2. HTTP 엔터티와 Content-Length

### 1) HTTP 엔터티 및 주요 엔터티 헤더 요약

**HTTP 엔터티의 정의**

* HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 본다면, HTTP 엔터티는 메시지의 `실질적인 화물(Payload)`입니다.
* 엔터티는 <mark style="color:red;">엔터티 헤더와 엔터티 본문</mark>으로 구성됩니다.
* **엔터티 본문**은 <mark style="color:red;">가공되지 않은 순수한 데이터</mark>를 담고 있으며, **엔터티 헤더**는 이 데이터의 의미(타입, 길이, 인코딩 등)를 설명합니다.



**HTTP/1.1의 10가지 주요 엔터티 헤더**

| **헤더 필드**            | **역할 (요약)**                                              |
| -------------------- | -------------------------------------------------------- |
| $$Content-Type$$     | 전달된 객체의 미디어 종류 (예: $$ $\text{text/plain, image/gif}$ $$) |
| $$Content-Length$$   | 전달되는 메시지 본문의 바이트 길이 또는 크기                                |
| $$Content-Language$$ | 전달된 객체와 가장 잘 대응되는 자연어                                    |
| $$Content-Encoding$$ | 객체 데이터에 가해진 변형 (예: 압축)                                   |
| $$Content-Location$$ | 요청 시점을 기준으로 객체의 다른 위치                                    |
| $$Content-Range$$    | 부분 엔터티일 경우, 전체에서 어느 부분에 해당하는지 정의                         |
| $$Content-MD5$$      | 엔터티 본문 콘텐츠에 대한 체크섬 (무결성 검증)                              |
| $$Last-Modified$$    | 서버에서 이 콘텐츠가 생성/수정된 날짜와 시각                                |
| $$Expires$$          | 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되는 날짜/시각                   |
| $$Allow$$            | 이 리소스에 대해 허용되는 요청 메서드 (예: $$ $\text{GET, HEAD}$ $$)      |

* 관련 헤더 (`Strictly` 엔터티 헤더는 아님): `ETag` (고유 검사기), `Cache-Control`(캐싱 지시자)는 엔터티와 관련된 중요한 동작을 위해 사용됩니다.

***

### 2) Content-Length와 엔터티 길이 판별

#### Content-Length의 역할

<figure><img src="../../../../.gitbook/assets/image (431).png" alt=""><figcaption></figcaption></figure>

* 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냅니다.
* 인코딩된(압축된) 본문이 전송될 경우, Content-Length는 인코딩된 후의 크기를 나타냅니다.
* 메시지 잘림 검출 및 `지속 커넥션(Persistent Connection)`에서 다음 메시지의 시작점을 구분하는 데 필수적입니다.

#### 엔터티 본문 길이 판별 규칙 (우선순위 순)

아래처럼 **`$text{}` 같은 잘못 들어간 수식 마크업만 제거해서** 깔끔하게 정리해줄게!

***

#### ✔️ 엔터티 본문 길이 판별 규칙 (우선순위 순)

엔터티 본문의 길이를 결정하는 규칙은 아래 순서대로 적용된다.\
(규칙의 최신화는 아래 3절에서 다룸)

| 우선순위  | 적용 조건                                                        | 엔터티 본문 길이 판단 방식                        | 비고                      |
| ----- | ------------------------------------------------------------ | -------------------------------------- | ----------------------- |
| **1** | 메시지 유형이 본문을 허용하지 않는 경우→ `HEAD`, `1xx`, `204`, `304`          | 헤더 이후 첫 번째 빈 줄에서 끝                     | 어떤 헤더가 있어도 본문 없음        |
| **2** | `Transfer-Encoding` 헤더 존재그리고 값이 `identity`가 아님 (`chunked` 등) | **0-byte chunk (`0\r\n\r\n`)가 엔터티의 끝** | `Content-Length`는 무시됨   |
| **3** | `Content-Length` 헤더 존재그리고 `Transfer-Encoding` 없음             | **Content-Length 값만큼 바이트 수를 본문으로 해석**  | 일반적인 HTTP/1.1 메시지 구조    |
| **4** | `multipart/*` 본문`Content-Length` 없음                          | boundary 기반 파트별 구분                     | 멀티파트 폼, 이메일 MIME과 동일 구조 |
| **5** | 위 조건 어디에도 해당되지 않음                                            | **커넥션 종료 시 엔터티 종료**                    | 서버가 연결을 닫으며 본문 끝 알림     |
| **6** | (레거시) HTTP/1.0 호환 규칙                                         | RFC 7230에서 삭제됨                         | GET 본문 등 혼란 요소 제거됨      |

**요약 보기**

| 규칙                       | 본문 길이 결정 방식               | 언제 사용됨              |
| ------------------------ | ------------------------- | ------------------- |
| **본문 없음 규칙**             | 빈 줄 이후 끝                  | HEAD, 1xx, 204, 304 |
| **Transfer-Encoding 우선** | chunked → `0\r\n\r\n`로 종료 | 대용량 스트리밍, 동적 응답     |
| **Content-Length**       | 명시된 길이만큼 읽음               | 대부분의 일반 응답          |
| **멀티파트**                 | boundary로 구분              | 파일 업로드, 폼 데이터       |
| **커넥션 종료**               | 연결이 닫히면 끝                 | HTTP/1.0 스타일, 예외적   |
| **레거시 규칙 삭제**            | 적용 X                      | 최신 HTTP 표준에서는 무효    |

***

### 3) 현행화 및 $$ $\text{HTTP/1.1}$ $$ 최신 규격 (RFC 7230/7231 기준)

이  책은 _HTTP: The Definitive Guide_ 등 과거 서적 내용을 반영하고 있어, **HTTP/1.1의 2014년 개정 사양(RFC 7230 시리즈)**&#xC5D0; 따라 일부 내용이 업데이트되었습니다.

| 과거/원문 내용                                   | RFC 7230/7231 기반 현행화 (주요 변경점)                                                                                                    |
| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| HTTP/1.1은 10가지 주요 엔터티 헤더를 정의함.             | RFC 7231에서 엔터티 헤더라는 용어는 **표현 헤더(Representation Headers)**&#xB85C; 대체되었습니다. (예: Content-Type, Content-Length, Content-Encoding 등) |
| 6번 규칙: HTTP/1.1 요청은 Content-Length를 가져야 함. | <mark style="color:red;">이 규칙은 RFC 7230에서 삭제되었습니다.</mark> Transfer-Encoding: chunked를 사용하여 요청 본문의 길이를 명시하지 않고도 전송하는 것이 일반적입니다.   |
| Content-MD5 헤더                             | 보안상의 이유 등으로 RFC 7231에서 더 이상 사용하지 않도록 권고됩니다. (실제 **무결성 확인은 TLS나 다른 상위 계층 프로토콜에 의존**)                                              |

**🔎 가장 중요한 현행화: 메시지 길이 판별 우선순위**

최신 HTTP/1.1에서는 메시지 본문 길이를 판별할 때 다음 우선순위가 명확하게 정의됩니다.

1. **Transfer-Encoding 헤더의 존재**
2. **Content-Length 헤더의 존재**
3. **본문이 없는 메시지 유형**\
   예: `HEAD` 응답, `1xx`, `204`, `304` 응답
4. **커넥션 종료 기반 메시지 종료**

{% hint style="success" %}
**Transfer-Encoding(특히 chunked)** 은 **Content-Length보다 항상 우선**합니다.
{% endhint %}



***

### 4) 더 공부해야 할 내용

통신의 핵심인 엔터티와 메시지 길이 판별을 다루고 있으므로, 다음 영역에 대한 심층 학습이 필요합니다.



**1. 전송 및 콘텐츠 인코딩 (Encoding)**

<figure><img src="../../../../.gitbook/assets/image (432).png" alt=""><figcaption></figcaption></figure>

* **콘텐츠 인코딩(Content-Encoding):**

{% hint style="success" %}
데이터를 압축(예: **gzip**, **deflate**, **br(Brotli)** 등)하여 전송 효율을 높이는 방법과, 클라이언트/서버가 이를 협상하는 방식(**Accept-Encoding** 및 **Content-Encoding** 헤더).
{% endhint %}

**콘텐츠 인코딩 (Content-Encoding)**

* **정의:** 데이터를 압축하여 전송 효율을 높이는 방식. 이 인코딩은 **엔터티 본문**에 적용되며, 전송 후 클라이언트에서 디코딩됩니다.
* **보완 설명:**
  * **Content-Encoding:** 데이터를 압축(예: gzip, deflate, br(Brotli))하여 전송 효율을 높이는 방법입니다.
  * **협상 방식:** 클라이언트는 Accept-Encoding 헤더로 수용 가능한 압축 방식을 알리고, 서버는 그중 하나를 선택해 Content-Encoding 헤더로 응답합니다.
* **Content-Length와의 관계:** Content-Encoding이 적용되면, Content-Length는 **압축된 데이터의 크기**를 나타냅니다.



* **전송 인코딩(Transfer-Encoding):**

{% hint style="success" %}
특히 `chunked 인코딩(Chunked Encoding)`을 중심으로, 서버가 엔터티의 전체 크기를 모르거나 동적으로 생성할 때 데이터를 **안전하게 전송하기 위해 청크 단위로 나누어 보내는 방식**입니다.
{% endhint %}

* **정의:** 엔터티 데이터를 "어떻게 전송할지"를 정의하는 방식입니다. 이는 메시지 자체에 적용되며 메시지 경계를 정의하는 메커니즘입니다.
* **핵심 기능 – Chunked 인코딩:**\
  Transfer-Encoding: chunked는 서버가 **전체 본문 길이를 미리 알 수 없을 때**, 데이터를 일정 크기의 청크로 나누어 전송합니다.
* **Content-Length와의 관계:**\
  Transfer-Encoding, 특히 chunked가 존재하면 **Content-Length는 무시됩니다.**



<figure><img src="../../../../.gitbook/assets/image (433).png" alt=""><figcaption><p><a href="https://m.blog.naver.com/PostList.naver?blogId=hypoid613&#x26;tab=1">https://m.blog.naver.com/PostList.naver?blogId=hypoid613&#x26;tab=1</a></p></figcaption></figure>



미디버스는 영상 콘텐츠를 사용자의 기기까지 **가장 효율적이고 안정적으로 전송**하기 위한 시스템이며, 내부 동작은 HTTP의 **엔터티 전송, 콘텐츠 인코딩, 전송 인코딩, 캐싱, 스트리밍** 개념과 깊게 연관된다.

정리하면, 미디버스는 `HTTP의 성능 최적화 계층(Content Delivery Layer)`을 구현하는 솔루션이다.



**1️⃣ 업로드 및 원본 엔터티 확보**

**✔️ 미디버스 고객이 파일 업로드**

* 웹/FTP/API를 통해 영상 파일을 업로드 → 이것이 “HTTP 엔터티 본문”의 원본 소스
* HTTP에서는 이것이 서버가 제공할 `Representation Data(표현 데이터)`가 된다.

**✔️ HTTP 연관 개념**

* 업로드는 본질적으로 **HTTP 엔터티 본문 전달 과정**
* 이후 스트리밍에서 여러 형태(품질/코덱)의 엔터티로 다시 변환됨



**2️⃣ 자동 인코딩(Automatic Encoding) & 포맷 변환**

**✔️ 미디버스 역할**

* 다양한 환경을 고려해 원본 영상을 여러 버전으로 자동 변환
  * 영상 코덱: H.264, H.265(HEVC), VP9, AV1
  * 컨테이너 포맷: MP4, WebM
  * 스트리밍 포맷: HLS, MPEG-DASH, CMAF



**✔️ HTTP 관점에서의 연결**

* `Content-Encoding(압축)`과 목적이 비슷함 → “전송 효율을 위한 변환”
* **콘텐츠 협상(Content Negotiation)** 개념과 동일
  * 클라이언트의 환경을 보고 최적화된 버전을 선택하여 제공
  * Accept 헤더 원리와 유사한 방식



**3️⃣ CDN 배포(Content Delivery Network)**

**✔️ 미디버스 역할**

* 인코딩된 파일을 전 세계 CDN 서버에 배포
* 사용자와 가까운 노드에서 제공하여 속도 최적화



**✔️ HTTP 개념 연결**

**🟦 캐싱(Caching)**

* CDN은 대규모 캐시 서버
* 사용되는 헤더:
  * Cache-Control
  * Expires
  * ETag / If-None-Match
  * Last-Modified / If-Modified-Since

→ 이를 통해 **신선도(Freshness)** 관리 및 **유효성 재검사(Revalidation)** 수행

**🟦 Content-Length의 역할**

* CDN이 콘텐츠 저장 시 **잘림(Truncation)** 여부를 확인
* 잘린 파일 캐시 = 심각한 장애 → Content-Length는 캐싱 무결성의 핵심

***

**4️⃣ 최종 사용자에게 전송 (Streaming & Download)**

**✔️ 미디버스 역할**

* 사용자가 URL(임베드된 플레이어)을 통해 영상 요청
* 서버 또는 CDN이 최적화된 스트림 제공



**✔️ HTTP 개념 연결**

**🟦 Transfer-Encoding: chunked**

* 스트리밍 환경에서 **전체 크기를 사전에 알 수 없을 때** 사용
* 데이터는 청크 단위로 전송 → 마지막은 “0 청크”로 종료
* 이 경우 **Content-Length는 무시**됨

**🟦 Range Request**

* 사용자가 영상 탐색(Seek)할 때 원하는 “바이트 범위만” 요청
* 중단된 다운로드 재개 기능 담당
* HLS/DASH 세그먼트도 사실상 Range 기반 요청과 동일한 원리

***

**5️⃣ 실제 스트리밍 기술 연결**

미디버스가 사용하는 핵심 기술들:

| 기능              | 기술                         | 설명                    |
| --------------- | -------------------------- | --------------------- |
| **영상 인코딩**      | H.264, H.265, VP9, AV1     | 원본을 다양한 품질로 변환        |
| **컨테이너 포맷**     | MP4, WebM                  | 플레이어와 브라우저 호환         |
| **적응형 스트리밍**    | HLS, MPEG-DASH, CMAF       | 네트워크 상황에 따라 실시간 품질 변경 |
| **HTTP 전송 인코딩** | Transfer-Encoding: chunked | 실시간 스트리밍용             |
| **캐싱 최적화**      | Cache-Control, ETag        | 글로벌 CDN 제공 품질 향상      |
| **부분 요청**       | Range Request              | 탐색·중단 재개 기능 가능        |

| **구분**  | **콘텐츠 인코딩 (Content-Encoding)**          | **전송 인코딩 (Transfer-Encoding)** |
| ------- | --------------------------------------- | ------------------------------ |
| 적용 대상   | 엔터티 본문 데이터 (내용)                         | 엔터티 메시지 (운반 방식)                |
| 주요 역할   | 데이터 압축, 포맷 변환                           | 메시지 경계 정의, 스트리밍                |
| 미디버스 단계 | 자동 인코딩 (코덱, $$ $\text{HLS/DASH}$ $$ 변환) | CDN 배포 및 시청 (메시지 전달)           |



**2. 캐싱 (Caching)**

{% hint style="danger" %}
* **캐시 관련 헤더들**(Expires, Cache-Control, Last-Modified, ETag)이 어떻게 협력하여 객체의 `신선도(freshness)`와 `유효성 재검사(revalidation)`를 제어하는지.
* **Content-Length의 역할:**\
  캐시가 메시지 잘림(Truncation)을 감지하여 **무결한 데이터만 저장/전달하도록 돕는 핵심 요소**입니다.
{% endhint %}

* **핵심 헤더들:**
  * Expires
  * Last-Modified
  * ETag
  * Cache-Control

이 헤더들은 `신선도(freshness)`와 `유효성 재검사(revalidation)`를 제어합니다.

**신선도 (Freshness)**

* Expires 또는 Cache-Control: max-age 지시자로 캐시된 사본을 서버에 재확인 없이 사용할 수 있는 기간을 정함.

**유효성 재검사 (Revalidation)**

* 신선도가 만료된 후 캐시된 사본이 여전히 유효한지 서버에 검증 요청함.
* Last-Modified ↔ If-Modified-Since
* ETag ↔ If-None-Match

**Content-Length와 캐싱의 관계**

* 캐시 서버는 Content-Length를 통해 **메시지가 잘리지 않았는지** 검증합니다.
* 잘린 콘텐츠를 캐시하면 사용자에게 잘못된 데이터가 전달되어 심각한 오류가 발생함.



**3. 메시지 길이 문제와 보안**

* **HTTP Desync / Request Smuggling 공격:**

**Content-Length**와 **Transfer-Encoding** 헤더를 프록시 서버와 백엔드 서버가 서로 다르게 해석할 때 발생하는 보안 취약점.

> 이는 메시지 길이 판별 규칙이 **왜 절대적으로 중요**한지 잘 보여주는 사례입니다.

**HTTP Request Smuggling / Desync 공격**

* 프록시 서버와 백엔드 서버가 메시지의 끝을 **다른 기준으로 해석**할 때 공격자가 이를 악용할 수 있습니다.
* 예시 상황:
  * 프록시는 Content-Length를 기준으로 요청을 종료
  * 백엔드는 Transfer-Encoding: chunked 기준으로 요청 해석
* 이때 공격자는 두 시스템이 다르게 해석하는 “숨겨진 요청(smuggled request)”을 삽입할 수 있음.

**결과**

* 인증 우회
* 세션 하이재킹
* 다른 사용자 요청 조작
* 캐시 오염 등 다양한 공격 가능

**방어 전략**

* 프록시와 백엔드가 메시지 길이 처리 방식을 **완전히 일치**시키기
* Transfer-Encoding이 존재할 경우 Content-Length 제거
* 중복 헤더 허용 금지 등 엄격한 파싱 규칙 적용

## 3. 다시 한 번 정리하는 HTTP 엔터티 및 인코딩 개념 — 최신 RFC 7230/7231 기준 정리

HTTP 엔터티 무결성, 데이터 유형 식별, 전송 구조 변환을 중심으로 설명하고 있으며, 초기 HTTP/1.1 설명을 기반으로 하지만, 최신 명세(RFC 7230/7231)에 따라 일부 개념의 **현행화가 필요**합니다.

### 1️) 엔터티 요약(Digest) & 무결성 검증

#### ✔️ Digest 개념

엔터티 요약은 본문이 전송 과정에서 **의도치 않은 변형**이 발생했는지 검사하기 위한 체크섬 역할을 합니니다.

#### ✔️ Content-MD5

* **역할:** 엔터티 본문에 MD5로 계산된 값 전달
* **검증 시점:** Transfer-Encoding을 제거한 후 원본 엔터티에 대해 재계산
* **장점:** 의도치 않은 손상 감지
* **단점:** 악의적 변조 공격에는 취약
* **현행화:**\
  → **RFC 7231에서 더 이상 사용 권장되지 않음(Deprecated)**\
  → HTTPS(TLS) 도입으로 전송 무결성이 전송 계층에서 보장되기 때문
* **대안:** Want-Digest(RFC 3230)와 같은 더 유연한 digest 메커니즘 사용 가능

### 2️) Content-Type & Charset — 데이터 유형 식별

#### ✔️ Content-Type

* 엔터티 본문의 **미디어 타입(MIME Type)** 전달
* IANA 등록 MIME 타입 사용 (예: text/html, image/jpeg, application/json)
* Content-Encoding이 적용되어도 **원본의 논리적 타입을 유지**함\
  (압축되었어도 여전히 text/html일 수 있음)

#### ✔️ Charset

* Content-Type의 매개변수(parameter)
* 텍스트 데이터가 문자로 해석되는 방식 인코딩 (예: charset=utf-8, iso-8859-4)
* 대부분의 현대 웹은 utf-8을 표준으로 사용

#### ✔️ Multipart 타입

여러 구성요소를 포함하는 엔터티를 담기 위한 구조

* multipart/form-data → 파일 업로드
* multipart/mixed → 이메일/복합 콘텐츠
* multipart/byteranges → Range 응답(206 Partial Content)

업데이트 필요 없음 — RFC 7231에서도 그대로 유효.

### 3️) Content-Encoding — 엔터티 본문의 가역적 변환(압축)

#### ✔️ 목적

본문 크기를 줄여 **전송 효율 향상**

#### ✔️ 흐름

1. 서버가 원본 엔터티 생성
2. gzip/deflate/br 같은 Content-Encoding 적용
3. Content-Encoding 헤더 추가
4. 클라이언트는 이를 디코딩하여 원본 복원

#### ✔️ 주요 인코딩

| 인코딩      | 설명           | 상태            |
| -------- | ------------ | ------------- |
| gzip     | 가장 흔함        | 계속 사용         |
| deflate  | zlib 기반      | 사용됨           |
| compress | 매우 오래됨       | **비권장**       |
| br       | Brotli — 고효율 | **현대 웹에서 중요** |
| identity | 무인코딩         | 기본값           |

#### ✔️ Accept-Encoding

클라이언트가 수용 가능한 인코딩을 서버에 전달 **Q값(q=0.0\~1.0)을 통해 선호도 표현**\
→ 콘텐츠 협상(Content Negotiation)의 주요 요소

### 4️) Transfer-Encoding — 메시지 전송 구조 변환

#### ✔️ 역할

Payload의 내용(Content-Type)과 무관하게 **메시지를 어떻게 전송할지** 정의\
→ 저장 포맷과 전송 포맷은 별개다!

#### ✔️ Content-Encoding vs Transfer-Encoding

| 항목    | Content-Encoding | Transfer-Encoding |
| ----- | ---------------- | ----------------- |
| 적용 대상 | 엔터티 본문 내용        | 메시지 전체 구조         |
| 목적    | 압축 등             | 길이 판별/스트리밍        |
| 예     | gzip, br         | chunked           |
| 제거 시점 | 클라이언트에서 디코딩      | 메시지 파싱 과정 중       |

### 5) Chunked 인코딩 (Transfer-Encoding: chunked)

#### ✔️ 필요 이유

* 콘텐츠 생성 중 **최종 길이를 알 수 없는 경우**
* 지속 커넥션 유지하면서 메시지 경계 구분 필요
* 스트리밍/동적 응답에 필수

#### ✔️ 동작 구조

* 메시지 본문을 여러 청크로 나눔
* 각 청크는 `청크길이(16진수) + CRLF + 데이터`
* 마지막엔 `0\r\n\r\n` (0바이트 청크)로 끝 표시
* 이후 Trailer 헤더 추가 가능

#### ✔️ Trailer 헤더

* 본문 생성이 끝난 뒤에만 알 수 있는 헤더용
* 예: Content-MD5, Digest, Signature 등

#### ✔️ 최신 사양

* RFC 7230에서 **chunked는 유일한 표준 Transfer-Encoding**
* HTTP/1.1 애플리케이션은 **반드시 chunked 지원해야 함**

### 6) 현행화 판단(RFC 7230/7231 기준)

| 개념                         | 최신 사양 기준   | 비고                         |
| -------------------------- | ---------- | -------------------------- |
| Content-MD5                | **사용 비권장** | TLS가 대체                    |
| compress 인코딩               | 구식         | gzip/br 우세                 |
| Content-Type               | 여전히 표준     | Representation Header로 재분류 |
| charset                    | 여전히 사용     | utf-8이 사실상 표준              |
| Transfer-Encoding: chunked | 여전히 필수     | 메시지 길이 판별 핵심 규칙            |
| Trailer                    | 유효         | chunked 때만 사용 가능           |

### 7)  전체 핵심 요약

* **Content-MD5** → 더 이상 권장되지 않음 (TLS가 무결성 검증 역할 수행)
* **Content-Type / Charset / Multipart** → 현대 HTTP에서도 중요한 표현 정보
* **Content-Encoding(gzip, br)** → 전송 효율 최적화
* **Transfer-Encoding(chunked)** → 스트리밍·동적 응답·지속 커넥션 관리에 필수
* 최신 HTTP/1.1 명세는 "**메시지 길이 판별 규칙의 일관성**"을 매우 중요하게 다룸\
  → Request Smuggling/Desync 공격 방어와 직결됨



## 5. 웹 객체 인스턴스·캐싱·범위 요청·델타 인코딩 — 요약

제시된 텍스트는 웹 객체의 **인스턴스(시간에 따라 변하는 버전)** 개념과, 이를 효율적으로 처리하기 위한 **캐싱(freshness·validators)**, 그리고 **인스턴스 조작(Range, Delta Encoding)** 메커니즘을 정리한 것입니다.&#x20;

### &#x20;1) 웹 객체의 인스턴스 & 인스턴스 조작

* **인스턴스:** 같은 URL의 리소스라도 시간에 따라 내용이 달라질 수 있으며, 각각을 “다른 인스턴스”라고 부름.
* **인스턴스 조작:**
  * **Range Request:** 객체의 특정 바이트 범위만 요청.
  * **Delta Encoding:** 클라이언트가 가진 버전과 서버 최신 버전의 “차이(델타)”만 전송해 네트워크 비용 절감.

### 2) 캐싱 — Freshness & Validators

캐시가 가진 사본이 유효한지 판단하고, 필요할 경우 조건부 요청을 이용해 최신 인스턴스를 가져오는 메커니즘.



**A. Freshness(신선도)**

* **Expires:** 절대 시간 기반 만료 시각(시계 동기화 문제로 사용 감소).
* **Cache-Control: max-age:** 상대 시간 기반 만료 시각.\
  → 실제 운영 환경에서 가장 많이 사용되고 가장 강력.

**B. Validators(검사기)**

* **Last-Modified / If-Modified-Since** → 약한 검사기 (초 단위 정확도 한계)
* **ETag / If-None-Match** → 강한 또는 약한 검사기\
  → 가장 선호되는 방식. 서버는 버전이 바뀌면 ETag 변경.

### 3) 범위 요청 (Range Request)

* 특정 바이트만 요청해 다운로드 재개, 부분 다운로드, 병렬 다운로드 가능.
* 응답은 **206 Partial Content** + **Content-Range** 헤더.
* 서버가 지원 여부를 **Accept-Ranges: bytes**로 알림.
* 최신 웹 스트리밍(HLS/DASH)에서도 필수적인 기능.

### 4) 델타 인코딩 (Delta Encoding)

* “전체 파일” 대신 **바뀐 부분만** 전송하는 방식.
* 주요 헤더:
  * If-None-Match (기존 버전 전달)
  * A-IM (델타 처리 가능 알림)
  * Delta-Base (서버가 기준으로 삼은 ETag)
  * 226 IM Used (델타 응답 코드)
* 매우 효율적이지만, 서버가 개별 클라이언트의 이전 버전을 기억해야 하는 높은 부하 때문에 **일반 HTTP 서비스에서는 널리 사용되지 않음**.
* → 대규모 앱 업데이트 시스템 등 특수 환경에서 활용.



## 참고하면 좋을 링크

* HTTP 개요 : [https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview)
