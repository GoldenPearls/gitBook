# 15장 엔터티와 인코딩

## 1. HTTP 엔터티의 역할과 보장 사항

HTTP는 이미지, 텍스트, 동영상 등 모든 종류의 미디어 객체(콘텐츠)를 전송하며, 이 콘텐츠는 엔터티라는 잘 라벨링된 컨테이너를 통해 운반됩니다.

<figure><img src="../../../../.gitbook/assets/image (430).png" alt=""><figcaption><p><a href="https://www.wallarm.com/what/http-headers">https://www.wallarm.com/what/http-headers</a></p></figcaption></figure>

### 1) HTTP가 보장하는 핵심 기능

<figure><img src="../../../../.gitbook/assets/image (429).png" alt=""><figcaption><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview</a></p></figcaption></figure>

* 객체의 올바른 식별 및 처리:
  * `Content-Type` (미디어 포맷) 및 `Content-Language` 헤더를 사용하여 객체를 정확하게 식별합니다.
  * 이를 통해 브라우저나 클라이언트가 콘텐츠를 올바르게 처리할 수 있습니다.
* 사용자 요구 충족 (콘텐츠 협상):
  * `Accept` 관련 헤더에 기반하여 사용자의 요구사항(선호하는 언어, 형식 등)을 만족하는 콘텐츠를 제공합니다.
* 빠르고 효율적인 네트워크 이동:
  * 범위 요청(Range Request), 델타 인코딩(Delta Encoding), 데이터 압축 등을 사용하여 효율적인 전송을 보장합니다.
* 객체의 무결성 및 온전한 도착:
  * `Transfer-Encoding` 헤더와 `Content-MD5` 체크섬을 사용하여 전송 과정에서 조작되지 않고 온전하게 도착하도록 합니다.
* 객체의 올바른 압축 해제:
  * `Content-Length`와 `Content-Encoding` 헤더를 사용하여 객체가 올바르게 압축이 풀릴 수 있도록 합니다.
* 항상 최신 상태 유지:
  * 엔터티 검사기 및 캐시 만료 제어를 사용하여 객체가 항상 최신 상태임을 보장합니다.

### 2) 엔터티 및 인코딩 관련 주요 기능

> 본 장에서 다루는 주요 내용은 HTTP 엔터티와 관련된 헤더 필드 및 전송 기술입니다.

**1. HTTP 메시지 엔터티 포맷 및 동작**

* HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 구조와 작동 방식.



**2. 콘텐츠 크기 및 식별 헤더**

* 엔터티 본문의 크기를 기술하고 측정하는 방법. (예: `Content-Length`)
* 클라이언트가 콘텐츠를 바르게 처리하도록 제공되는 식별 헤더들:
  * `Content-Type`: 콘텐츠의 포맷
  * `Content-Language`: 콘텐츠의 언어
  * `Content-Charset`: 콘텐츠의 문자 집합 (문맥상 `Content-Type`에 포함되거나 별도로 사용됨)



**3. 인코딩 기술**

* 콘텐츠 인코딩 (Content Encoding):
  * 발송자가 공간을 절약하고 **더 안전하게 만들기 위해 콘텐츠 데이터 포맷을 변형할 때 사용**합니다. (예: 압축)
  * 수신 시 디코딩 가능한 형태로 전송됩니다.
* 전송 인코딩 (Transfer Encoding):
  * HTTP가 데이터를 실어 나르는 방식을 수정하여 특정 종류의 콘텐츠 송수신을 개선합니다.
  * 청크 인코딩 (Chunked Encoding): 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 `조각(청크)`으로 쪼개 전달하는 방식.



**4. 캐싱 및 최신 버전 제어**

* 엔터티 검사기 (Validators):
  * 콘텐츠의 버전 번호처럼 동작하여, 웹 애플리케이션이 최신 콘텐츠를 가지고 있음을 확신하도록 돕습니다.
  * 태그(`ETag` 등), 라스트 수정 시간(`Last-Modified` 등) 같은 검사기들을 사용하여 클라이언트가 최신 버전을 가져올 수 있게 합니다.



**5. 효율적인 전송 기능**

* 범위 요청 (Range Request):
  * 중단되었던 다운로드를 중단된 지점부터 재개하고자 할 때 유용합니다. (부분 요청)
* 델타 인코딩 (Delta Encoding) 확장:
  * 클라이언트가 이전에 본 웹 페이지를 다시 볼 때, 이후 변경된 부분만 요청할 수 있게 해줍니다. (대역폭 절약)
* 요약 (Digest) / 체크섬:
  * 엔터티 본문의 체크섬을 사용하여, 엔터티 콘텐츠가 프록시 등을 지나는 과정에서 변경되지 않았는지 탐지합니다.

{% hint style="warning" %}
이러한 메커니즘을 통해 HTTP는 전 세계 웹 트래픽의 핵심을 이루는 미디어 객체 전송을 정확하고 안전하며 효율적으로 수행합니다.
{% endhint %}

## 2. HTTP 엔터티와 Content-Length

### 1) HTTP 엔터티 및 주요 엔터티 헤더 요약

**HTTP 엔터티의 정의**

* HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 본다면, HTTP 엔터티는 메시지의 `실질적인 화물(Payload)`입니다.
* 엔터티는 <mark style="color:red;">엔터티 헤더와 엔터티 본문</mark>으로 구성됩니다.
* **엔터티 본문**은 <mark style="color:red;">가공되지 않은 순수한 데이터</mark>를 담고 있으며, **엔터티 헤더**는 이 데이터의 의미(타입, 길이, 인코딩 등)를 설명합니다.



**HTTP/1.1의 10가지 주요 엔터티 헤더**

| **헤더 필드**            | **역할 (요약)**                                              |
| -------------------- | -------------------------------------------------------- |
| $$Content-Type$$     | 전달된 객체의 미디어 종류 (예: $$ $\text{text/plain, image/gif}$ $$) |
| $$Content-Length$$   | 전달되는 메시지 본문의 바이트 길이 또는 크기                                |
| $$Content-Language$$ | 전달된 객체와 가장 잘 대응되는 자연어                                    |
| $$Content-Encoding$$ | 객체 데이터에 가해진 변형 (예: 압축)                                   |
| $$Content-Location$$ | 요청 시점을 기준으로 객체의 다른 위치                                    |
| $$Content-Range$$    | 부분 엔터티일 경우, 전체에서 어느 부분에 해당하는지 정의                         |
| $$Content-MD5$$      | 엔터티 본문 콘텐츠에 대한 체크섬 (무결성 검증)                              |
| $$Last-Modified$$    | 서버에서 이 콘텐츠가 생성/수정된 날짜와 시각                                |
| $$Expires$$          | 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되는 날짜/시각                   |
| $$Allow$$            | 이 리소스에 대해 허용되는 요청 메서드 (예: $$ $\text{GET, HEAD}$ $$)      |

* 관련 헤더 (`Strictly` 엔터티 헤더는 아님): `ETag` (고유 검사기), `Cache-Control`(캐싱 지시자)는 엔터티와 관련된 중요한 동작을 위해 사용됩니다.

***

### 2) Content-Length와 엔터티 길이 판별

#### Content-Length의 역할

* 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냅니다.
* 인코딩된(압축된) 본문이 전송될 경우, $\text{Content-Length}$는 인코딩된 후의 크기를 나타냅니다.
* 메시지 잘림 검출 및 \*\*지속 커넥션(Persistent Connection)\*\*에서 다음 메시지의 시작점을 구분하는 데 필수적입니다.

#### 엔터티 본문 길이 판별 규칙 (우선순위 순)

엔터티 본문의 길이를 결정하는 규칙은 다음과 같이 순서대로 적용됩니다 (규칙의 현행화는 아래 3절에서 다룹니다).

1. 본문이 허용되지 않는 메시지 유형: $$ $\text{HEAD}$ $$ 응답, $$ $\text{1XX}$ $$, $$ $\text{204}$ $$, $$ $\text{304}$ $$ 응답은 $$ $\text{Content-Length}$ $$ 헤더 유무와 상관없이 본문을 갖지 않으며, 헤더 이후의 첫 번째 빈 줄($$ $\text{CRLF}$ $$)에서 끝납니다.
2. $$ $\text{Transfer-Encoding}$ $$ 헤더 존재 시: $$ $\text{Transfer-Encoding}$ $$ 헤더가 $\text{identity}$가 아닌 경우 (예: $$ $\text{chunked}$ $$), 엔터티는 '0 바이트 청크' 패턴으로 끝납니다. 이 경우 $\text{Content-Length}$는 무시됩니다.
3. $$ $\text{Content-Length}$ $$ 헤더 존재 시: 메시지 유형이 본문을 허용하고 $\text{Transfer-Encoding}$이 없는 경우, $$ $\text{Content-Length}$ $$ 값이 본문의 길이를 나타냅니다. (2번 규칙에 따라, $\text{Transfer-Encoding}$과 $\text{Content-Length}$$ $가 모두 있다면 **$ $$\text{Transfer-Encoding}$이 우선\*\*하며 $\text{Content-Length}$는 무시되어야 합니다.)
4. $$ $\text{multipart/byteranges}$ $$: $\text{Content-Length}$가 정의되지 않은 경우, 각 멀티파트 부분이 자체적으로 크기를 정의합니다.
5. 커넥션 닫힘: 위의 어떤 규칙에도 해당되지 않는 경우, 엔터티는 커넥션이 닫힐 때 끝납니다. (주로 서버만 이를 이용해 메시지 끝을 알릴 수 있음)
6. (구 HTTP/1.0 호환 규칙): $$ $\text{HTTP/1.1}$ $$ 요청이 본문을 가지면 $\text{Content-Length}$$ $를 포함해야 한다는 규칙은 **$ $$\text{RFC 7230}$에서 삭제\*\*되었습니다. (아래 현행화 참고)

***

### 🔄 3. 현행화 및 $$ $\text{HTTP/1.1}$ $$ 최신 규격 (RFC 7230/7231 기준)

제시된 텍스트는 HTTP: The Definitive Guide와 같은 과거의 서적 내용을 반영하고 있어, \*\*$\text{HTTP/1.1}$의 2014년 개정 사양($\text{RFC 7230}$ 시리즈)\*\*에 따라 일부 내용이 업데이트되었습니다.

| **과거/원문 내용**                                                       | **RFC 7230/7231 기반 현행화 (주요 변경점)**                                                                                                                     |
| ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| $\text{HTTP/1.1}$은 10가지 주요 엔터티 헤더를 정의함.                            | $\text{RFC 7231}$에서 엔터티 헤더라는 용어는 \*\*표현 헤더(Representation Headers)\*\*로 대체되었습니다. (예: $$ $\text{Content-Type, Content-Length, Content-Encoding}$ $$ 등) |
| 6번 규칙: $$ $\text{HTTP/1.1}$ $$ 요청은 $\text{Content-Length}$를 가져야 함. | 이 규칙은 $\text{RFC 7230}$에서 삭제되었습니다. $\text{Transfer-Encoding: chunked}$를 사용하여 요청 본문의 길이를 명시하지 않고도 전송하는 것이 일반적입니다.                                      |
| $$ $\text{Content-MD5}$ $$ 헤더                                      | 보안상의 이유 등으로 $\text{RFC 7231}$에서 더 이상 사용하지 않도록 권고됩니다. (실제 무결성 확인은 $\text{TLS}$나 다른 상위 계층 프로토콜에 의존)                                                     |

#### 가장 중요한 현행화: 메시지 길이 판별 우선순위

최신 $\text{HTTP/1.1}$에서는 메시지 본문 길이 판별 시 다음의 우선순위가 명확하게 정의됩니다.

1. $$ $\text{Transfer-Encoding}$ $$ 헤더의 존재
2. $$ $\text{Content-Length}$ $$ 헤더의 존재
3. 본문이 없는 메시지 유형 (예: $$ $\text{HEAD}$ $$ 응답, $$ $\text{204}$ $$ 응답)
4. $$ $\text{multipart/byteranges}$ $$
5. 커넥션 닫힘

요약: $$ $\text{Transfer-Encoding}$ $$ (특히 $$ $\text{chunked}$ $$)은 $\text{Content-Length}$보다 항상 우선합니다.

***

### 📚 4. 더 공부해야 할 내용

제시된 텍스트는 $$ $\text{HTTP}$ $$ 통신의 핵심인 엔터티와 메시지 길이 판별을 다루고 있으므로, 다음 영역에 대한 심층 학습이 필요합니다.

#### 1. 전송 및 콘텐츠 인코딩 (Encoding)

* $$ $\text{Content-Encoding}$ $$: 데이터를 압축(예: $$ $\text{gzip, deflate}$ $$)하여 전송 효율을 높이는 방법과 클라이언트/서버가 이를 협상하는 방식($$ $\text{Accept-Encoding}$ $$ 헤더).
* $$ $\text{Transfer-Encoding}$ $$: \*\*청크 인코딩 (Chunked Encoding)\*\*을 중심으로, 서버가 엔터티의 전체 크기를 모르거나 동적으로 생성할 때 어떻게 데이터를 안전하게 전송하는지.

#### 2. 캐싱 (Caching)

* $$ $\text{Expires, Last-Modified, ETag, Cache-Control}$ $$ 헤더들이 협력하여 \*\*객체의 신선도(freshness)\*\*와 \*\*유효성 재검사(revalidation)\*\*를 어떻게 제어하는지. $\text{Content-Length}$가 잘림 검출을 통해 캐시의 무결성을 어떻게 돕는지와 연결됩니다.

#### 3. $$ $\text{Content-Length}$ $$ 문제와 보안

* HTTP Desync/Smuggling 공격: $\text{Content-Length}$와 $$ $\text{Transfer-Encoding}$ $$ 헤더를 프록시와 백엔드 서버가 다르게 해석하여 발생하는 보안 취약점. 이는 메시지 길이 판별 규칙의 중요성을 극단적으로 보여줍니다.

이러한 내용을 학습하시면 $$ $\text{HTTP}$ $$ 엔터티와 인코딩에 대한 이해를 현대적인 웹 환경에 맞게 완성할 수 있습니다.





## 참고하면 좋을 링크

* HTTP 개요 : [https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview)
