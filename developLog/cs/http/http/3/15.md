# 15장 엔터티와 인코딩

## 1. HTTP 엔터티의 역할과 보장 사항

HTTP는 이미지, 텍스트, 동영상 등 모든 종류의 미디어 객체(콘텐츠)를 전송하며, 이 콘텐츠는 엔터티라는 잘 라벨링된 컨테이너를 통해 운반됩니다.

<figure><img src="../../../../.gitbook/assets/image (430).png" alt=""><figcaption><p><a href="https://www.wallarm.com/what/http-headers">https://www.wallarm.com/what/http-headers</a></p></figcaption></figure>

### 1) HTTP가 보장하는 핵심 기능

<figure><img src="../../../../.gitbook/assets/image (429).png" alt=""><figcaption><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview</a></p></figcaption></figure>

* 객체의 올바른 식별 및 처리:
  * `Content-Type` (미디어 포맷) 및 `Content-Language` 헤더를 사용하여 객체를 정확하게 식별합니다.
  * 이를 통해 브라우저나 클라이언트가 콘텐츠를 올바르게 처리할 수 있습니다.
* 사용자 요구 충족 (콘텐츠 협상):
  * `Accept` 관련 헤더에 기반하여 사용자의 요구사항(선호하는 언어, 형식 등)을 만족하는 콘텐츠를 제공합니다.
* 빠르고 효율적인 네트워크 이동:
  * 범위 요청(Range Request), 델타 인코딩(Delta Encoding), 데이터 압축 등을 사용하여 효율적인 전송을 보장합니다.
* 객체의 무결성 및 온전한 도착:
  * `Transfer-Encoding` 헤더와 `Content-MD5` 체크섬을 사용하여 전송 과정에서 조작되지 않고 온전하게 도착하도록 합니다.
* 객체의 올바른 압축 해제:
  * `Content-Length`와 `Content-Encoding` 헤더를 사용하여 객체가 올바르게 압축이 풀릴 수 있도록 합니다.
* 항상 최신 상태 유지:
  * 엔터티 검사기 및 캐시 만료 제어를 사용하여 객체가 항상 최신 상태임을 보장합니다.

### 2) 엔터티 및 인코딩 관련 주요 기능

> 본 장에서 다루는 주요 내용은 HTTP 엔터티와 관련된 헤더 필드 및 전송 기술입니다.

**1. HTTP 메시지 엔터티 포맷 및 동작**

* HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 구조와 작동 방식.



**2. 콘텐츠 크기 및 식별 헤더**

* 엔터티 본문의 크기를 기술하고 측정하는 방법. (예: `Content-Length`)
* 클라이언트가 콘텐츠를 바르게 처리하도록 제공되는 식별 헤더들:
  * `Content-Type`: 콘텐츠의 포맷
  * `Content-Language`: 콘텐츠의 언어
  * `Content-Charset`: 콘텐츠의 문자 집합 (문맥상 `Content-Type`에 포함되거나 별도로 사용됨)



**3. 인코딩 기술**

* 콘텐츠 인코딩 (Content Encoding):
  * 발송자가 공간을 절약하고 **더 안전하게 만들기 위해 콘텐츠 데이터 포맷을 변형할 때 사용**합니다. (예: 압축)
  * 수신 시 디코딩 가능한 형태로 전송됩니다.
* 전송 인코딩 (Transfer Encoding):
  * HTTP가 데이터를 실어 나르는 방식을 수정하여 특정 종류의 콘텐츠 송수신을 개선합니다.
  * 청크 인코딩 (Chunked Encoding): 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 `조각(청크)`으로 쪼개 전달하는 방식.



**4. 캐싱 및 최신 버전 제어**

* 엔터티 검사기 (Validators):
  * 콘텐츠의 버전 번호처럼 동작하여, 웹 애플리케이션이 최신 콘텐츠를 가지고 있음을 확신하도록 돕습니다.
  * 태그(`ETag` 등), 라스트 수정 시간(`Last-Modified` 등) 같은 검사기들을 사용하여 클라이언트가 최신 버전을 가져올 수 있게 합니다.



**5. 효율적인 전송 기능**

* 범위 요청 (Range Request):
  * 중단되었던 다운로드를 중단된 지점부터 재개하고자 할 때 유용합니다. (부분 요청)
* 델타 인코딩 (Delta Encoding) 확장:
  * 클라이언트가 이전에 본 웹 페이지를 다시 볼 때, 이후 변경된 부분만 요청할 수 있게 해줍니다. (대역폭 절약)
* 요약 (Digest) / 체크섬:
  * 엔터티 본문의 체크섬을 사용하여, 엔터티 콘텐츠가 프록시 등을 지나는 과정에서 변경되지 않았는지 탐지합니다.

{% hint style="warning" %}
이러한 메커니즘을 통해 HTTP는 전 세계 웹 트래픽의 핵심을 이루는 미디어 객체 전송을 정확하고 안전하며 효율적으로 수행합니다.
{% endhint %}

## 2. HTTP 엔터티와 Content-Length

### 1) HTTP 엔터티 및 주요 엔터티 헤더 요약

**HTTP 엔터티의 정의**

* HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 본다면, HTTP 엔터티는 메시지의 `실질적인 화물(Payload)`입니다.
* 엔터티는 <mark style="color:red;">엔터티 헤더와 엔터티 본문</mark>으로 구성됩니다.
* **엔터티 본문**은 <mark style="color:red;">가공되지 않은 순수한 데이터</mark>를 담고 있으며, **엔터티 헤더**는 이 데이터의 의미(타입, 길이, 인코딩 등)를 설명합니다.



**HTTP/1.1의 10가지 주요 엔터티 헤더**

| **헤더 필드**            | **역할 (요약)**                                              |
| -------------------- | -------------------------------------------------------- |
| $$Content-Type$$     | 전달된 객체의 미디어 종류 (예: $$ $\text{text/plain, image/gif}$ $$) |
| $$Content-Length$$   | 전달되는 메시지 본문의 바이트 길이 또는 크기                                |
| $$Content-Language$$ | 전달된 객체와 가장 잘 대응되는 자연어                                    |
| $$Content-Encoding$$ | 객체 데이터에 가해진 변형 (예: 압축)                                   |
| $$Content-Location$$ | 요청 시점을 기준으로 객체의 다른 위치                                    |
| $$Content-Range$$    | 부분 엔터티일 경우, 전체에서 어느 부분에 해당하는지 정의                         |
| $$Content-MD5$$      | 엔터티 본문 콘텐츠에 대한 체크섬 (무결성 검증)                              |
| $$Last-Modified$$    | 서버에서 이 콘텐츠가 생성/수정된 날짜와 시각                                |
| $$Expires$$          | 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되는 날짜/시각                   |
| $$Allow$$            | 이 리소스에 대해 허용되는 요청 메서드 (예: $$ $\text{GET, HEAD}$ $$)      |

* 관련 헤더 (`Strictly` 엔터티 헤더는 아님): `ETag` (고유 검사기), `Cache-Control`(캐싱 지시자)는 엔터티와 관련된 중요한 동작을 위해 사용됩니다.

***

### 2) Content-Length와 엔터티 길이 판별

#### Content-Length의 역할

<figure><img src="../../../../.gitbook/assets/image (431).png" alt=""><figcaption></figcaption></figure>

* 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냅니다.
* 인코딩된(압축된) 본문이 전송될 경우, Content-Length는 인코딩된 후의 크기를 나타냅니다.
* 메시지 잘림 검출 및 `지속 커넥션(Persistent Connection)`에서 다음 메시지의 시작점을 구분하는 데 필수적입니다.

#### 엔터티 본문 길이 판별 규칙 (우선순위 순)

아래처럼 **`$text{}` 같은 잘못 들어간 수식 마크업만 제거해서** 깔끔하게 정리해줄게!

***

#### ✔️ 엔터티 본문 길이 판별 규칙 (우선순위 순)

엔터티 본문의 길이를 결정하는 규칙은 아래 순서대로 적용된다.\
(규칙의 최신화는 아래 3절에서 다룸)

| 우선순위  | 적용 조건                                                        | 엔터티 본문 길이 판단 방식                        | 비고                      |
| ----- | ------------------------------------------------------------ | -------------------------------------- | ----------------------- |
| **1** | 메시지 유형이 본문을 허용하지 않는 경우→ `HEAD`, `1xx`, `204`, `304`          | 헤더 이후 첫 번째 빈 줄에서 끝                     | 어떤 헤더가 있어도 본문 없음        |
| **2** | `Transfer-Encoding` 헤더 존재그리고 값이 `identity`가 아님 (`chunked` 등) | **0-byte chunk (`0\r\n\r\n`)가 엔터티의 끝** | `Content-Length`는 무시됨   |
| **3** | `Content-Length` 헤더 존재그리고 `Transfer-Encoding` 없음             | **Content-Length 값만큼 바이트 수를 본문으로 해석**  | 일반적인 HTTP/1.1 메시지 구조    |
| **4** | `multipart/*` 본문`Content-Length` 없음                          | boundary 기반 파트별 구분                     | 멀티파트 폼, 이메일 MIME과 동일 구조 |
| **5** | 위 조건 어디에도 해당되지 않음                                            | **커넥션 종료 시 엔터티 종료**                    | 서버가 연결을 닫으며 본문 끝 알림     |
| **6** | (레거시) HTTP/1.0 호환 규칙                                         | RFC 7230에서 삭제됨                         | GET 본문 등 혼란 요소 제거됨      |

**요약 보기**

| 규칙                       | 본문 길이 결정 방식               | 언제 사용됨              |
| ------------------------ | ------------------------- | ------------------- |
| **본문 없음 규칙**             | 빈 줄 이후 끝                  | HEAD, 1xx, 204, 304 |
| **Transfer-Encoding 우선** | chunked → `0\r\n\r\n`로 종료 | 대용량 스트리밍, 동적 응답     |
| **Content-Length**       | 명시된 길이만큼 읽음               | 대부분의 일반 응답          |
| **멀티파트**                 | boundary로 구분              | 파일 업로드, 폼 데이터       |
| **커넥션 종료**               | 연결이 닫히면 끝                 | HTTP/1.0 스타일, 예외적   |
| **레거시 규칙 삭제**            | 적용 X                      | 최신 HTTP 표준에서는 무효    |

***

### 3) 현행화 및 $$ $\text{HTTP/1.1}$ $$ 최신 규격 (RFC 7230/7231 기준)

이  책은 _HTTP: The Definitive Guide_ 등 과거 서적 내용을 반영하고 있어, **HTTP/1.1의 2014년 개정 사양(RFC 7230 시리즈)**&#xC5D0; 따라 일부 내용이 업데이트되었습니다.

| 과거/원문 내용                                   | RFC 7230/7231 기반 현행화 (주요 변경점)                                                                                                    |
| ------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| HTTP/1.1은 10가지 주요 엔터티 헤더를 정의함.             | RFC 7231에서 엔터티 헤더라는 용어는 **표현 헤더(Representation Headers)**&#xB85C; 대체되었습니다. (예: Content-Type, Content-Length, Content-Encoding 등) |
| 6번 규칙: HTTP/1.1 요청은 Content-Length를 가져야 함. | <mark style="color:red;">이 규칙은 RFC 7230에서 삭제되었습니다.</mark> Transfer-Encoding: chunked를 사용하여 요청 본문의 길이를 명시하지 않고도 전송하는 것이 일반적입니다.   |
| Content-MD5 헤더                             | 보안상의 이유 등으로 RFC 7231에서 더 이상 사용하지 않도록 권고됩니다. (실제 **무결성 확인은 TLS나 다른 상위 계층 프로토콜에 의존**)                                              |

**🔎 가장 중요한 현행화: 메시지 길이 판별 우선순위**

최신 HTTP/1.1에서는 메시지 본문 길이를 판별할 때 다음 우선순위가 명확하게 정의됩니다.

1. **Transfer-Encoding 헤더의 존재**
2. **Content-Length 헤더의 존재**
3. **본문이 없는 메시지 유형**\
   예: `HEAD` 응답, `1xx`, `204`, `304` 응답
4. **커넥션 종료 기반 메시지 종료**

{% hint style="success" %}
**Transfer-Encoding(특히 chunked)** 은 **Content-Length보다 항상 우선**합니다.
{% endhint %}



***

### 4) 더 공부해야 할 내용

통신의 핵심인 엔터티와 메시지 길이 판별을 다루고 있으므로, 다음 영역에 대한 심층 학습이 필요합니다.

#### 1. 전송 및 콘텐츠 인코딩 (Encoding)

* $$ $\text{Content-Encoding}$ $$: 데이터를 압축(예: $$ $\text{gzip, deflate}$ $$)하여 전송 효율을 높이는 방법과 클라이언트/서버가 이를 협상하는 방식($$ $\text{Accept-Encoding}$ $$ 헤더).
* $$ $\text{Transfer-Encoding}$ $$: `청크 인코딩 (Chunked Encoding)`을 중심으로, 서버가 엔터티의 전체 크기를 모르거나 동적으로 생성할 때 어떻게 데이터를 안전하게 전송하는지.

#### 2. 캐싱 (Caching)

* $$ $\text{Expires, Last-Modified, ETag, Cache-Control}$ $$ 헤더들이 협력하여 `객체의 신선도(freshness)`와 `유효성 재검사(revalidation)`를 어떻게 제어하는지. $\text{Content-Length}$가 잘림 검출을 통해 캐시의 무결성을 어떻게 돕는지와 연결됩니다.

#### 3. $$ $\text{Content-Length}$ $$ 문제와 보안

* HTTP Desync/Smuggling 공격: Content-Length와 $$ $\text{Transfer-Encoding}$ $$ 헤더를 프록시와 백엔드 서버가 다르게 해석하여 발생하는 보안 취약점. 이는 메시지 길이 판별 규칙의 중요성을 극단적으로 보여줍니다.



### 5) 아래는 **모든 `$text{}` 마크업을 제거하고**, 자연스러운 문장으로만 다시 정리한 버전이야. 내용은 그대로 유지하되, 수식 마크업 없이 깔끔하게 작성했어.

***

### 📚 심층 학습 내용 보완 설명

제시된 '더 공부해야 할 내용' 목록에 대한 구체적인 설명과 핵심 개념을 보완해 드립니다.

***

#### 1. 전송 및 콘텐츠 인코딩 (Encoding)

**콘텐츠 인코딩 (Content-Encoding)**

* **정의:** 데이터를 압축하여 전송 효율을 높이는 방식. 이 인코딩은 **엔터티 본문**에 적용되며, 전송 후 클라이언트에서 디코딩됩니다.
* **보완 설명:**
  * **Content-Encoding:** 데이터를 압축(예: gzip, deflate, br(Brotli))하여 전송 효율을 높이는 방법입니다.
  * **협상 방식:** 클라이언트는 Accept-Encoding 헤더로 수용 가능한 압축 방식을 알리고, 서버는 그중 하나를 선택해 Content-Encoding 헤더로 응답합니다.
* **Content-Length와의 관계:** Content-Encoding이 적용되면, Content-Length는 **압축된 데이터의 크기**를 나타냅니다.

***

**전송 인코딩 (Transfer-Encoding)**

* **정의:** 엔터티 데이터를 "어떻게 전송할지"를 정의하는 방식입니다. 이는 메시지 자체에 적용되며 메시지 경계를 정의하는 메커니즘입니다.
* **핵심 기능 – Chunked 인코딩:**\
  Transfer-Encoding: chunked는 서버가 **전체 본문 길이를 미리 알 수 없을 때**, 데이터를 일정 크기의 청크로 나누어 전송합니다.
* **Content-Length와의 관계:**\
  Transfer-Encoding, 특히 chunked가 존재하면 **Content-Length는 무시됩니다.**

***

#### 2. 캐싱 (Caching)

* **핵심 헤더들:**
  * Expires
  * Last-Modified
  * ETag
  * Cache-Control

이 헤더들은 \*\*신선도(freshness)\*\*와 \*\*유효성 재검사(revalidation)\*\*를 제어합니다.

**신선도 (Freshness)**

* Expires 또는 Cache-Control: max-age 지시자로 캐시된 사본을 서버에 재확인 없이 사용할 수 있는 기간을 정함.

**유효성 재검사 (Revalidation)**

* 신선도가 만료된 후 캐시된 사본이 여전히 유효한지 서버에 검증 요청함.
* Last-Modified ↔ If-Modified-Since
* ETag ↔ If-None-Match

**Content-Length와 캐싱의 관계**

* 캐시 서버는 Content-Length를 통해 **메시지가 잘리지 않았는지** 검증합니다.
* 잘린 콘텐츠를 캐시하면 사용자에게 잘못된 데이터가 전달되어 심각한 오류가 발생함.

***

#### 3. 메시지 길이 문제와 보안

* **핵심 보완 내용:**\
  Content-Length와 Transfer-Encoding을 프록시와 백엔드 서버가 다르게 해석할 때 발생하는 보안 취약점.

**HTTP Request Smuggling / Desync 공격**

* 프록시 서버와 백엔드 서버가 메시지의 끝을 **다른 기준으로 해석**할 때 공격자가 이를 악용할 수 있습니다.
* 예시 상황:
  * 프록시는 Content-Length를 기준으로 요청을 종료
  * 백엔드는 Transfer-Encoding: chunked 기준으로 요청 해석
* 이때 공격자는 두 시스템이 다르게 해석하는 “숨겨진 요청(smuggled request)”을 삽입할 수 있음.

**결과**

* 인증 우회
* 세션 하이재킹
* 다른 사용자 요청 조작
* 캐시 오염 등 다양한 공격 가능

**방어 전략**

* 프록시와 백엔드가 메시지 길이 처리 방식을 **완전히 일치**시키기
* Transfer-Encoding이 존재할 경우 Content-Length 제거
* 중복 헤더 허용 금지 등 엄격한 파싱 규칙 적용

***

필요하면 이 내용을 **RFC 스타일 표**, **모바일용 슬라이드 요약**, **블로그용 스토리텔링 버전** 등으로도 재구성해줄게!





## 참고하면 좋을 링크

* HTTP 개요 : [https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview)
