---
icon: clock-eleven-thirty
---

# 11장 성능을 위한 알고리즘



🧠 주제: **계산을 피하라! – 표와 근사로 속도를 얻는 기술들**

> “정확히 계산하는 것보다, 아예 계산하지 않는 게 빠르다!”

### 1. **왜 계산을 피하려고 할까?**

컴퓨터는 빠르고 정밀하다고 생각하기 쉽지만, 현실은 그렇게 단순하지 않습니다.

* **정확성(Accuracy)**: 결과가 정답에 얼마나 가까운가?
* **정밀성(Precision)**: 같은 계산을 반복했을 때 결과들이 얼마나 일관적인가?

컴퓨터는 **정밀성은 강하지만 정확성은 상황에 따라 한계가 있습니다.** 특히 실수(float, double)는 근사값입니다.

> 예: `π = 3.1415926535...` 을 매번 계산할까요? 절대 아닙니다. 필요한 자리수까지만 기억하면 됩니다.

그래서 등장한 아이디어가 두 가지입니다:

#### 1) **지름길 (Shortcut)**

* 미리 계산된 값을 테이블로 만들어서 사용
* 대표 예시: 삼각함수, 로그, 온도 변환, 텍스처 매핑 등

#### 2) **근삿값 (Approximation)**

* 정밀도가 약간 떨어지더라도 계산량을 줄이기 위해 간단한 계산이나 추정 사용
* 대표 예시: 게임 렌더링, 필터링, 피라미드 이미지(MIP 맵)

### 📐 2. **표로 계산을 대신한다 – Lookup Table**

{% hint style="success" %}
직접 계산하는 것보다 표에서 무언가를 찾는 게 훨씬 더 빠른 경우가 종종 있습니다.&#x20;
{% endhint %}

표 찾기는 어떤 계산을 많이 하는 경우 **그 결과를 미리 계산해서 반복 사용하는 편이 합리적**이라는 측면에서 8장에서 설명한 `루프 불변값 최적화`와 비슷합니다.

#### 예시: **온도 센서 보정**

```plaintext
A/D 변환기 → 전압(v) → 로그함수 포함된 복잡한 계산식 → 온도(t)
```

> 이걸 매번 계산한다면?

너무 느리죠! 그래서 다음과 같이 처리합니다:

#### 👉 해결 방법

* 10비트 A/D 변환기 → 최대 1024 값
* 8비트 온도 테이블을 만들어, 각 A/D 값에 대응하는 온도를 미리 저장
* 필요할 때 `temp = lookup[vin]` 으로 끝!

```c
unsigned char lookup[1024];  // A/D값 → 온도
```

> 계산을 단 한 번도 하지 않고, 빠르게 온도값을 얻을 수 있습니다.

<figure><img src="../../.gitbook/assets/image (337).png" alt=""><figcaption></figcaption></figure>

### 3. **3D 그래픽의 핵심 – 텍스처 매핑과 MIP Mapping**

{% hint style="warning" %}
#### 🎮 게임 속 벽돌을 보면?

* 가까이 있으면 선명하게
* 멀어지면 흐릿하게

이런 효과를 어떻게 줄까요?
{% endhint %}

#### 전통적 방법

1. 벽 텍스처에서 해당 좌표의 색을 가져오기
2. 멀리 있으면 평균을 내거나 다운스케일
3. 너무 느림!

#### ✅ 해결책: **MIP 맵(Multum in Parvo)**

<figure><img src="../../.gitbook/assets/image (339).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (338).png" alt=""><figcaption></figcaption></figure>

* **아이디어**: 텍스처의 여러 해상도 버전을 미리 계산해 저장
* 더 멀리 떨어진 물체에는 **저해상도 버전**을 사용
* 그림처럼 **피라미드 구조**로 저장

```plaintext
원본 64x64 → 32x32 → 16x16 → 8x8 ... → 1x1까지 저장
```

#### 🧠 이점

* 계산 없음 → 빠르다!
* 시점에 따라 적절한 해상도 선택
* 부드러운 전환 → 시각적으로도 깔끔

MIP 맵은 지금도 **게임 엔진 / 그래픽 카드 / 영상 합성기**에 기본 적용됩니다.

### 4. **문자 종류 판별 – if문보다 빠른 방법은?**

#### 전통적 접근

```c
int isdigit(int c) {
  return c >= '0' && c <= '9';
}
```

#### 문제점?

* 매번 조건 판단
* 코드가 반복됨

#### ✨ 해결책: **표를 만들자!**

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

* 아스키 코드(0\~127)에 대해 속성을 비트로 저장

| 문자 | 비트 표현    |
| -- | -------- |
| A  | 00000010 |
| a  | 00000101 |
| 0  | 00001100 |

* 각 문자에 대해 아래처럼 비트를 부여

```c
#define UPPER      0x01
#define LOWER      0x02
#define DIGIT      0x04
#define HEXADECIMAL 0x08
```

#### 매크로로 한 줄 처리 가능

```c
#define isdigit(c) (table[(c)&0x7f] & DIGIT)
#define isalpha(c) (table[(c)&0x7f] & (UPPER | LOWER))
```

> **조건문 없이 비트 연산 한 번!**

이 방법은 무려 **20배나 빠르다**고 합니다. 벨 연구소에서 리치가 결국 채택했을 정도니까요.

### 🧠 5. 매크로 vs 함수

| 구분    | 매크로                          | 함수             |
| ----- | ---------------------------- | -------------- |
| 실행 속도 | 빠름 (치환)                      | 비교적 느림 (함수 호출) |
| 부작용   | 높음 (재평가 위험)                  | 낮음             |
| 사용 예  | isdigit(\*p++)와 같이 사용할 경우 위험 | 함수는 안전         |

**결론**: 매우 단순한 연산에는 매크로, 그렇지 않으면 함수!

### 🧠 정리: “계산하지 않을 수 있다면, 계산하지 마라!”

| 기술           | 설명                       | 사용 사례               |
| ------------ | ------------------------ | ------------------- |
| Lookup Table | 결과값을 미리 저장해 사용           | 온도 변환, 로그값, 삼각함수    |
| MIP Mapping  | 낮은 해상도 이미지를 계층으로 미리 저장   | 게임 텍스처, 거리 기반 렌더링   |
| 문자 판별 표      | ASCII 문자 속성 정보를 비트로 저장   | 언어 처리, 컴파일러, 문법 분석기 |
| 매크로 최적화      | 함수를 매크로로 치환하여 호출 오버헤드 제거 | 단순한 수식, 논리 조건 등     |

> **"계산은 컴퓨터가 빠르니까 시킨다?"**\
> 아니다. **계산을 안 할 수 있으면 안 하는 게 최고다!**

***

## 🎯 **정수만으로 그림을 그리자 – 계산 없이 속도로 승부하는 그래픽 알고리즘 이야기**

{% hint style="warning" %}
**“정수 + 덧셈만으로도 컴퓨터 그래픽을 완성할 수 있다고?”**\
지금부터 컴퓨터 역사상 가장 중요한 발명 중 하나인 ‘브레슨햄 알고리즘’을 시작으로,\
계산 없이 성능을 높이는 기술들을 살펴보겠습니다.
{% endhint %}

### 1. 왜 정수 계산인가?

컴퓨터 하드웨어는 연산의 종류에 따라 속도가 다릅니다.

| 연산 종류    | 속도    | 메모리/전력 사용량 |
| -------- | ----- | ---------- |
| 정수 덧셈/뺄셈 | 빠름    | 적음         |
| 정수 곱셈    | 중간    | 보통         |
| 부동소수점 연산 | 느림    | 많음         |
| 삼각함수, 로그 | 매우 느림 | 매우 많음      |

> 📌 결론: **가능하면 정수 덧셈/뺄셈만으로 표현하는 것이 가장 효율적이다.**

### 2. 캔버스에서 좌표계 변환 – 위아래가 바뀐 세상?

{% hint style="success" %}
캔버스는 웹에서 그래픽을 그릴 수 있는 HTML 요소입니다. 모눈종이처럼 생각하면 돼요
{% endhint %}

캔버스 모눈 종이는 기본적으로 표준적인 직교 좌표계를 사용하지 않기 때문에 우리가 그릴 때 쓰던 방식과 다릅니다. 이렇게 된 이유는 텔레비전에 래스터로 화면을 그리던 방향의 영향을 받았기 때문

기본적으로 사용되는 좌표계는 다음과 같습니다:

* (0, 0): **왼쪽 위**
* x축: → 오른쪽으로 증가
* y축: ↓ 아래로 증가 (**우리가 아는 좌표계와 반대**)

#### 🛠 좌표계 변환 코드

```js
canvas.translate(0, height);  // y축 기준 하단으로 평행이동
canvas.scale(1, -1);          // y축 방향 반전
```

### 3. 그리드와 직선 – 수학이 필요한 이유

격자선을 그리고 선을 그리는 기능을 자바스크립트로 구현해 보겠습니다.

#### 격자 그리기 코드

```js
var grid = 25;
canvas.scale(grid, grid);
canvas.setLineDash([0.1, 0.1]);  // 점선
```

### 4. 직선 그리기 – 부동소수점의 한계

아래 코드는 \*\*기울기 `m = y / x`\*\*를 사용해 점을 찍습니다.

```js
for (var x = 0; x <= width; x++) {
  var y = Math.round(m * x);
  canvas.arc(x, y, 0.15, 0, 2 * Math.PI);
}
```

📌 **문제점**

* `곱셈` + `소수점` + `반올림` → **느리다**
* **대각선 픽셀은 흩어져 보여 밝기가 낮게 보임**
* 부동소수점 연산은 정수보다 **성능이 2\~10배 느림**

### 5. 잭 브레슨햄의 혁신 – 덧셈으로 직선을 그린다!

1962년, **Jack Bresenham**은 IBM에서 근무하며 **CPU에 부동소수점이 없던 시절**\
순수 정수 덧셈만으로 직선을 그리는 방법을 고안했습니다.

#### 💡 아이디어

* 결정 변수 `d`를 설정하고 덧셈으로 x/y 방향을 판단
* 기울기 대신 변화량 `Δx`, `Δy`만 사용
* `d >= 0`이면 y를 증가시키고, 그렇지 않으면 x만 이동

#### ✅ 브레슨햄 알고리즘 코드 (JavaScript)

```js
var dx = width;
var dy = yValue;
var d = 2 * dy - dx;
var y = 0;

dx *= 2;
dy *= 2;

for (var x = 0; x <= width; x++) {
  canvas.arc(x, y, 0.4, 0, 2 * Math.PI); // 점 그리기

  if (d >= 0) {
    y++;
    d -= dx;
  }
  d += dy;
}
```

#### 🎯 결과

* **곱셈 없음**
* **정수 덧셈/뺄셈만 사용**
* **빠르고 정확**

### 6. 응용: 브레슨햄으로 그레이디언트 만들기

```js
var dc = 255;
var d = 2 * dc - dx;
var color = 0;

for (var x = 0; x <= width; x++) {
  var rgb = `rgb(${color}, ${color}, ${color})`;
  canvas.strokeStyle = rgb;
  canvas.moveTo(x, 0);
  canvas.lineTo(x, height);
  canvas.stroke();

  if (d >= 0) {
    color++;
    d -= 2 * dx;
  }
  d += 2 * dc;
}
```

#### 🟣 효과

* 정수만 사용해서 **수직 그라데이션**
* 부드럽고 빠르게 색상 변화 구현

### 7. 정수만으로 타원까지?

브레슨햄 알고리즘은 타원에도 확장됩니다.

#### 핵심 수식

```
Ax² + By² = AB
```

* `A = b²`, `B = a²`
* d (결정 변수)를 초기화하고, 세 방향 중 **가장 이상적인 방향 선택**

#### 타원 그리기 전략

* 수평, 수직, 대각선 세 점 비교 → `|d|`가 가장 작은 점 선택
* **좌표계의 1사분면만 계산**, 나머지는 대칭성으로 해결
* `(x, y)` → `(-x, y)`, `(-x, -y)`, `(x, -y)` 동시에 찍기

### 8. 정리

| 개념         | 설명                  | 예시                  |
| ---------- | ------------------- | ------------------- |
| 부동소수점 회피   | 계산 비용 높은 실수 연산 회피   | `y = mx + b` → 브레슨햄 |
| 브레슨햄 알고리즘  | 결정 변수로 선/타원 그리기     | 픽셀당 연산 최소화          |
| 대칭성 활용     | 1/4 계산 후 대칭으로 전체 구현 | 원, 타원 그리기           |
| 정수 기반 색 변화 | 점진적 덧셈으로 색상 변화      | 그레이디언트 구현           |

### 🧠 한 줄 요약

> **정수 계산은 낡았다고요?**\
> **오늘날 GPU와 게임엔진도 여전히 이 고전적인 알고리즘에 감사하고 있습니다.**

