---
icon: clock-eleven-thirty
---

# 11장 성능을 위한 알고리즘



🧠 주제: **계산을 피하라! – 표와 근사로 속도를 얻는 기술들**

> “정확히 계산하는 것보다, 아예 계산하지 않는 게 빠르다!”

### 1. **왜 계산을 피하려고 할까?**

컴퓨터는 빠르고 정밀하다고 생각하기 쉽지만, 현실은 그렇게 단순하지 않습니다.

* **정확성(Accuracy)**: 결과가 정답에 얼마나 가까운가?
* **정밀성(Precision)**: 같은 계산을 반복했을 때 결과들이 얼마나 일관적인가?

컴퓨터는 **정밀성은 강하지만 정확성은 상황에 따라 한계가 있습니다.** 특히 실수(float, double)는 근사값입니다.

> 예: `π = 3.1415926535...` 을 매번 계산할까요? 절대 아닙니다. 필요한 자리수까지만 기억하면 됩니다.

그래서 등장한 아이디어가 두 가지입니다:

#### 1) **지름길 (Shortcut)**

* 미리 계산된 값을 테이블로 만들어서 사용
* 대표 예시: 삼각함수, 로그, 온도 변환, 텍스처 매핑 등

#### 2) **근삿값 (Approximation)**

* 정밀도가 약간 떨어지더라도 계산량을 줄이기 위해 간단한 계산이나 추정 사용
* 대표 예시: 게임 렌더링, 필터링, 피라미드 이미지(MIP 맵)

### 📐 2. **표로 계산을 대신한다 – Lookup Table**

{% hint style="success" %}
직접 계산하는 것보다 표에서 무언가를 찾는 게 훨씬 더 빠른 경우가 종종 있습니다.&#x20;
{% endhint %}

표 찾기는 어떤 계산을 많이 하는 경우 **그 결과를 미리 계산해서 반복 사용하는 편이 합리적**이라는 측면에서 8장에서 설명한 `루프 불변값 최적화`와 비슷합니다.

#### 예시: **온도 센서 보정**

```plaintext
A/D 변환기 → 전압(v) → 로그함수 포함된 복잡한 계산식 → 온도(t)
```

> 이걸 매번 계산한다면?

너무 느리죠! 그래서 다음과 같이 처리합니다:

#### 👉 해결 방법

* 10비트 A/D 변환기 → 최대 1024 값
* 8비트 온도 테이블을 만들어, 각 A/D 값에 대응하는 온도를 미리 저장
* 필요할 때 `temp = lookup[vin]` 으로 끝!

```c
unsigned char lookup[1024];  // A/D값 → 온도
```

> 계산을 단 한 번도 하지 않고, 빠르게 온도값을 얻을 수 있습니다.

<figure><img src="../../.gitbook/assets/image (337).png" alt=""><figcaption></figcaption></figure>

### 3. **3D 그래픽의 핵심 – 텍스처 매핑과 MIP Mapping**

{% hint style="warning" %}
#### 🎮 게임 속 벽돌을 보면?

* 가까이 있으면 선명하게
* 멀어지면 흐릿하게

이런 효과를 어떻게 줄까요?
{% endhint %}

#### 전통적 방법

1. 벽 텍스처에서 해당 좌표의 색을 가져오기
2. 멀리 있으면 평균을 내거나 다운스케일
3. 너무 느림!

#### ✅ 해결책: **MIP 맵(Multum in Parvo)**

<figure><img src="../../.gitbook/assets/image (339).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (338).png" alt=""><figcaption></figcaption></figure>

* **아이디어**: 텍스처의 여러 해상도 버전을 미리 계산해 저장
* 더 멀리 떨어진 물체에는 **저해상도 버전**을 사용
* 그림처럼 **피라미드 구조**로 저장

```plaintext
원본 64x64 → 32x32 → 16x16 → 8x8 ... → 1x1까지 저장
```

#### 🧠 이점

* 계산 없음 → 빠르다!
* 시점에 따라 적절한 해상도 선택
* 부드러운 전환 → 시각적으로도 깔끔

MIP 맵은 지금도 **게임 엔진 / 그래픽 카드 / 영상 합성기**에 기본 적용됩니다.

### 4. **문자 종류 판별 – if문보다 빠른 방법은?**

#### 전통적 접근

```c
int isdigit(int c) {
  return c >= '0' && c <= '9';
}
```

#### 문제점?

* 매번 조건 판단
* 코드가 반복됨

#### ✨ 해결책: **표를 만들자!**

* 아스키 코드(0\~127)에 대해 속성을 비트로 저장

| 문자 | 비트 표현    |
| -- | -------- |
| A  | 00000010 |
| a  | 00000101 |
| 0  | 00001100 |

* 각 문자에 대해 아래처럼 비트를 부여

```c
#define UPPER      0x01
#define LOWER      0x02
#define DIGIT      0x04
#define HEXADECIMAL 0x08
```

#### 매크로로 한 줄 처리 가능

```c
#define isdigit(c) (table[(c)&0x7f] & DIGIT)
#define isalpha(c) (table[(c)&0x7f] & (UPPER | LOWER))
```

> **조건문 없이 비트 연산 한 번!**

이 방법은 무려 **20배나 빠르다**고 합니다. 벨 연구소에서 리치가 결국 채택했을 정도니까요.

### 🧠 5. 매크로 vs 함수

| 구분    | 매크로                          | 함수             |
| ----- | ---------------------------- | -------------- |
| 실행 속도 | 빠름 (치환)                      | 비교적 느림 (함수 호출) |
| 부작용   | 높음 (재평가 위험)                  | 낮음             |
| 사용 예  | isdigit(\*p++)와 같이 사용할 경우 위험 | 함수는 안전         |

**결론**: 매우 단순한 연산에는 매크로, 그렇지 않으면 함수!

### 🧠 정리: “계산하지 않을 수 있다면, 계산하지 마라!”

| 기술           | 설명                       | 사용 사례               |
| ------------ | ------------------------ | ------------------- |
| Lookup Table | 결과값을 미리 저장해 사용           | 온도 변환, 로그값, 삼각함수    |
| MIP Mapping  | 낮은 해상도 이미지를 계층으로 미리 저장   | 게임 텍스처, 거리 기반 렌더링   |
| 문자 판별 표      | ASCII 문자 속성 정보를 비트로 저장   | 언어 처리, 컴파일러, 문법 분석기 |
| 매크로 최적화      | 함수를 매크로로 치환하여 호출 오버헤드 제거 | 단순한 수식, 논리 조건 등     |

***

### 💡 요약 슬로건

> **"계산은 컴퓨터가 빠르니까 시킨다?"**\
> 아니다. **계산을 안 할 수 있으면 안 하는 게 최고다!**
