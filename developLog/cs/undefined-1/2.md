---
description: 컴퓨터는 어떤 논리로 비트를 다루는가
icon: '2'
---

# 2장 : 전자 회로의 조합 논리

> 대부분의 기술은 **다른 목적을 위해 만들어진 기술을 계산에** `적용`했을 뿐이다.&#x20;

1장에서는 현대 컴퓨터들이 `비트`라고 부르는 **2진 상자를 내부 언어로 사용한다는 사실**을 배웠다. 2장에서는 비트를 사용하지 않는 초기 계산 장치를 살펴봄으로써 <mark style="color:red;">**왜 비트가 오늘날 사용하는 기술에 어울리는 선택인지 배우게 된다.**</mark>

{% hint style="danger" %}
비트는 <mark style="color:red;">계산에 유용한 형태로 자연스럽게 발견된 것이 아니다.</mark> 따라서 비트를 만들기 위해 무엇이 필요한지 알아보자.
{% endhint %}

1장이 추상적인 내용이었다면, 2장부터는 본론으로 들어간다.

**하드웨어**

비트에 동작하는 장치를 포함한 모든 물리적인 장치로 `조합 논리`를 구현하는 하드웨어를 살펴보자

> 조합논리는 1장에서 설명한 불리언 대수를 부르는 또 다른 이름이다.

## 1. 디지털 컴퓨터의 사례 : **톱니바퀴와 계산 장치의 역사**

> &#x20;**사람들이 숫자를 더 쉽게 계산하기 위해 어떤 도구를 개발했는지** 살펴볼자.

#### **1) 톱니바퀴를 활용한 계산 장치**

톱니바퀴는 기계식 계산기의 핵심 요소였어. <mark style="color:red;">톱니의 크기와 개수에 따라 회전 속도를 조절할 수 있기 때문에 곱셈, 나눗셈 같은 연산을 수행하는 데 유용했지.</mark>

#### **(1) 안티키테라 기계 (기원전 100년경)**

<figure><img src="../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

* **무엇인가?**\
  기원전 100년경 그리스에서 만들어진 **세계에서 가장 오래된 기계식 계산기**야.
* **무엇을 할 수 있었나?**\
  사용자가 **다이얼을 돌려 날짜를 입력**하면, 크랭크를 돌려 **해당 날짜의 태양과 달의 위치를 계산**할 수 있었어.
* **왜 중요한가?**\
  현대의 기계식 계산기의 **초기 형태**로 볼 수 있어. 특히 천문학 계산을 기계적으로 수행할 수 있다는 점에서 매우 혁신적이었어.

📌 **읽어보기 좋은 자료**

* [안티키테라 기계 설명 - Wikipedia](https://ko.wikipedia.org/wiki/%EC%95%88%ED%8B%B0%ED%82%A4%ED%85%8C%EB%9D%BC_%EA%B8%B0%EA%B3%84) : 안티키테라 기계의 구조, 사용 목적, 발굴 과정을 설명하는 자료야. 이 기계가 천문학 계산을 어떻게 수행했는지, 발견 이후 어떤 연구가 이루어졌는지 다뤄. 기계식 계산기의 초기 형태를 이해하는 데 도움 된다.

#### **(2) 화기 제어 컴퓨터 (2차 세계대전 즈음)**

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **무엇인가?**\
  **2차 세계대전 때 사용된 군사용 계산 장치**로, 복잡한 톱니바퀴 구조를 가지고 있었어.
* **무엇을 할 수 있었나?**\
  **삼각함수와 미적분을 계산**해서 **포탄 발사 각도나 속도** 같은 것을 자동으로 조정하는 역할을 했어.
* **왜 중요한가?**\
  기계식 컴퓨터가 군사적인 목적으로도 활용될 수 있다는 점을 보여준 예시야.

#### **2) 톱니바퀴 없이 계산하는 방법: 계산자(Slide Rule)**

톱니바퀴 없이도 계산을 쉽게 할 수 있는 도구가 있었어. **대표적인 게 계산자(Slide Rule)야.**

#### **(1) 계산자란 무엇인가?**

<figure><img src="../../.gitbook/assets/sGa1uPzCJ9P3nuaDaG60GKYxoiyVP69PbFHre1O73XO1v9ZNuCLGJirPvuPCHT346jG9ESAxpvyFVTW1gNiusw.gif" alt=""><figcaption></figcaption></figure>

* 17세기 윌리엄 오트레드(William Oughtred)가 개발한 **기계식 계산 도구**야.
* 숫자를 곱할 때 **로그(logarithm, 로그) 개념**을 이용해서 **곱셈을 덧셈으로 바꿔서** 계산할 수 있었어.

#### **(2) 계산자의 원리**

* 로그(logarithm)를 이용하면 **곱셈을 덧셈으로 변환할 수 있어.**
  * 예를 들어,\
    **log(1.5 × 3) = log(1.5) + log(3)**\
    → 계산자가 이걸 자동으로 계산해줌!
* **즉, 숫자를 직접 곱하는 것이 아니라 로그 값을 더해서 빠르게 곱셈을 할 수 있도록 해주는 도구**
* 최초로 대량 생산된 계산 장치로 여겨지며, 사람들이 **자신이 사용할 수 있는 기술을 최대한 활용해 문제를 어떻게 해결하는지 보여주는 예시**

> 👉 **한 마디로, "숫자 곱하기"를 "더하기"로 바꿔서 계산을 쉽게 만들어 준 장치야!**

📌 **응용 예시**

* 예를 들어, 빛의 속도(3×10⁸ m/s) × 15000초 동안 간 거리를 계산할 때,
  * 로그를 사용하면 **log(1.5) + log(3) + 4 + 8 = log(4.5) + 12**
  * 계산자가 이를 빠르게 처리해줘!

#### **3) 숫자를 세는 다양한 방식들**

기계식 계산기가 나오기 전에도 사람들은 숫자를 기록하고 계산하는 다양한 방법을 사용했어.

* **탤리 막대 (Tally Stick)**:\
  기원전 18,000년부터 사용된 **숫자를 기록하는 원시적인 방법**으로, 나무나 뼈에 선을 긋는 방식이야.
* **호루스의 눈 (Eye of Horus Theory)**:\
  이집트에서 2진 분수를 표현하는 데 사용되었다는 이론이 있어.

📌 **읽어보기 좋은 자료**

* [탤리 막대의 역사 (Math History)](https://www.historyofinformation.com/detail.php?id=4556) **:** 숫자를 기록하는 **초기 방법과 그 발전 과정**을 알 수 있어.

#### **4) 차분 기관 (Difference Engine) - 기계식 컴퓨터의 시작**

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **무엇인가?**\
  찰스 배비지 (Charles Babbage, 1791\~1871)가 설계한 **초기 기계식 컴퓨터**야.&#x20;
* **무엇을 할 수 있었나?**\
  **10진수 계산을 자동으로 수행**하려고 했지만, **당시 기술로는 너무 정밀한 부품을 만들 수 없어서 완성되지 못했어.**
* **왜 중요한가?**\
  이후 **현대 컴퓨터 개념의 기초**를 마련하는 중요한 역할을 했어.
* 영국 정보를 설득해 복잡한 10진 기계식 계산기 개발 비용을 지원하게 했다.

📌 **읽어보기 좋은 자료**

* [찰스 배비지와 차분 기관 (Computer History Museum)](https://www.computerhistory.org/babbage/) : 차분 기관의 **구조, 원리, 컴퓨터 역사에서의 역할**을 설명하고 있다.

#### **정리: 기계적 계산기의 발전 과정**

1. **톱니바퀴 계산기** → 안티키테라 기계, 화기 제어 컴퓨터
2. **톱니바퀴 없는 계산기** → 계산자(Slide Rule)
3. **숫자 기록법** → 탤리 막대, 호루스의 눈
4. **배비지의 차분 기관** → 최초의 기계식 컴퓨터 개념&#x20;

📌 **추가로 알아두면 좋은 개념**

* **로그(Logarithm)**: 곱셈을 덧셈으로 변환하는 수학 개념.
* **과학적 표기법 (Scientific Notation)**: 큰 수를 다루기 쉽게 표기하는 방식.
* **기계식 계산기에서 전자식 컴퓨터로의 변화**: 이후 컴퓨터로 발전하는 과정.

***

### 1️⃣ 아날로그와 디지털의 차이

계산자와 비교할 때 탤리 막내나 뎃셈 기계는 중요한 차이가 있다.

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

컴퓨터의 연산 방식에는 **아날로그(analog)**&#xC640; **디지털(digital)** 방식이 있어. 이 두 가지 개념을 이해하려면 **연속적인 것과 이산적인 것**의 차이를 아는 게 중요하다.&#x20;

#### **1) 연속적인 수와 이산적인 수**

**(1) 계산자 vs. 손가락**

* **계산자**: 1.1, 1.2 같은 **소수(실수)를 표현할 수 있는 연속적인 도구**.
* **손가락**: 1, 2, 3 같은 **정수만 표현할 수 있는 이산적인 도구**.

👉 **연속적인 값**을 표현할 수 있는 계산자와 달리, 손가락으로는 1.1 같은 값을 표현하기 어렵다는 점에서 차이가 생겨.

#### **(2) 연속적(Continuous) vs. 이산적(Discrete)**

* **연속적 (Continuous)**: 숫자들 사이에 무한한 값이 존재함 → **아날로그**
* **이산적 (Discrete)**: 특정한 값만 존재하고 그 사이에 값이 없음 → **디지털**

> **예시**
>
> * **아날로그(연속적)**: 온도계(섭씨 25.3도, 25.31도 등 무한한 값)
> * **디지털(이산적)**: 손가락 개수(1개, 2개, 3개… 중간 값 없음)

#### **2) 디지털(Digital)이라는 단어의 의미**

{% hint style="warning" %}
디지털(digital)이라는 단어는 라틴어 **"digitus"**(손가락)에서 유래했어.\
→ 손가락처럼 **이산적인 값을 가지는 것**이 바로 디지털 방식이야.
{% endhint %}

👉 그래서 **디지털 컴퓨터는 숫자를 개별적인 단위(0과 1)로 다루고, 아날로그 컴퓨터는 연속적인 값을 처리할 수 있어.**

📌 **흥미로운 사실**:\
**아날로그 컴퓨터**도 실제로 존재했어! 계산자(Slide Rule)처럼 **연속적인 값을 활용하는 기계**가 대표적인 예야.

#### **3) 아날로그 방식의 한계: 정밀도의 문제**

**아날로그 방식은 실수를 표현할 수 있지만, 정밀도가 한계가 있어.**

* **예시**: 계산자에서 1.1을 선택하는 건 쉽지만, 9.1을 정확히 선택하는 건 어려워.
* 이유는 **눈금 간격이 숫자에 따라 다르기 때문**이야.

👉 만약 **아날로그 방식의 컴퓨터를 더 정밀하게 만들려면 눈금을 더 촘촘하게 배치해야 하는데, 그러면 기기가 커지고 다루기 어려워지는 문제**가 생겨.

> **극단적인 예**\
> 축구장 크기의 자를 만들면 정밀하게 측정할 수 있겠지만,\
> 이동식 컴퓨터로 사용하기엔 너무 커서 현실적으로 불가능해.

{% hint style="success" %}
**아날로그 신호**는 무한한 정밀도(원자 단위)를 가질 수 있지만 잡음에 민감하고 변환 과정에서 왜곡이 발생할 수 있다.\
반면, **디지털 신호**는 이산적인 값이기 때문에 정밀도가 제한되지만 잡음에 대한 내성이 높고 저장과 전달에 용이하다.
{% endhint %}

***

### 2️⃣ 하드웨어에서 크기가 중요한 이유

#### **1) 컴퓨터 속도와 크기의 관계**

컴퓨터의 성능은 **전자가 얼마나 빠르게 이동할 수 있는가**에 의해 결정돼.&#x20;

> 전자는 빛의 속도(초당 3억 미터)로 이동하지만, 현실적으로는 **부품 간 거리**가 전자의 이동 속도를 제한해.&#x20;

이를 줄이기 위해 **컴퓨터 부품을 가능한 한 가깝게 배치하는 것**이 중요해.

#### **2) 컴퓨터 속도와 거리의 관계**

* 현대 컴퓨터의 `클록 속도(clock speed)`는 **4GHz(40억 Hz)** 정도야.
* 1초에 40억 개의 연산을 수행할 수 있다는 뜻이고, 40억 분의 1초 동안 전자는 **약 75mm**밖에 이동하지 못해.
* 최신 CPU의 크기는 약 **18mm** 정도라서, **전자가 40억 분의 1초 동안 CPU 안을&#x20;**<mark style="color:red;">**겨우 두 번 왕복**</mark>**할 수 있는 거리**야.

👉 **즉, 전자가 이동하는 거리가 줄어들수록 연산 속도가 더 빨라지고, 성능이 높아져!**

#### **3) 작은 하드웨어의 장점**

* **에너지 절약**: 이동 거리가 줄어들면 **소모되는 에너지도 감소**해.
* **발열 감소**: 발열이 줄어들면, **배터리 사용 시간이 늘어나고, 과열 문제도 해결**돼.
* **휴대성이 증가**: 작고 효율적인 부품 덕분에 **스마트폰이나 노트북처럼 작고 강력한 기기**가 가능해졌어.

👉 **그래서 하드웨어는 점점 더 작아지는 방향으로 발전해 왔어.**

#### **4) 너무 작아지면서 생긴 문제들**

* **발열 문제**: 작은 크기에서도 강력한 성능을 내다 보니 **열이 집중적으로 발생**하게 돼.
* **양자 효과**: 부품이 너무 작아지면 **양자역학적인 현상**이 나타나서 기존 반도체 기술로 해결하기 어려운 문제가 생겨.
* **전력 누수**: 트랜지스터가 너무 작아지면 전류가 새어나가는 문제(누설 전류)가 발생할 수 있어.

{% hint style="success" %}
**결론**: 컴퓨터 성능을 높이려면 하드웨어 크기를 줄이는 것이 필수적이지만, 너무 작아지면 새로운 물리적 한계에 부딪힌다!
{% endhint %}



***

### 3️⃣ CPU에 대해 간단하게 알아보자

CPU(Central Processing Unit, 중앙처리장치)는 컴퓨터에서 데이터를 처리하는 핵심 장치로, **기억, 해석, 연산, 제어**라는 네 가지 주요 기능을 수행해.

<figure><img src="../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### **1) CPU의 구성 요소**

1. **코어(Core)**

<figure><img src="../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

* CPU 내부에서 **연산을 수행하는 핵심 단위**야.
* `싱글코어(single-core)`는 한 번에 하나의 작업만 가능하지만, **멀티코어(multi-core)**&#xB294; 여러 작업을 동시에 처리할 수 있어.
* 코어 수가 많을수록 **병렬 연산 성능**이 향상돼.

2. **쓰레드(Thread)**

* 코어는 물리적인 개념이지만, **쓰레드는 논리적인 개념**이야.
* **하이퍼쓰레딩(Hyper-Threading)** 기술을 사용하면 하나의 코어를 논리적으로 나누어 **한 코어에서 두 개의 작업을 동시에 수행할 수 있어.**
* 예를 들어, **쿼드코어(4코어) CPU에서 하이퍼쓰레딩이 적용되면 8개의 쓰레드가 실행 가능해.**

3. **클럭 속도(Clock Speed)**

* CPU가 **1초에 처리할 수 있는 연산 수**를 나타내며, 단위는 \*\*GHz(기가헤르츠)\*\*를 사용해.
* 클럭 속도가 높을수록 **연산 속도가 빠르지만, 발열과 전력 소모가 증가**해.
* **오버클럭(Overclock)**: 기본 클럭보다 높은 속도로 동작하도록 설정하는 것.

4. **캐시 메모리(Cache Memory)**

* CPU와 RAM 사이의 속도 차이를 줄이기 위해 **자주 사용하는 데이터를 빠르게 저장하는 고속 메모리**야.
* **L1 캐시**: 코어 내부에 위치하며 가장 빠르지만 용량이 작아.
* **L2 캐시**: L1보다 속도는 느리지만, 더 많은 데이터를 저장 가능해.
* **L3 캐시**: 여러 코어가 공유하는 캐시로, L1·L2보다 크지만 속도는 다소 낮아.

#### **2) CPU의 종류와 차이점**

1. **CPU vs. 프로세서(Processor)**
   * 프로세서(Processor)는 **명령어를 처리하는 모든 장치**를 의미하는 포괄적인 용어야.
   * CPU는 일반적으로 프로세서의 대표적인 형태지만, 보조 프로세서(Coprocessor)나 GPU(Graphics Processing Unit)도 프로세서의 일종이야.
2. **CPU vs. MPU vs. MCU**
   * **MPU(Microprocessor Unit)**: 일반적인 컴퓨터와 워크스테이션에서 사용하는 CPU.
   * **MCU(Microcontroller Unit)**: 작은 용량의 메모리와 입출력 장치를 단일 칩에 내장한 프로세서로, **아두이노(Arduino) 같은 임베디드 시스템에 사용**돼.

#### **3) CPU의 발전 과정과 한계**

1. **Power Wall 문제**
   * CPU의 성능을 높이기 위해 클럭 속도를 증가시키면 **발열 문제와 전력 소모 증가**가 발생해.
   * 이 문제를 해결하기 위해 **멀티코어 구조**가 등장했어.
2. **Memory Wall 문제**
   * CPU의 연산 속도(GHz)와 RAM의 속도(MHz) 차이로 인해 `병목 현상(Bottleneck)`이 발생해.
   * 이를 해결하기 위해 **캐시 메모리(Cache Memory) 구조**가 발전했어.

#### 4) CPU 다이(Die) 구조

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **Core (코어)**: CPU에서 연산을 수행하는 핵심 유닛. 멀티코어 CPU에서는 여러 개의 코어가 존재.
* **Shared L3 Cache (공유 L3 캐시)**: 모든 코어가 공유하는 고속 메모리로, CPU와 RAM 간 속도 차이를 줄여줌.
* **Memory Controller (메모리 컨트롤러)**: CPU와 RAM 간 데이터를 주고받는 역할을 수행.
* **Queue (대기열, 큐)**: 연산이 필요한 명령어를 정리하고 각 코어에 배분하는 역할.
* **PCIe (Peripheral Component Interconnect Express)**: GPU, SSD 등 외부 장치와 데이터를 주고받는 인터페이스.
* **Misc IO (기타 입출력 장치)**: USB, 네트워크 등 다양한 입출력 장치와 연결되는 부분.

#### 5) CPU 다이와 CPU의 차이

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>



**📌 읽어보기 좋은 자료**

* [cpu에 대해 더 자세히 알아보기](https://computer.howstuffworks.com/computer-cpu-channel.htm)

***

### 4️⃣ 디지털을 사용하면 더 안정적인 장치를 만들 수 있다

#### **하드웨어의 소형화와 물리적 한계**

컴퓨터 하드웨어는 성능을 높이기 위해 계속해서 더 작아지고 있어. 하지만 너무 작아지면 **물리적인 간섭과 양자역학적인 문제**가 발생할 수 있어.

#### **1) 너무 작은 크기의 문제점**

1. **외부 간섭 문제**
   * 아주 작은 장치는 **외부 환경의 영향을 쉽게 받음**.
   * 예를 들어,  계랑컵이나 계산자는 아날로그 장치로 **우주선 방사선(cosmic ray)** 같은 작은 충격도 미세한 부품에 영향을 줄 수 있어.
   * 반면, **손가락을 이용한 셈이나 기계식 계산기 같은&#x20;**<mark style="color:red;">**이산적인 장치**</mark>**는 외부 간섭의 영향을 덜 받음**.
     * **이산적인 장치에는 판정 기준**이 있기 때문
     * 판정적 기준을 아날로그 장치에 도입하면 값 중에 어떤 범위의 값을 표현할 수 있는 가능성이 사라진다.
2. **내부 간섭 문제**
   * `전자기력(Electromagnetic Force)`은 멀리  떨어진 물체에도 영향을 미쳐.
   * **CPU 내부 선 간 거리가 몇 나노미터(10⁻⁹m) 수준**으로 작아지면서, **누화(Crosstalk, 신호 간섭)** 문제가 심각해졌어.
   * **머리카락(약 10만 나노미터)보다 훨씬 작은 간격**이기 때문에, 회로 간 신호가 서로 영향을 주는 거야.

#### **2) 신호 간섭과 디지털 회로의 필요성**

1. **전자기력과 신호 간섭(Crosstalk)**

* **전자기력은 멀리 있는 물체에도 영향을 줌**
  * 예를 들어, **라디오 신호**도 전자기파로 전송되기 때문에 멀리 있는 기기에서도 신호를 받을 수 있어.
  * 하지만 이 특성 때문에 **CPU 내부에서도 신호 간섭이 발생**할 수 있어.
* **칩 내부 전선이 매우 가까워서 간섭이 심해짐**
  * 현대 반도체 칩의 **회로 간 거리는 수 나노미터(10⁻⁹m)** 수준이야.
  * 비교하자면, **사람 머리카락 지름(10만 나노미터)보다 훨씬 작은 간격**이야.
  * 이런 작은 간격에서는 하나의 신호가 옆 전선의 신호에 영향을 주는 '`누화 효과(Crosstalk)'`가 심해져.

#### **3) 신호 간섭을 해결하는 방법**

1. **신호 간 거리를 늘리는 방법**
   * 칩 설계에서 **전선 간 거리를 멀리 배치하면 간섭을 줄일 수 있어.**
   * 하지만 이렇게 하면 **칩 크기가 커지고 성능이 저하됨**.
2. **차폐 기술(Shielding) 사용**
   * 전자파를 차단하는 **실드(Shielding) 기술**을 사용하면 간섭을 줄일 수 있어.
   * 하지만 실드를 추가하면 **전력 소모와 칩의 복잡성이 증가**하는 단점이 있어.
3. **디지털 회로의 활용**
   * **디지털 신호(0과 1)를 사용하면, 신호가 어느 정도 간섭을 받아도 판정 기준(Threshold)을 통해 원래 값을 복원할 수 있어.**
   * **디지털 신호는 잡음 내성(Noise Immunity)이 강하기 때문에, 신호 왜곡이 덜한 방식으로 설계할 수 있어.**

**4) 디지털 신호가 중요한 이유**

<figure><img src="../../.gitbook/assets/image (152).png" alt=""><figcaption></figcaption></figure>



* 아날로그 신호는 연속적인 값(예: 1.1, 1.2, 1.3...)을 가지기 때문에 작은 간섭에도 큰 영향을 받아.
* 하지만 디지털 신호는 **0 또는 1만 사용하므로, 일정 수준의 간섭이 있어도 원래 신호를 유지할 수 있어.**

> 👉 **결국, 신호 간섭을 줄이고 안정적인 연산을 하기 위해 컴퓨터는 디지털 회로를 사용해!**

**📌 읽어보기 좋은 자료**

[ :전자 회로에서 발생하는 신호 간섭(누화) 문제와 이를 해결하는 방법을 설명하는 자료](https://donggreen.tistory.com/entry/%EC%A0%84%EC%9E%90-Signal-Integrity-SI-%EC%8B%A0%ED%98%B8-%EB%AC%B4%EA%B2%B0%EC%84%B1-%EB%85%B8%EC%9D%B4%EC%A6%88-%EA%B0%84%EC%84%AD-Noise-Interference%ED%83%80%EC%9D%B4%EB%B0%8D-%EC%98%A4%EB%A5%98-Timing-Errors?utm_source=chatgpt.com)

***

### 5️⃣ 아날로그 세계에서 디지털 만들기(**전이 함수와 디지털 신호**)

> 아날로그 세계를 어떻게 조작해서 안정적인 계> 산 장치를 만드는 데 필요한 디지털적 동작을 얻어낼 수 있는지 살펴보자.

<figure><img src="../../.gitbook/assets/image (153).png" alt=""><figcaption></figcaption></figure>

> 전이 함수는 **입력과 출력 사이의 관계를 수학적으로 나타내는 함수**야. 전자 회로, 카메라 센서, 오디오 증폭기 등 **다양한 시스템에서 입력이 어떻게 변환되는지** 설명하는 데 사용돼.

#### **1) 전이 함수란?**

> 수학 시간에 배운 함수와 같지만 실제 세계에서 벌어지는 현상을 표현한다는 점만 다름

1. **입력과 출력의 관계를 표현하는 함수**
   * 카메라 센서에서는 <mark style="color:red;">빛(입력)과 기록된 밝기(출력)</mark>의 관계를 나타냄.
   * 오디오 증폭기에서는 <mark style="color:blue;">소리 크기(입력)와 스피커 출력(출력)</mark>의 관계를 설명함.
2. **비선형성(Non-linearity)과 왜곡(Distortion)**
   * 현실에서는 입력과 출력이 **완벽한 선형 관계를 가지지 않음.**
   * 입력이 너무 크면 **출력이 한계에 도달하여 왜곡이 발생(Clipping).**

#### **2) 카메라 센서와 전이 함수**

1. **그래프 분석**
   * **X축**: 들어오는 빛(입력)
   * **Y축**: 기록된 밝기나 센서가 기록하는 빛(출력)
   * 빛이 너무 많으면, 즉  상단부에 많이 닿으면 **최댓값으로 모여 과노출(Overexposure)** 발생.
   * 빛이 너무 적으면,  즉  빛이 하단부에 많이 닿으면 **기록되지 않아 어두운 이미지**가 됨.
2. **해결 방법**
   * 카메라의 **셔터 속도, 조리개(F값), ISO 감도**를 조절하여 적절한 노출을 유지함.
   * 노출을 조절해서 빛이 직선부에 많이 닿게 해야함

#### **3) 오디오 증폭기와 전이 함수**

<figure><img src="../../.gitbook/assets/image (154).png" alt=""><figcaption><p>볼륨을 바꿀 때 중복 전이 함수가 어떻게 바뀌는 지 보여줌</p></figcaption></figure>

1. **게인(Gain)과 왜곡(Distortion)**
   * 게인은 **입력 신호를 얼마나 증폭할지 결정하는 값.**
   * **게인이 너무 높으면 (오른쪽 사진) 소리가 찌그러지고(Clipping), 원래 소리와 다르게 변형됨.**
2. **음향 시스템에서 전이 함수 활용**
   * 오디오 시스템에서는 **적절한 게인 조절이 필요**하며, 과출력은 소리를 왜곡시킴.
3. 게인   이 11로 고정된 **특별한 증폭기를 사용한다면?**
   * 출력이 더 이상 입력을 충실     하게 재현하지 못하기 때문에 왜곡distortion이 발생하며, 소리가 이상해진다.

#### **4) 디지털 신호의 안정성과 문턱값(Threshold)**

1. 판정 기준을 문턱값이라고 한다.
2. **디지털 신호는 문턱값(Threshold)을 활용해 안정적**
   * 디지털 신호는 **0 또는 1**만 사용하므로 **일정 수준의 잡음이 있어도 신호를 판별할 수 있음.**
   * 반면, 아날로그 신호는 **연속적인 값**을 가지므로 작은 간섭에도 쉽게 영향을 받음.
3. **디지털 신호의 장점**
   * 신호 간섭에도 강하고, 정보를 안정적으로 전달할 수 있음.
   * 잡음 내성(Noise Immunity)이 강하여 **전송 오류가 적음.**

**5) 전이 함수의 예시**

1. **전자 회로에서의 전이 함수:** 전자 회로에서 전이 함수는 입력 전압에 대한 출력 전압의 비율을 나타내며, 필터의 주파수 응답을 분석하는 데 사용된다.
2. **제어 시스템에서의 전이 함수:** 제어 시스템에서 전이 함수는 시스템의 안정성과 동적 특성을 분석하는 데 활용되며, 시스템의 입력과 출력 간의 관계를 주파수 영역에서 표현해

{% hint style="danger" %}
전자 신호가 일정 범위를 초과하면 왜곡(Distortion)이 발생할 수 있어. 특히, 증폭기에서 입력 신호가 너무 커지면 출력이 더 이상 원래 신호를 충실하게 재현하지 못하고 **클리핑(Clipping) 현상**이 일어나.
{% endhint %}

**6) 클리핑(Clipping)과 왜곡**

1. **클리핑(Clipping)이란?**
   * 증폭기에서 신호가 **출력 가능한 범위를 넘어가면 상한값이나 하한값에서 잘려버리는 현상**.
   * 원래 입력 신호가 **부드러운 곡선 형태라면, 클리핑이 발생하면 신호가 직선으로 잘려버려 왜곡됨.**
2. **왜곡(Distortion)의 결과**
   * **소리가 찌그러지고(Audio Distortion), 이미지가 과도하게 밝아지거나 색이 깨지는 현상(Image Clipping)이 발생할 수 있음.**
   * 증폭기가 신호를 제대로 증폭하지 못하고 잘라버리기 때문에, 원래 신호와 다르게 변형됨.

> 👉 **즉, 클리핑은 증폭기가 감당할 수 없는 신호를 입력받았을 때 출력 신호가 잘려서 왜곡되는 현상!**

**7) 문턱값(Threshold)과 디지털 신호**

<figure><img src="../../.gitbook/assets/image (155).png" alt=""><figcaption></figcaption></figure>

1. **문턱값(Threshold)이란?**
   * 신호가 특정 값(문턱값)을 넘으면 다른 상태로 바뀌는 기준점.
   * 예를 들어, **디지털 신호는 특정 문턱값을 넘으면 '1', 넘지 않으면 '0'으로 판별**해.
2. **왜 문턱값이 중요한가?**
   * 아날로그 신호는 **연속적인 값**을 가지기 때문에 작은 잡음에도 영향을 받음.
   * 하지만 **디지털 신호는 0과 1로 구분되기 때문에 일정 수준의 간섭이 있어도 신호를 판별할 수 있어(잡음 내성, Noise Immunity).**

{% hint style="danger" %}
&#x20;즉, **문턱값을 설정**하면 **신호가 명확하게 0과 1로 구분되어 안정적인 처리가 가능해!**
{% endhint %}



**8) 아날로그 vs. 디지털 신호의 차이**

| 구분        | 아날로그 신호          | 디지털 신호           |
| --------- | ---------------- | ---------------- |
| **신호 형태** | 연속적인 값           | 0과 1의 이산적인 값     |
| **잡음 내성** | 낮음(외부 간섭 영향 큼)   | 높음(문턱값으로 신호 안정화) |
| **왜곡 발생** | 과한 입력으로 인해 왜곡 가능 | 명확한 문턱값 덕분에 안정적  |
| **예시**    | 아날로그 오디오, 필름 카메라 | MP3 파일, 디지털 카메라  |

👉 **아날로그 신호는 선형적으로 처리하려 하지만 왜곡될 위험이 크고, 디지털 신호는 문턱값을 활용해 잡음에 강하고 안정적인 처리가 가능해.**

#### **📌 정리하면?**

1. **전이 함수는 입력과 출력의 관계를 나타내는 함수**로, 카메라 센서나 오디오 증폭기에서 중요한 역할을 함.
2. **카메라에서 빛이 너무 강하거나 약하면 이미지가 왜곡(Clipping)될 수 있음.**
3. **오디오 증폭기에서 게인이 너무 높으면 소리가 찌그러지는 왜곡이 발생.**
4. <mark style="color:blue;">클리핑(Clipping)</mark>은 신호가 한계를 초과하면 발생하는 왜곡으로, 증폭기에서 입력 신호가 너무 커지면 출력이 잘려버리는 현상.
5. <mark style="color:blue;">문턱값(Threshold)</mark>은 신호를 일정한 기준에 따라 구분하는 값으로, 디지털 신호에서는 문턱값을 통해 0과 1을 명확하게 판별할 수 있음.
6. **아날로그 신호는 연속적이라 잡음에 민감하지만, 디지털 신호는 문턱값을 설정하여 신호 안정성을 확보할 수 있음.**
7. 즉, 아날로그보다 디지털 기술이 더 나은 선택이다.

***

### 6️⃣ 10진 숫자 대신 비트를 사용하는 이유

#### **컴퓨터가 10진법이 아니라 2진법(비트)을 사용하는 이유**

컴퓨터는 우리가 일상적으로 사용하는 **10진법(Decimal)** 대신 2진법(Binary)을 사용해.

> 그 이유는 **하드웨어 설계의 효율성과 신뢰성** 때문이야.

#### **1) 사람은 10진법을 쓰는데, 왜 컴퓨터는 2진법을 사용할까?**

1. **사람은 손가락을 이용해 10까지 세는 게 자연스러움**
   * 우리가 10진법을 쓰는 이유는 **손가락이 10개라서 10까지 세는 것이 익숙하기 때문**이야.
   * 예를 들어, 손가락 하나를 숫자 1로 세면 **최대 10까지 표현할 수 있어.**
2. **비트를 사용하면 숫자를 더 효율적으로 표현할 수 있음**
   * **손가락 4개를 2진법으로 사용하면 16가지(0000\~1111) 숫자를 표현할 수 있어.**
   * **손가락 10개를 2진법으로 사용하면 1024가지 숫자(2¹⁰)를 표현할 수 있어.**
   * 👉 **즉, 같은 자원을 사용하면서도 훨씬 더 많은 정보를 저장할 수 있어!**

#### **2) 하드웨어 설계에서 10진법보다 2진법이 더 효율적인 이유**

{% hint style="danger" %}
컴퓨터는 전기로 동작하는데, 전기 신호는 **단순한 두 가지 상태(ON/OFF, HIGH/LOW)를 구분하는 것이 가장 안정적**이야.
{% endhint %}

이걸 `문턱값(Threshold Value)`을 이용해서 설명할 수 있어.

<figure><img src="../../.gitbook/assets/image (159).png" alt=""><figcaption><p>왼쪽 하드웨어를 구현하는 것은 오른쪽 하드웨어를 10개 만드는 것보다 훨씬 복잡하고 비용이 많이 든다.</p></figcaption></figure>

1. **10진법을 사용하면 문턱값이 10개 필요함**
   * 0\~9까지 10개의 값을 구분하려면 **10개의 문턱값이 필요함.**
   * 하지만 아날로그 신호는 **완벽하게 10개의 구분선을 만들기 어려움.**
   * 예를 들어, **온도나 전압이 미세하게 변하면 값이 제대로 구분되지 않을 수도 있음.**
2. **2진법을 사용하면 문턱값이 단 2개만 필요함**
   * 2진법에서는 단순히 **0과 1(LOW/HIGH)만 구분하면 됨.**
   * **하드웨어적으로 구현하기 쉽고, 전기적 노이즈에 강함.**
   * **회로를 더 간단하고 안정적으로 만들 수 있음.**

<mark style="color:red;">👉 즉, 2진법은 하드웨어 설계가 간단하고, 신뢰성이 높기 때문에 컴퓨터에서 가장 적합한 방식이야!</mark>

#### **3) 비트를 사용하면 전이 함수의 특성을 활용하기 쉬움**

컴퓨터는 전기 신호를 사용해 데이터를 처리하는데, 전이 함수(Transfer Function)가 중요한 역할을 해.

1. **전이 함수의 하단부(0)와 상단부(1)를 쉽게 활용할 수 있음**
   * 하드웨어에서 **전압이 일정 값 이하일 때는 0, 이상이면 1**로 판별하면 됨.
   * `급격한 전이(Threshold Crossover)`가 가능하기 때문에 신호 처리 속도가 빨라지고 정확해짐.
2. **전기 엔지니어링에서 2진법이 더 신뢰성이 높음**
   * 컴퓨터는 전기로 움직이니?
   * 전이 함수에서 **출력이 급격하게 바뀌기 때문에, 비트 단위로 데이터를 처리하는 것이 매우 안정적**이야.
   * **2진법을 사용하면 전력 소비를 줄일 수 있고, 회로 설계도 단순해짐.**

👉 **즉, 2진법을 사용하면 전이 함수의 특성을 활용하여 데이터를 빠르고 정확하게 처리할 수 있어!**

#### **4) 정리하자면?**

> **💡 왜 컴퓨터는 10진법이 아니라 2진법을 사용할까?**

* &#x20;비트를 사용하면 같은 공간에서 더 많은 정보를 저장할 수 있음.
* 10진법을 하드웨어적으로 구현하려면 **문턱값이 10개 필요**하지만, **2진법은 2개**만 필요해서 더 간단하고 안정적임.
* 2진법을 사용하면 전이 함수의 하단부(0)와 상단부(1)를 쉽게 활용할 수 있어 신호 처리가 정확해짐.
* 결과적으로, 2진법을 사용하면 회로가 단순해지고 전력 소모도 줄어들어 컴퓨터 하드웨어가 더 효율적으로 작동할 수 있음.

👉 **즉, 컴퓨터가 2진법을 사용하는 것은 "효율성"과 "신뢰성"을 위한 필연적인 선택이야!**

***

## 2. 간단한 전기 이론 가이드

> 현대 컴퓨터는 전기를 조작해 작동된다. 현재 사용 가능한 다른 기술로 컴퓨터를 만드는 것보다 전기를 사용해 컴퓨터를 만들면 더 빠르고 쉽게 컴퓨터를 만들 수 있다.

### 1️⃣ **전기와 물의 비유: 컴퓨터 회로를 쉽게 이해하기**

전기는 눈에 보이지 않기 때문에, **물의 흐름과 비교하면 이해하기 쉬워.**

> 전기가 흐르는 원리, 논리 게이트(AND, OR), 옴의 법칙 등이 **물의 흐름과 비슷한 방식으로 작동**하기 때문이야.

#### **1) 전기의 흐름을 물의 흐름과 비교하면?**

1. **배터리 = 물탱크**
   * 물이 물탱크에서 나오는 것처럼 **전기도 배터리(또는 전원)에서 나옴.**
   * 배터리가 방전되면 물탱크처럼 **에너지를 다시 충전해야 함.**
   * 물탱크에 물이 많을수록 더 많은 물을 공급할 수 있는 것처럼, **전압이 높을수록 더 많은 전기가 흐를 수 있음.**
2. **배관 = 전선(도체)**
   * 물이 배관을 통해 흐르는 것처럼, **전기는 전선을 통해 이동함.**
   * 전선 내부의 금속 부분을 `도체(Conductor)`라고 부르고, 전선을 감싸는 절연층을 `부도체(Insulator)`라고 부름.
     * 물 배관을 예로 들면, `도체`는 파이프 내부, `부도체`는 파이프 자체
   * 배관이 막히거나 좁아지면 물의 흐름이 방해받는 것처럼, **전선에도 저항(Resistance)이 존재하여 전류의 흐름을 방해할 수 있음.**
3. **수압 = 전압(Voltage)**
   * 물이 높은 곳에서 낮은 곳으로 흐르는 것처럼, **전기도 전압 차이가 있어야 흐름.**
   * 수압이 높을수록 물이 빠르게 흐르는 것처럼, **전압이 높을수록 전자가 더 빠르게 이동 가능.**
4. **밸브(Valve) = 스위치(Switch)**

<figure><img src="../../.gitbook/assets/image (161).png" alt=""><figcaption></figcaption></figure>

* 물의 흐름을 조절하는 밸브처럼, **전기는 스위치를 통해 흐름을 조절할 수 있음.**
* **밸브가 닫히면(0) 물이 흐르지 않고, 열리면(1) 물이 흐름.**
* 전자 회로에서도 **트랜지스터를 사용해 전류를 차단(0)하거나 흐르게(1) 만듦.**

#### **2) 논리 게이트와 물의 흐름 비교**

논리 연산은 **물 밸브를 사용하여 쉽게 설명할 수 있어.**

<figure><img src="../../.gitbook/assets/image (162).png" alt=""><figcaption></figcaption></figure>

1. **AND 게이트 (직렬 연결)**
   * 두 개의 밸브를 **연결해서 둘 다 열려야(1) 물이 흐름.**
   * **즉, A와 B가 모두 1일 때만 출력이 1이 됨.**
   * **논리식: A ⋅ B**
   * 예시: **샤워기에서 찬물과 뜨거운 물 두 개의 밸브를 모두 열어야 물이 나오는 것과 같음.**
2. **OR 게이트 (병렬 연결)**
   * 두 개의 밸브가 각각 연결되어 있고, **둘 중 하나라도 열려 있으면 물이 흐름.**
   * **즉, A 또는 B 중 하나라도 1이면 출력이 1이 됨.**
   * **논리식: A + B**
   * 예시: **집에서 두 개의 수도꼭지가 있을 때, 어느 한쪽만 열어도 물이 나오는 것과 같음.**

#### **3) 옴의 법칙과 물의 흐름 비교**

**옴의 법칙(Ohm’s Law) :**

$$
I = \frac{V}{R}
$$

* **전류(I, A)** = 전기의 흐름(물의 양)
* **전압(V, V)** = 전기를 미는 힘(수압)
* **저항(R, Ω)** = 전류의 흐름을 방해하는 요소(배관의 크기)

{% hint style="success" %}
**💡 쉽게 이해하자면?**

* 빨대를 이용해서 밀크셰이크를 마실 때, **빨대가 가늘수록(저항↑) 빨아들이기 어렵고(전류↓)**,\
  빨대가 넓을수록(저항↓) 쉽게 마실 수 있음(전류↑).
* 같은 빨대를 사용할 때, 더 세게 빨면(전압↑) 더 많은 밀크셰이크가 올라오는 것과 같음.
{% endhint %}

#### **4) 전기의 이동 속도와 전파 지연 (Propagation Delay)**

전기가 이동하는 것도 **물이 파이프를 따라 흐르는 것과 비슷**하지만, 속도가 완전히 같지는 않아.

1. **전자는 실제로 아주 느리게 움직임**
   * 우리가 "전기가 빠르게 흐른다"라고 말하지만, 사실 **전자 자체는 매우 느리게 이동함.**
   * 하지만 **전자의 움직임이 아니라 전자기장이 전달되는 속도(전기 신호)가 빠름.**
2. <mark style="color:red;">**전파 지연(Propagation Delay)**</mark>**이 발생함**
   * 물이 파이프를 따라 이동하는 데 시간이 걸리는 것처럼,\
     **전기 신호도 칩 내부에서 이동하는 데 약간의 지연 시간이 필요함.**
     * 물의 경우 온도 변화가 파이프를 확장시키거나 수축시키기 때문에 물의 흐름이 달라지며 그에       \
       따라 지연 시간도 차이가 난다.
   * **전선이 길어질수록 지연 시간이 길어지고, 고속 컴퓨팅에서 큰 영향을 미칠 수 있음.**

> 👉 **즉, 전기의 흐름을 물의 흐름처럼 이해하면 전압, 전류, 저항, 논리 회로까지 쉽게 이해할 수 있어!**.

#### **5) 전압(Voltage) = 수압(Pressure)**

🔹 **전압(Voltage)이란?**

* 전기 신호를 **밀어주는 힘**을 의미해.
* **측정 단위:** 볼트(Volt, V)
* **이탈리아 물리학자 알레산드로 볼타(Alessandro Volta)의 이름을 따서 명명됨.**

🔹 **물의 흐름과 비교하면?**

* 수압이 높을수록 물이 빠르게 흐르듯, **전압이 높을수록 전류가 더 강하게 흐를 수 있음.**
* 예를 들어 **산에서 내려오는 폭포(높은 전압)와 평지에서 흐르는 개울(낮은 전압)을 비교해 볼 수 있음.**

📌 **즉, 전압은 전류가 흐르게 만드는 "압력"과 같은 역할을 해!**

#### **6) 전류(Current) = 물의 흐름량(Flow Rate)**

🔹 **전류(Current)란?**

* **전기가 흐르는 양**을 의미해.
* **측정 단위:** 암페어(Ampere, A)
* **프랑스 물리학자 앙드레마리 앙페르(André-Marie Ampère)의 이름에서 유래됨.**

🔹 **물의 흐름과 비교하면?**

* 굵은 배관을 통해 흐르는 물의 양이 많으면 **물이 빠르게 이동하는 것처럼**,
* 전류도 **높을수록 더 많은 전기가 흐름.**
* **전압(수압)이 높을수록, 저항(배관의 크기)이 낮을수록 전류가 많이 흐를 수 있음.**

📌 **즉, 전류는 전기 신호가 이동하는 "양"을 의미해!**

#### **7) 저항(Resistance) = 배관의 크기(Flow Restriction)**

🔹 **저항(Resistance)이란?**

* 전기의 흐름을 방해하는 요소.
* **측정 단위:** 옴(Ohm, Ω)
* **독일 물리학자 게오르크 시몬 옴(Georg Simon Ohm)의 이름에서 유래됨.**

🔹 **물의 흐름과 비교하면?**

* **배관이 좁으면(저항↑) 물이 흐르기 어렵고, 배관이 넓으면(저항↓) 물이 쉽게 흐름.**
* **전선의 저항이 크면, 전류가 흐르는 데 방해를 받음.**
* **전선이 길어지거나 얇아지면 저항이 증가하고, 전력 손실이 발생할 수 있음.**

> 📌 **즉, 저항이 높을수록 전기가 흐르기 어려워지고, 낮을수록 쉽게 흐를 수 있어!**

#### **8) 저항과 열 발생**

전기가 흐를 때 저항이 있으면 일부 전력이 열로 변환됨.\
이 원리를 이용해서 **전기히터, 토스터, 전기담요** 등이 작동함.

🔹 **물의 흐름과 비교하면?**

* 배관이 좁을수록 물이 마찰로 인해 더 뜨거워지는 것처럼,
* 전선이 가늘거나 저항이 높을수록 전기 흐름이 방해받으며 열이 발생함.

> 📌 **즉, 전기 저항은 열을 발생시키며, 이를 활용하여 다양한 전열기구를 만들 수 있어**

***

#### **📌 정리: 물과 전기의 흐름 비교**

| **개념**                       | **물의 흐름**     | **전기의 흐름**      |
| ---------------------------- | ------------- | --------------- |
| **배터리(전원)**                  | 물탱크           | 배터리             |
| **전압(Voltage, V)**           | 수압            | 전압(볼트, V)       |
| **전류(Current, I)**           | 물의 흐름량        | 전기의 흐름량(암페어, A) |
| **저항(Resistance, R)**        | 좁은 배관         | 전선의 저항(옴, Ω)    |
| **스위치(Switch)**              | 밸브(물 흐름 조절)   | 전기 흐름 제어        |
| **논리 연산(AND/OR)**            | 물 밸브 직렬/병렬 연결 | 논리 게이트          |
| **전파 지연(Propagation Delay)** | 물이 이동하는 속도    | 전기 신호가 전달되는 시간  |

***

### 2️⃣ 전기 스위치

{% hint style="success" %}
컴퓨터와 전자 기기의 **전류 흐름을 조절하는 핵심 요소**가 바로 스위치(Switch)와 회로(Circuit)\
스위치는 **물 밸브처럼 전기의 흐름을 제어**하고, 회로는 **배관 시스템처럼 전기가 이동하는 경로**를 제공해.
{% endhint %}

#### **1) 스위치(Switch)란?**

🔹 **전기에서 스위치의 역할**

* 스위치는 **전기의 흐름을 차단하거나 연결하는 역할**을 해.
* 쉽게 말해, **전등 스위치를 켜고 끄는 것과 같은 원리야.**

🔹 **공기가 좋은 부도체인 이유**

* **두 개의 전선이 맞닿아야 전기가 흐를 수 있음.**
* **공기는 부도체**(전기가 흐르지 않는 물질)이기 때문에, **스위치를 끄면 공기가 전선을 분리하여 전류 흐름을 막음.**
* 하지만 **전압이 충분히 높으면 공기가 이온화되어 도체로 변함.**
* **번개가 치는 원리**도 이런 원리로 설명할 수 있어!

📌 **즉, 스위치는 도체(전선)를 연결하거나 분리하여 전기를 흐르게 하거나 차단하는 역할을 해!**

#### **2) 스위치의 종류 (SPST, SPDT, DPDT 등)**

스위치는 **연결 방식에 따라 다양한 종류**가 있어.\
이를 쉽게 이해하려면 **철도 선로를 바꾸는 장치**와 비슷하다고 보면 돼.

**🔹 단극단투(SPST, Single-Pole Single-Throw) 스위치**

<figure><img src="../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

* 하나의 입력(극, Pole)과 하나의 출력(Throw)만 연결됨.
  * 극이란 한꺼번에 연결되어 이동하는 스위치의 수
  * 수도관 밸브는 모두 단극
* 전등 스위치 같은 가장 기본적인 스위치 형태.
* 도개교처럼 <mark style="color:red;">열고 닫아 전류 흐름을 조절하는 역할</mark>을 함.
  * 단투 스위치로는 한쪽은 켜고 반대쪽은 끄는 역할을 할 수 없음
* 🛠 **예시:** 가정용 전등 스위치

**🔹 단극쌍투(SPDT, Single-Pole Double-Throw) 스위치**

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

> 두 선로 중 한쪽으로 기차를 연결해주는 선로 분기나 그림 2-16처럼 두 파이> 프 중 <mark style="color:red;">한쪽으로 흐름을 연결해주는 배관과 같다.</mark>

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption><p>손잡이를 아래로 내리면 물이 위쪽 밸브를 통해 흐른다. 손잡이를 위로 올리면 물<br>이 아래쪽 밸브를 통해 흐른다</p></figcaption></figure>

* **하나의 입력을 두 개의 출력 중 하나에 연결할 수 있는 스위치.**
* **기차 선로를 분기하는 장치처럼 동작함.**
* 🛠 **예시:** 하나의 전원을 두 개의 다른 회로 중 하나로 전환할 때 사용

**🔹 쌍극쌍투(DPDT, Double-Pole Double-Throw) 스위치**

> 단극쌍투를원하는 개수만큼 극이나 접점을 사용해 스위치 관련 용어를 확장할 수 있다.

<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

* **두 개의 입력을 각각 두 개의 출력에 연결할 수 있음.**
* **두 개의 전원을 독립적으로 스위칭 가능함.**
* 🛠 **예시:** 모터 방향 전환(정방향/역방향 변경)

<figure><img src="../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

> 📌 **즉, 스위치는 단순한 ON/OFF 기능뿐만 아니라, 다양한 회로 연결 방식을 지원하는 중요한 전기 부품이야!**

#### **3) 회로(Circuit)란?**

{% hint style="warning" %}
`수도 시스템`은 물이 흘러갈 장소가 없으면 제대로 작동하지 않는다. 배수관이 막히면 물이 흐를 수 없어. 그리고 배수관에 모은 물을 다시 물탱크로 보낼 방법이 필요하다. 그런 방법이 없으면 수도 시스템에서 물이 말라&#x20;버릴 것이다.\
전기 시스템도 비슷해
{% endhint %}



🔹 **회로의 정의**

{% hint style="info" %}
에너지 근원에서 나온 전기는 회로 구성요소를 지나서 다시 근원으로&#x20;돌아가. 그래서 이를 `회로circuit`라고 불러
{% endhint %}

* 전기가 흐를 수 있는 **연결된 경로**를 의미해.
* 전류는 **배터리(전원) → 스위치 → 부하(전구, 모터 등) → 배터리(전원)로 돌아오는 폐쇄된 경로를 따라 흐름.**
* 만약 **회로가 끊어지면(스위치 OFF) 전기가 흐를 수 없음.**

🔹 **기본적인 회로 구성 요소**

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

* **전원(Voltage Source)**: 배터리, 발전기 등
* **전선(Wires)**: 전기를 전달하는 도체
* **부하(Load)**: 전등, 모터 등 전력을 소비하는 장치
* **스위치(Switch)**: 전류 흐름을 제어하는 장치

🔹 **회로가 작동하는 방식**

* 스위치를 닫으면 **전류가 흐르고 전구가 켜짐.**
* 스위치를 열면 **전류가 차단되고 전구가 꺼짐.**

> 📌 **즉, 회로는 배관 시스템처럼 전기가 원활하게 흐를 수 있도록 구성되는 필수적인 요소야!**

#### **4) 직렬 회로와 병렬 회로의 차이**

**🔹 직렬 회로(Series Circuit)**

* **전기 부품이 한 줄로 연결됨.**
* **모든 부품을 지나야 전류가 흐를 수 있음.**
* **한 개가 고장 나면 전체 회로가 동작하지 않음.**
* 🛠 **예시:** 크리스마스 트리 전구(한 개가 나가면 모두 꺼짐)

**🔹 병렬 회로(Parallel Circuit)**

* **전기 부품이 여러 갈래로 연결됨.**
* **각 부품이 독립적으로 전력을 공급받음.**
* **한 개가 고장 나도 나머지는 계속 동작함.**
* 🛠 **예시:** 가정의 전기 배선(한 방의 전등이 나가도 다른 방의 전등은 켜짐)

📌 **즉, 직렬 회로는 한 줄로 연결된 반면, 병렬 회로는 독립적으로 연결되어 있어!**



> 전기에 대해 조금 배웠고 기본적인 회로 요소도 살펴본 내용

***

## 3. 비트를 처리하기 위한 하드웨어

> 하드웨어에 비트를 사용해야 하는 이유를 알았으므로, 비트를 다루는 하드웨어를 만드는 방법> 을 배울 준비 된거야!

### 1️⃣ **컴퓨터와 릴레이 회로: 초창기 컴퓨터에서 현대 컴퓨터까지**

컴퓨터는 전기적인 신호를 조작하여 데이터를 처리하고 논리를 실행하는 기계야.\
하지만 초창기 컴퓨터는 지금과 같은 반도체 기반이 아니라 `릴레이(relay)`를 이용해 **논리 연산을 수행했어.**\
이 릴레이는 현대 컴퓨터의 기초가 되는 `트랜지스터(transistor)`가 등장하기 전까지 중요한 역할을 했어.

이제 릴레이가 무엇인지, 왜 사용되었으며, 어떻게 트랜지스터로 대체되었는지 알아보자.

#### **1) 전기와 자기의 관계: 한스 외르스테드의 발견**

전기가 컴퓨터에 사용되기 시작한 것은 **전기와 자기의 관계가 밝혀진 이후**였어.

> 덴마크의 과학자 한스 크리스티안 외르스테드(Hans Christian Ørsted, 1777\~1851)는 **전류가 흐르면 자기장이 생성된다는 사실을 발견**했어.

이 원리를 활용하면 **코일(선)을 감고 전기를 흘려서 전자석을 만들 수 있어.**\
전자석은 전류가 흐를 때만 자성을 가지므로, **전기를 이용해 자기력을 조절하는 것이 가능**해.

📌 **이 원리는 컴퓨터 내부의 다양한 전자기적 장치(릴레이, 모터, 트랜스포머 등)에 사용돼.**

#### **2) 전자석과 전기 회로의 응용**

전류를 흐르게 하여 전자석을 만들면, 다양한 방식으로 응용할 수 있어.

1️⃣ **스위치 역할**

* 전자석을 이용하여 특정 부품을 움직이거나, 전류 흐름을 조절할 수 있어.
* `릴레이(Relay)`가 대표적인 예시야.

2️⃣ **전기 모터**

* 전자기력을 활용하여 모터를 회전시킬 수 있어.
* **컴퓨터의 냉각 팬, 하드디스크의 회전판 등에 사용됨.**

3️⃣ **발전기 원리**

* 전선을 감은 코일 주변에서 자석을 움직이면 전기가 발생해.
* **이 원리를 이용하여 발전기를 만들고 전기를 생산할 수 있음.**

> &#x20;**즉, 전자기 원리는 컴퓨터뿐만 아니라 모든 전자기기에서 필수적인 개념이야.**

#### **3) 역기전력(Back-EMF)과 전기 신호의 안정성**

{% hint style="warning" %}
컴퓨터에서 전기를 안정적으로 사용하려면, 전압과 전류의 변화를 조절해야 해.\
하지만 **코일을 포함한 회로에서는 전원이 갑자기 차단될 때 역기전력(Back-EMF)이 발생할 수 있어.**
{% endhint %}

📌 **역기전력이란?**

* 코일 내부의 자기장이 급격히 변화할 때 발생하는 전압
* 자동차 점화 코일, 전기 펜스 등에서 활용되기도 하지만,
* **컴퓨터 회로에서는 역기전력이 문제를 일으킬 수 있기 때문에 방지 회로가 필요함.**

컴퓨터 내부에서는 **전압이 갑자기 변하지 않도록 회로 설계를 신중하게 해야 해.**

#### **4) 릴레이란 무엇인가?**

릴레이(relay)는 **전자석을 이용해 스위치를 자동으로 조작하는 장치**야.\
쉽게 말해, **전기가 흐르면(ON) 스위치가 닫히고, 전기가 흐르지 않으면(OFF) 스위치가 열리는 원리**로 동작해.

> 릴레이는 전자기력을 이용하여 스위치를 열고 닫을 수 있기 때문에, **전기를 이용한 자동화 시스템에서 핵심적인 역할**을 했어.

예를 들어, **전화 교환기, 전기 펜스, 자동차 점화 코일, 공장 자동화 시스템 등에서 널리 사용되었지.**

#### **릴레이의 내부 구조**

릴레이는 크게 4가지 주요 부품으로 구성돼.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

1️⃣ **전자석 (Electromagnet)** → 전류가 흐르면 자석처럼 작용하여 금속 스위치를 당김\
2️⃣ **가동 접점 (Movable Contact)** → 자석에 의해 움직이는 스위치 부분\
3️⃣ **정지 접점 (Stationary Contact)** → 고정된 접점으로, 스위치가 닫히면 전기가 흐름\
4️⃣ **스프링 (Spring)** → 전류가 끊어지면 원래 위치로 돌아가도록 도와줌

> 즉, 릴레이는 전자석을 이용하여 물리적인 스위치를 제어하는 장치야.

#### **5) 릴레이와 컴퓨터의 관계**

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

**🔹 릴레이를 활용한 초기 컴퓨터**

초창기 컴퓨터(예: **Harvard Mark II**)는 **릴레이를 이용하여 논리 연산을 수행했어.**\
이때, 릴레이는 일종의 "전기적 스위치"로서 **컴퓨터 내부에서 0과 1을 표현하는 기본 단위**로 사용되었어.

**릴레이 컴퓨터의 특징:**\
✅ **0과 1을 표현 가능** → 스위치를 열면(0), 닫으면(1)\
✅ **논리 연산 가능** → AND, OR, NOT 등의 연산 수행 가능\
✅ **전기적 신호만으로 자동 동작 가능**

즉, 릴레이는 최초의 전기적 논리 연산 장치였고, 컴퓨터의 기초적인 역할을 했어.

***

#### **🔹 릴레이 기반 논리 회로**

> 아래  사진은 두 릴레이가 모두 활성화돼야 두 선이 연결된다는 사실을 알 수 있다.>

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption><p>두 선의 교차점에 점이 찍혀 있지 않으면 두 선은 서로 연결되지 않은 것이다.</p></figcaption></figure>

릴레이는 단순한 스위치가 아니라, **논리 연산을 수행하는 논리 회로**를 만들 수 있어. 스위치로는 불가능한 일을 할 수 있다.

**AND 게이트 (직렬 연결)**

* 두 개의 릴레이가 **모두 활성화(ON)** 되어야 출력이 1
* 예: 샤워기에서 찬물과 뜨거운 물 두 개의 밸브를 모두 열어야 물이 나오는 것과 같음

**OR 게이트 (병렬 연결)**

* 두 개의 릴레이 중 **하나라도 활성화(ON)** 되어 있으면 출력이 1
* 예: 집에서 수도꼭지 하나만 열어도 물이 나오는 것과 같음

**NOT 게이트 (반전)**

* 입력이 1이면 0을 출력, 입력이 0이면 1을 출력
* 예: 스위치를 누르면 불이 꺼지고, 다시 누르면 켜지는 것과 같음
* 랄레이를 사용하면 **NOT 함수를 구현하는 인버터**를 만들 수 있음
  * 이게 없으면 불리언 연산 제한

즉, 릴레이를 여러 개 조합하면 복잡한 논리 연산을 수행하는 컴퓨터 회로를 만들 수 있어!

#### &#x20;**6) 릴레이의 한계와 트랜지스터의 등장**

릴레이는 초창기 컴퓨터에서 중요한 역할을 했지만, 다음과 같은 단점이 있었어.

**릴레이의 단점**

1️⃣ **속도가 느림** → 기계적 움직임이 필요하여 연산 속도가 제한됨\
2️⃣ **전력 소모가 많음** → 전자석을 계속 작동시키려면 많은 전력이 필요함\
3️⃣ **물리적인 마모** → 릴레이 접점이 반복적으로 작동하면서 마모됨\
4️⃣ **버그 발생 가능** → 먼지나 벌레가 릴레이 접점을 막으면 오작동(실제로 '버그'라는 용어의 유래)

즉, 릴레이는 컴퓨터 연산을 수행하기에는 너무 느리고, 유지보수가 어려웠어.

{% hint style="success" %}
**버그의 일화**\
실제로 미국 컴퓨터과학자 그레이스 호퍼Grace Hopper가 1947년 하버드 마크 2Harvard Mark II에 발생한 오류를 추적하다가 릴레이에 낀 나방을 발견하면서 버그bug라는 단어가 유명해졌다
{% endhint %}

***

### 2️⃣ 진공관

컴퓨터가 발전하는 과정에서 **전기의 흐름을 제어하는 장치**가 필수적이었다.\
처음에는 `릴레이(Relay)`가 사용되었지만, 속도와 효율성이 문제였다.

> 이 문제를 해결하기 위해 등장한 것이 바로 **진공관(Vacuum Tube)이다.**

#### **1) 진공관의 발명: 존 앰브로즈 플레밍의 공헌**

영국 물리학자이자 전기 엔지니어인 **존 앰브로즈 플레밍(Sir John Ambrose Fleming, 1849\~1945)이 진공관을 발명**했다.\
그는 **열전자 방출(Thermionic Emission)이라는 현상을 기반으로 진공관**을 만들었다.

**열전자 방출이란?**

* 물체를 충분히 가열하면 전자가 튀어나오는 현상
* 이를 활용하여 진공 상태에서 전자의 흐름을 조절 가능

**진공관의 구성 요소**

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption><p>전자는 야구공과 같다.</p></figcaption></figure>

1. **캐소드(Cathode, 음극)**: 전자를 방출하는 부분\[야구 투수]
2. **히터(Heater)**: 캐소드를 가열하여 전자가 나오게 함
3. **애노드(Anode, 양극)**: 전자를 받아들이는 부분\[포수]

> 즉, 진공관은 전자의 흐름을 조절하여 스위치처럼 작동할 수 있는 장치다.

#### **2) 삼극관(Triode)의 등장: 신호 증폭과 스위칭**

플레밍의 진공관은 단순한 전류 흐름을 조절하는 기능만 가졌으나, **리 이드 포레스트(Lee De Forest)**&#xB294; 이를 발전시켜 `삼극관(Triode)`을 발명했다.

**삼극관이란?**

* 세 요소(캐소드, 그리드, 애노드)가 들어 있는 진공관을 `삼극관`이라고 한다.



**삼극관의 추가 요소: 그리드(Grid)**

{% hint style="info" %}
전자는 자석과 비슷한 성질을 몇 가지 띠는데, 그중에는 <mark style="color:red;">서로 다른 극이 서로를 끌어당기고 서로 같은 극이 서로를 밀어낸다</mark>는 성질을 가지고 만든 것이 그리드
{% endhint %}

* 타자와 같은 역할
* 캐소드에서 방출된 전자를 조절하는 역할(**캐소드**에서 나오는 전자를 쫓아내서 애노드에 도  \
  착하지 못하게 만듦)
* 전압을 가해 전자의 흐름을 차단하거나 허용
* 이제 단순한 ON/OFF 스위치뿐만 아니라 **증폭(Amplification)**&#xB3C4; 가능해짐

삼극관의 등장으로 컴퓨터는 더욱 빠르고 정밀한 계산을 수행할 수 있게 되었다.

#### **3) 진공관의 장점과 단점**

**진공관의 장점**

1. 릴레이보다 훨씬 빠름
2. 기계적인 움직임이 없어서 마모되지 않음
3. 신호 증폭이 가능하여 더욱 강력한 전자 회로 설계 가능

**진공관의 단점**

1. 열이 많이 발생하여 냉각이 필요함
2. 크기가 크고 깨지기 쉬움
3. 전력 소비가 큼

> 진공관도 한계를 가지고 있었고, 더 나은 기술이 필요했다.

***

### 3️⃣ **트랜지스터**와 현대 컴퓨터

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

컴퓨터의 발전 과정에서 트랜지스터는 핵심적인 역할을 하는 부품이야. 과거에는 **릴레이와 진공관**을 이용해 컴퓨터를 만들었지만, 크기가 크고 전력 소모가 많으며 발열이 심한 문제가 있었어. 트랜지스터의 등장은 <mark style="color:red;">컴퓨터 소형화와 성능 향상을 가능하게 만들었지.</mark>

***

#### 1) 트랜지스터란?

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

* 트랜지스터(Transistor)는 전송 저항(Transfer Resistor)이라는 단어에서 유래한 전자 부품이야.
* 전류의 흐름을 조절하는 **스위치 역할**을 하며, `반도체(Semiconductor)`라는 특별한 물질을 이용해 만들어져.
* 컴퓨터는 0과 1의 이진법으로 동작하는데, 트랜지스터는 **전류를 켜고 끄는(ON/OFF) 방식**으로 이진 연산을 수행할 수 있어.

#### 2) 트랜지스터의 주요 특징

1. **반도체를 이용한 동작**
   * 트랜지스터는 **도체(전기가 잘 흐르는 물질)**&#xC640; **부도체(전기가 안 흐르는 물질)** 사이의 특성을 가진 반도체로 만들어져 있어.
   * 전압을 가하면 전류가 흐르고, 전압이 없으면 전류가 차단되는 원리를 이용해 전자 회로에서 ON/OFF 스위치로 활용돼.
2. **소형화 가능**
   * 트랜지스터는 **매우 작게 제작할 수 있어서** 컴퓨터의 성능을 높이면서도 크기를 줄일 수 있어.
   * 현재의 CPU에는 **수십억 개의 트랜지스터**가 집적되어 있어.
3. **전력 소모와 발열 문제**
   * 트랜지스터는 전력을 소모하면서 열을 발생시키기 때문에, **발열을 줄이는 기술**이 중요해.
   * 특히, 트랜지스터가 많아질수록 열이 심해지므로 **냉각 기술과 저전력 설계**가 필수적이야.

#### 3) 트랜지스터의 구조와 유형

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

1.  **쌍극 접합 트랜지스터(BJT, Bipolar Junction Transistor)**

    <figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

    * **NPN형과 PNP형**이 있으며, 전류의 흐름을 제어하는 방식이 달라.
    * 컬렉터(Collector), 베이스(Base), 이미터(Emitter)라는 세 개의 단자로 구성돼.
    * 베이스(Base)에 전압을 가하면 컬렉터에서 이미터로 전류가 흐르게 돼.
    * **릴레이나 진공관을 대체하면서 초기 컴퓨터에 사용됨.**
2. **전계 효과 트랜지스터(FET, Field Effect Transistor)**

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

* **MOSFET(Metal-Oxide Semiconductor Field Effect Transistor)**&#xC774; 가장 대표적인 FET야.
* **게이트(Gate), 드레인(Drain), 소스(Source)**&#xB77C;는 세 개의 단자로 구성돼.
* 게이트(Gate)에 전압을 가하면 전류의 흐름을 조절할 수 있어.
* **전력 소모가 적고 빠르기 때문에 현대 컴퓨터에서 가장 널리 사용돼.**

#### 4) 트랜지스터 제조 방식

1. **반도체 기판(실리콘 웨이퍼) 사용**
   * 트랜지스터는 실리콘(Si)이라는 반도체 물질 위에 회로를 새겨서 만들어져.
     * <mark style="color:red;">반도체 물질로 이뤄진 기판 또는 슬랩 위에 만들어진다는 것이 중요</mark>
     * 기어, 밸브, 릴레이, 진공관 같은 기술과 달리 트랜지스터는 개별적으       로 생산되는 물체가 아니야
   * 실리콘 웨이퍼는 둥근 판 모양이며, 여기에 **광식각(Photolithography)** 기술을 이용해 트랜지스터 패턴을 새겨.
     * **광신각 :** 트랜지스터는 트랜지스터 그림을 실리콘 웨이퍼wafer(얇은 판) 위에       &#x20;투영해서 현상
   * 이 과정에서 미세한 회로를 새기고, 불순물을 첨가하는 **도핑(Doping)** 과정을 거쳐 반도체 특성을 조절해.
2. **CMOS(Complementary MOS) 기술**
   * 현대 컴퓨터의 대부분은 **CMOS(Complementary Metal-Oxide Semiconductor)** 기술을 사용해.
   * N채널(NMOS)과 P채널(PMOS) 트랜지스터를 짝지어 **전력 소비를 최소화**할 수 있어.
   * **저전력 소모와 고속 처리가 가능한 회로 기술**이라서 CPU, 메모리, 디지털 회로 등에 널리 활용돼.

#### 5) 트랜지스터와 현대 컴퓨터

1. **컴퓨터 프로세서(CPU)의 핵심 요소**
   * **CPU 내부에는 수십억 개의 트랜지스터**가 집적되어 있어.
   * 연산을 수행하는 ALU(Arithmetic Logic Unit)와 제어 장치(Control Unit)에서 트랜지스터를 활용해 논리 연산을 수행해.
2. **메모리와 저장장치에 활용**
   * **DRAM(동적 램), 플래시 메모리(SSD)** 같은 저장장치에도 트랜지스터가 사용돼.
   * DRAM에서는 **전하를 저장하는 캐패시터와 트랜지스터**가 1비트를 저장하는 기본 단위로 사용돼.
3. **트랜지스터 수의 증가와 성능 향상**
   * 트랜지스터 수가 많을수록 컴퓨터 성능이 향상돼.
   * 무어의 법칙(Moore’s Law)에 따라 트랜지스터 수는 **18\~24개월마다 2배 증가**해왔어.
   * 하지만 최근에는 미세 공정(5nm 이하)에서 한계를 맞이하며 새로운 기술(양자 컴퓨팅, 3D 트랜지스터)이 연구되고 있어.

#### 6) 트랜지스터의 미래

1. **더 작고 빠른 트랜지스터 개발**
   * **나노미터(nm) 단위 공정**이 발전하면서 **3nm, 2nm**급 트랜지스터가 연구되고 있어.
   * 기존 실리콘 기반이 아닌 **탄소 나노튜브, 그래핀** 등의 신소재 연구도 진행 중.
2. **3D 트랜지스터(게이트 올 어라운드, GAAFET)**
   * 기존 **평면형 트랜지스터** 대신 \*\*3차원 구조(3D 트랜지스터)\*\*를 활용해 성능을 높이고 발열 문제를 줄이는 연구가 진행 중.
3. **양자 컴퓨팅과 뉴로모픽 칩**
   * 전통적인 트랜지스터 대신 **양자 컴퓨팅(Quantum Computing)** 기술이 연구되며,
   * 뇌의 뉴런 구조를 모방한 뉴로모픽 칩(Neuromorphic Chip)도 개발되고 있어.

***

#### 📌 정리

> [관련 링크](https://namu.wiki/w/%ED%8A%B8%EB%9E%9C%EC%A7%80%EC%8A%A4%ED%84%B0)

1. 트랜지스터는 `반도체`를 이용해 전류의 흐름을 제어하는 전자 부품으로, 컴퓨터의 핵심 요소야.
2. 대표적인 트랜지스터 종류는 **BJT(쌍극 접합 트랜지스터)와 FET(전계 효과 트랜지스터)**&#xAC00; 있어.
3. MOSFET은 전력 소모가 적고 빠르기 때문에 현대 컴퓨터에서 가장 많이 사용돼.
4. 트랜지스터는 실리콘 웨이퍼와 광식각 공정을 이용해 대량 생산되며, CPU와 메모리 등 컴퓨터의 모든 부분에서 사용돼.
5. 미래에는 3D 트랜지스터, 나노미터 공정, 양자 컴퓨팅 등 새로운 기술이 연구되고 있어.

### 4️⃣ 집적 회로

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

#### 1) 트랜지스터에서 집적 회로(IC)로의 발전

* 트랜지스터가 등장하면서 **더 작고, 빠르고, 신뢰할 수 있으며 전력 소모도 적은 논리 회로**를 만들 수 있게 됐어.
* 하지만 트랜지스터로 **AND, OR 같은 간단한 논리 회로**를 만들려 해도 **너무 많은 부품이 필요**했고, 복잡한 회로를 만들기가 어려웠어.

#### 2) 집적 회로(IC, Integrated Circuit)의 탄생

* 1958년, 미국 엔지니어 잭 킬비(Jack Kilby)와 물리학자 로버트 노이스(Robert Noyce)가 `집적 회로(IC)`를 발명했어.
* **IC(집적 회로)란?**
  * 여러 개의 트랜지스터, 저항, 콘덴서를 한 개의 반도체 칩에 집어넣은 전자 회로야.
  * 이전에는 개별적으로 조립해야 했던 회로를 **칩 한 개**로 대체할 수 있어.
  * **트랜지스터를 하나씩 조립하는 것보다 비용이 훨씬 저렴하고, 성능도 좋아졌어.**

👉 **IC는 생긴 모양 때문에 ‘칩(Chip)’이라고도 불려.**

#### 3) 트랜지스터 → IC 발전의 주요 효과

1. **회로 크기 감소**: 동일한 기능을 수행하는 회로가 훨씬 작아짐.
2. **전력 소모 감소**: 트랜지스터 개별 사용보다 전력 효율이 높음.
3. **신뢰성 향상**: 개별 부품을 납땜하던 방식보다 오류가 적어짐.
4. **제작 비용 절감**: 동일한 칩을 대량 생산할 수 있어 가격이 저렴해짐.
5. **처리 속도 향상**: 칩 내부의 신호 이동 거리가 짧아져 연산 속도가 빨라짐.

#### 4) 집적 회로(IC)의 중요성

* **릴레이, 진공관, 트랜지스터, IC(집적 회로)** → 점점 작아지고, 빠르고, 효율적인 회로로 발전해왔어.
* 현재 우리가 사용하는 컴퓨터, 스마트폰, 전자 기기들은 **IC가 없으면 작동할 수 없어.**
* **IC가 등장하면서 현대 디지털 컴퓨터 시대가 본격적으로 시작됐어.**

👉 **다음으로는 조합 논리(Combinational Logic)를 위한 IC 회로 설계 방식에 대해 알아보자!**

***

## 4. 논리게이트

### 0️⃣ 들어가기

#### 1) **논리 게이트와 집적 회로(IC)의 발전**

* 1960년대 중반, 잭 킬비(Jack Kilby)와 로버트 노이스(Robert Noyce)가 **집적 회로(IC, Integrated Circuit)**&#xB97C; 발명했어.
* 텍사스 인스트루먼츠(TI)는 **5400, 7400 시리즈 논리 IC**를 출시했고, 이 칩들은 <mark style="color:red;">AND, OR, NOT 같</mark>은 **기본 논리 연산을 수행하는 회로**를 포함하고 있었어.
  * 이런 회로    를 논리 게이트logic gate라고 부르며, 그냥 `게이트`라고도 해
* 하드웨어 설계자는 이 IC를 사용하여 **기존의 트랜지스터 기반 회로보다 훨씬 적은 부품으로 논리 회로를 쉽게 구현**할 수 있었어.
  * 기성 제품들을 복잡한 배관으로 연결해 수도 시스템을 만드는 것과 같음

#### 2) **논리 게이트(Logic Gate)란?**

* 논리 게이트는 **하드웨어적으로 논리 연산을 수행하는 기본 요소**야.
* 입력 신호(A, B 등)를 받아 특정 논리 연산을 수행한 후, **출력(Y)을 결정**해.
* 마치 수도관을 조립하듯이 논리 게이트들을 조합하면 **더 복잡한 연산을 수행하는 디지털 회로를 만들 수 있어**.

**기본 논리 게이트 종류(논리 설계자의 박스 같은 존재)**

<figure><img src="../../.gitbook/assets/image (164).png" alt=""><figcaption></figcaption></figure>

* **AND 게이트**: 두 입력이 모두 1일 때만 출력이 1
* **OR 게이트**: 두 입력 중 하나라도 1이면 출력이 1
* **XOR(배타적 OR) 게이트**: 두 입력이 다를 때만 출력이 1
* **NOT 게이트(인버터)**: 입력 값을 반전(0이면 1, 1이면 0)
  * 동그라미가 없는 삼각형은 `버퍼`로 **입력을 출력으로 단지 전달만 한다.**

{% hint style="warning" %}
**이러한 논리 게이트들은 트랜지스터들로 구성되어 있어!**
{% endhint %}

* 예를 들어, **TTL(Transistor-Transistor Logic) 방식에서는 트랜지스터 2개로 NAND 게이트를 만들 수 있어.**
* CMOS 회로에서는 NAND 게이트를 만들기 위해 4개의 트랜지스터를 사용해.

#### 3) **NAND와 NOR 게이트가 기본이 되는 이유**

<figure><img src="../../.gitbook/assets/image (166).png" alt=""><figcaption></figcaption></figure>

> 디지털 회로에서는 **NAND와 NOR 게이트가 가장 많이 사용**돼. 왜일까?

**① NAND와 NOR는 모든 논리를 만들 수 있음 (완전 논리 집합)**

* NAND와 NOR 게이트는 **모든 논리 연산을 조합해서 만들 수 있는 완전한 집합**이야.
* NAND만으로도 AND, OR, NOT을 구현할 수 있어 → 그래서 디지털 회로에서는 `NAND 기반 회로`가 많아.

**② 트랜지스터 개수를 절약할 수 있음**

* **NAND 게이트는 AND 게이트보다 트랜지스터 개수가 적음**.
* AND 게이트를 만들려면 **NAND + NOT(인버터)이 필요**한데, NAND는 자체적으로 반전 기능을 포함하고 있어 불필요한 트랜지스터를 줄일 수 있어.

**③ 반응 속도가 더 빠름**

* AND나 OR 게이트보다 **NAND와 NOR가 회로를 더 간단하게 구성할 수 있어서 연산 속도가 빠름**.

#### 4) **드모르간의 법칙과 NAND의 활용**

> NAND 게이트는 AND + NOT이 결합된 형태이지만, **드모르간의 법칙**을 사용하면 OR 게이트처럼 동작할 수도 있어.

**드모르간의 법칙**

<figure><img src="../../.gitbook/assets/image (167).png" alt=""><figcaption></figcaption></figure>

* (A ⋅ B)’ = A’ + B’ (NAND = NOT(AND) = OR 변형 가능)
* (A + B)’ = A’ ⋅ B’ (NOR = NOT(OR) = AND 변형 가능)

> 🛠 **즉, NAND를 활용하면 AND, OR, NOT을 모두 구현 가능** → **디지털 회로 설계에서 NAND가 가장 기본적인 연산 블록이 되는 이유야!**

#### 5) **입력이 2개 이상인 논리 게이트**

* 지금까지 본 게이트들은 2개의 입력(A, B)을 가졌지만, 현실에서는 **3개 이상의 입력을 갖는 게이트도 많아**.
  * **3입력 AND 게이트**: A, B, C가 모두 1이어야 출력이 1.
  * **3입력 OR 게이트**: A, B, C 중 하나라도 1이면 출력이 1.
* 이를 통해 더 복잡한 논리를 쉽게 표현할 수 있어

#### 6) **논리 게이트가 디지털 컴퓨터에 미친 영향**

{% hint style="info" %}
**초창기 컴퓨터(릴레이, 진공관) → 트랜지스터 → 논리 게이트 IC → 집적 회로 발전**
{% endhint %}

* 초기에는 트랜지스터를 개별적으로 연결해서 회로를 만들었지만, **IC 칩을 활용하면 훨씬 간결하고 빠르게 논리 회로를 구성할 수 있음**.
* CPU 내부에서도 **수십억 개의 트랜지스터가 모여 논리 게이트로 작동**하고 있어.

#### 🔥 **정리**

* 논리 게이트는 디지털 회로에서 기본적인 논리 연산을 수행하는 블록
* NAND와 NOR는 모든 논리를 표현할 수 있어서 가장 기본적인 연산 요소로 사용됨
* 드모르간의 법칙을 사용하면 NAND로 AND, OR, NOT을 모두 구현할 수 있음
* 집적 회로(IC)의 발전으로 논리 게이트를 쉽게 사용할 수 있게 되어 **디지털 컴퓨터의 발전에 핵심적인 역할을 함**&#x20;

***

### 1️⃣ 이력 현상을 활용한 잡음 내성 향상

#### 1) 디지털 신호의 잡음 문제와 글리치 현상

<figure><img src="../../.gitbook/assets/image (168).png" alt=""><figcaption></figcaption></figure>

* 논리 게이트에서 0과 1의 상태 변화가 순간적으로 일어난다고 생각할 수 있지만, <mark style="color:red;">실제로는 신호가 천천히 변하는 경우가 발생한다.</mark>
* 천천히 변하는 신호는 잡음(노이즈)에 취약하며, 이로 인해 `글리치(Glitch)`가 발생할 가능성이 높다.
  * **글리치**란 신호가 예상과 다르게 순간적으로 튀거나 불안정한 상태가 되는 현상을 의미한다. 작은 오류라는 뜻
* 그림 2-29처럼 잡음이 있는 신호는 문턱값(threshold)을 오락가락하며, 결과적으로 불안정한 출력을 만들어낸다.

#### 2) 이력 현상(Hysteresis)과 해결 방법

> `이력 현상(Hysteresis)`이란 판정 기준이 과거의 신호 상태에 따라 달라지는 것을 의미한다.

* 일반적인 논리 게이트는 단일 문턱값(Single Threshold)을 사용하지만, 이력 효과를 추가하면 **상승 문턱값(Upper Threshold)과 하강 문턱값(Lower Threshold)이 따로 존재**하게 된다.
* 이 방식은 신호가 변할 때 **문턱값을 더 크게 설정**하여 <mark style="color:red;">작은 잡음에 의해 신호가 불필요하게 변하지 않도록 만든다.</mark>
* 결과적으로, 신호의 안정성을 높이고 잡음 내성을 향상할 수 있다. 글리치를 방지할  수 있다.

#### 3) 슈미트 트리거(Schmitt Trigger)의 역할

* `슈미트 트리거(Schmitt Trigger)`는 이력 효과를 활용하여 신호의 잡음을 줄이는 특수한 논리 게이트를 의미한다.
* 일반적인 논리 게이트보다 **입력 신호의 변화에 대한 문턱값이 다르게 설정**되어 있다.

<figure><img src="../../.gitbook/assets/image (169).png" alt=""><figcaption></figcaption></figure>

* 그림 2-30에서 볼 수 있듯이, 상승할 때와 하강할 때의 문턱값이 다르게 작용하여 **신호가 더욱 안정적으로 변하도록 설계된다**.
  * 입력    신호가 두 문턱값 중 하나를 넘어간 경우 반대쪽 문턱값을 지나가며 출력이 반전되려면 값이 상    \
    당히 많이 변해야 한다는 뜻이다.
  * 잡음 내성이 커진다.
* 슈미트 트리거를 사용하면 **노이즈가 많은 환경에서도 신호를 더욱 안정적으로 유지할 수 있다**.

> 📌 **결론**\
> 슈미트 트리거는 신호의 잡음을 줄이고 안정적인 출력을 제공하는 역할을 한다. 그러나 일반적인 논리 게이트보다 복잡하고 비용이 높아 **특정한 경우(예: 센서 신호 정리, 진동 방지)에만 사용된다**.

***

### 2️⃣ 차등 신호

> 잡음이 많아서 이력을 도입해도 충분하지 못한 경우도 있음. 누군가가 나를 밀어내는 경우도 있는데 이런 경우에도 보호를 받고 싶을 때 사용하는 신호

차동 신호는 **두 개의 반전된(complementary) 신호를 동시에 전송하여 신호 간섭을 줄이고 신뢰성을 높이는 방식**이야. 이는 디지털 신호 전송에서 잡음을 줄이고, 데이터 전송의 정확성을 보장하는 중요한 기술이야.

#### **1) 차동 신호의 개념**

* 일반적으로 **한 개의 신호선**을 사용하여 데이터를 전송하는 **단일 신호(single-ended signaling)** 방식이 있어.\
  → 하지만 이 방식은 **잡음이 심한 환경에서 오류가 발생할 가능성이 높아**.
* 차동 신호는 **두 개의 반전된 신호를 함께 전송하여 잡음을 최소화하는 방식**이야.
* `두 신호의 차이(difference`를 이용하여 데이터 값을 결정하는 것이 특징이야.

> 📌 **즉, 단일 신호는 전압이 특정 기준값을 넘었는지 확인하지만, 차동 신호는&#x20;**<mark style="color:red;">**두 신호 간의 차이를 비교해서 데이터를 전송하는 방식이야!**</mark>

#### **2) 차동 신호의 동작 방식**

<figure><img src="../../.gitbook/assets/image (170).png" alt=""><figcaption></figcaption></figure>

차동 신호에서는 두 개의 선(Line)이 함께 동작해.

* **드라이버(driver)** : 입력 신호를 반전된 두 개의 신호로 변&#xD658;**(반전관계 출력물로 변환)**&#xD558;여 전송.&#x20;
* **리시버(receiver)** : 수신된 두 신&#xD638;**(반전관계의 두 입력을 받아)**&#xC758; 차이를 비교하여 데이터를 해석.

이렇게 하면 **잡음이 신호선 두 개에 동일하게 영향을 주기 때문에(공통 모드 잡음)**,\
`리시버`가 두 신호의 차이를 계산하면 잡음이 제거돼.

#### **3) 차동 신호의 장점**

**① 잡음 내성(Noise Immunity)이 뛰어남**

* 주변에서 발생하는 전자기 간섭(EMI)이나 신호 간섭을 효과적으로 제거할 수 있어.
* 예를 들어, 주변 환경에서 생기는 잡음이 두 신호에 똑같이 영향을 미치면, 리시버는 **두 신호의 차이**만을 사용하기 때문에 잡음이 제거돼.

**② 장거리 데이터 전송에 유리함**

* 단일 신호 방식은 거리가 길어질수록 신호가 약해지고 노이즈가 많이 끼지만,\
  차동 신호는 신호 강도를 일정하게 유지할 수 있어.

**③ 신호 속도가 빠름**

* 차동 신호는 높은 주파수에서도 왜곡이 적어 고속 데이터 전송에 유리해.

***

#### **4) 차동 신호의 응용 분야**

차동 신호는 다양한 디지털 통신 및 전송 기술에서 사용돼.

| **기술**                                         | **설명**                                           |
| ---------------------------------------------- | ------------------------------------------------ |
| **USB(Universal Serial Bus)**                  | 고속 데이터 전송을 위해 차동 신호를 사용                          |
| **Ethernet(이더넷 LAN)**                          | 네트워크 케이블에서 노이즈 제거를 위해 연선(Twisted-Pair) 방식과 함께 사용 |
| **SATA(Serial ATA)**                           | 하드디스크와 메인보드 간의 데이터 전송에 차동 신호 적용                  |
| **LVDS(Low Voltage Differential Signaling)**   | 노트북, 모니터 등의 디지털 디스플레이 데이터 전송                     |
| **HDMI(High-Definition Multimedia Interface)** | 고해상도 영상 및 음성 데이터를 고속으로 전송하기 위해 차동 신호를 사용         |

> 📌 **즉, 우리가 사용하는&#x20;**<mark style="color:red;">**대부분의 컴퓨터 및 네트워크 장비는 차동 신호를 활용**</mark>**하여 데이터를 빠르고 안정적으로 전송하고 있어!**

***

#### **5) 차동 신호의 역사**

차동 신호는 19세기 후반부터 활용되었어.

* **1880년대**: 전화선에서 노면전차의 전자기 간섭 문제를 해결하기 위해 **알렉산더 그레이엄 벨**이 연선(Twisted-Pair) 방식을 발명.
* **20세기 중반**: 디지털 회로와 컴퓨터가 발전하면서 **USB, 이더넷, HDMI 등 다양한 통신 기술에서 차동 신호를 활용**.
* **현대**: 5G, 고속 데이터 센터 네트워크, 광통신 시스템 등에서도 차동 신호를 이용한 기술이 계속 발전 중.

***

#### **6) 차동 신호와 연선(Twisted-Pair)**

차동 신호를 효과적으로 사용하기 위해 **연선(Twisted-Pair)** 기법이 사용돼.

* 두 개의 신호선을 **서로 꼬아 배치**하면, 외부의 전자기 간섭이 양쪽 신호선에 **동일한 정도**로 영향을 줘서 간섭 효과를 최소화할 수 있어.
* 이 방식은 **이더넷, 전화선, USB, SATA 케이블** 등에 널리 사용돼.

***

#### **7) 차동 신호의 한계**

아무리 차동 신호가 뛰어나도, 잡음이 너무 심하면 완벽하게 해결할 수 없어.

* `공통 모드 잡음(Common Mode Noise)`이 너무 강하면 차동 신호도 영향을 받을 수 있어.
* `공통 모드 판별비(CMRR, Common Mode Rejection Ratio)`라는 개념을 사용해 얼마나 잡음을 잘 제거할 수 있는지를 측정해.
  * 공통 모드 판별비CMRR, common-mode rejection ratio는 부품 정격 중    &#x20;하나로 처리 가능한 잡음의 양을 표시한다.
  * ‘공통 모드’라고 부르는 이유는 (서로 반전관계인) 두    &#x20;신호에서 **공통인 잡음**을 가리키기 때문
* 차동 신호를 사용할 때도 **케이블의 품질, 신호 강도, 회로 설계**가 중요해.

***

#### **8) 정리**

✅ 차동 신호(Differential Signaling)는 **두 개의 반전 신호를 동시에 전송하여 신호 간섭을 줄이고 안정성을 높이는 방식**이야.\
✅ 잡음에 강하고, 장거리 전송이 가능하며, 고속 데이터 전송에 적합해.\
✅ USB, Ethernet, HDMI, SATA, LVDS 등 다양한 디지털 통신 기술에서 활용되고 있어.\
✅ 연선(Twisted-Pair) 방식과 함께 사용하면 전자기 간섭을 최소화할 수 있어.\
✅ 하지만 `공통 모드 잡음`이 너무 크면 차동 신호도 영향을 받을 수 있으므로, **CMRR 등 추가적인 설계가 필요해.**

> 📌 **즉, 차동 신호는 현대 디지털 통신의 필수적인 기술이며, 우리가 사용하는 대부분의 고속 데이터 전송 기술에서 활용되고 있어!**

### 3️⃣전파  지연

#### **1) 전파 지연(Propagation Delay)이란?**

전파 지연은 **디지털 회로에서 입력 신호가 바뀐 후 출력이 바뀔 때까지 걸리는 시간**을 의미해.\
즉, **입력 신호가 0 → 1 또는 1 → 0으로 바뀌었을 때, 출력이 따라 바뀌는 데 걸리는 시간**이지.

* **제조 공정, 온도, 부품 특성에 따라 달라질 수 있음.**
* **게이트를 많이 연결할수록(연쇄적으로 연결된 논리 회로가 많을수록) 전파 지연이 누적되어 속도가 느려짐.**
* **디지털 회로의 동작 속도를 제한하는 주요 요인 중 하나.**

#### **2) 전파 지연의 영향: 신호가 즉시 변하지 않는 이유**

실제로 논리 게이트는 입력이 바뀌어도 **즉시 출력이 바뀌지 않음.**\
**최소 지연(Min Delay)과 최대 지연(Max Delay) 사이에서 랜덤하게 출력이 변경됨.**

**① 전파 지연이 생기는 이유**

* **회로 내부에서 전자가 이동하는 시간이 필요함.**
* **배선의 길이, 신호 전송 속도, 트랜지스터의 응답 속도 등 다양한 요인에 의해 결정됨.**
* **제조 공정(프로세스)에 따라 지연 시간이 다름.**
  * **고급 공정(예: 최신 CPU)** → 전파 지연이 짧음(피코초 단위).
  * **낡은 공정(예: TTL IC)** → 전파 지연이 길음(나노초 단위).

**② 전파 지연이 길어지면 어떤 문제가 생길까?**

* **논리 회로의 신뢰성이 떨어짐.**
  * 예를 들어, 신호가 **너무 늦게 도착하면** 다음 단계에서 올바르게 해석하지 못할 수 있음.
* **고속 연산이 어려워짐.**
  * CPU처럼 **수천억 개의 연산을 초당 수행해야 하는 경우, 지연 시간이 길면 전체 성능이 저하됨.**
* **글리치(Glitch) 발생 가능성 증가**
  * 신호가 천천히 변하거나 잡음이 많을 경우 **잘못된 신호가 일시적으로 발생할 수 있음.**
  * 예를 들어, 논리 회로에서 **출력이 순간적으로 1 → 0 → 1로 바뀌는 등 불안정한 상태가 생길 수 있음.**

#### **3) 전파 지연이 표시되는 방식**

데이터시트(Datasheet)에서 전파 지연 시간은 **tPLH와 tPHL**로 표시돼.

* **tPLH (Propagation time from Low to High):**
  * **0 → 1로 변할 때 걸리는 시간.**
* **tPHL (Propagation time from High to Low):**
  * **1 → 0으로 변할 때 걸리는 시간.**

📌 예제)\
7400 계열 TTL IC의 경우 **전파 지연이 약 10ns(나노초)**\
최신 CPU 내부 논리 게이트의 경우 **전파 지연이 피코초(ps, 1조분의 1초) 단위**

#### **4) 전파 지연을 줄이는 방법**

전파 지연을 줄이면 회로가 더 빠르게 동작할 수 있어.

> 그렇다면 **전파 지연을 줄이는 방법은 무엇이 있을까?**

**① 최신 반도체 공정을 사용하기**

* 트랜지스터 크기를 줄이면 전자가 이동하는 거리가 짧아져 속도가 빨라짐.
* **예:**
  * **고전적인 7400 시리즈(나노초 단위) → 최신 CMOS 공정(피코초 단위)**
  * **CPU의 공정 발전: 90nm → 45nm → 7nm → 3nm → 2nm(예정)**

**② 병렬 처리 및 파이프라이닝 사용**

* 전파 지연을 극복하기 위해 **CPU는 여러 개의 논리 연산을 동시에 수행하는 병렬 구조를 활용함.**
* 파이프라이닝(Pipelining) 기법을 사용하면 **한 번에 여러 단계의 연산을 처리할 수 있음.**

**③ 배선 길이 최소화**

* **전선이 길어질수록 신호 전파 속도가 느려짐.**
* 최신 반도체 칩에서는 **전선 배치를 최적화하여 신호 전송 지연을 최소화함.**

#### **5) 전파 지연이 논리 회로에서 실제로 어떻게 보일까?**

📌 **논리 게이트에서 전파 지연이 발생하는 과정:**

1. **입력 A가 0 → 1로 바뀜**
2. **출력 B는 즉시 변하지 않고, 짧은 시간(전파 지연) 동안 신뢰할 수 없는 상태가 됨**
3. **출력 B가 1로 안정화됨**

📌 **결과적으로 나타나는 현상:**

* 입력이 바뀐 후 **출력이 바로 바뀌지 않음.**
* 여러 논리 게이트를 연달아 연결할수록 **전파 지연이 누적되면서 전체 연산 속도가 느려짐.**

#### **6) 결론: 전파 지연을 고려한 회로 설계가 필수적!**

✅ 전파 지연(Propagation Delay)은 <mark style="color:red;">**디지털 회로에서 입력이 바뀐 후 출력이 바뀔 때까지 걸리는 시간**</mark>이야.\
&#xNAN;**✅** 논리 게이트를 많이 연결할수록 전파 지연이 누적되어 회로 속도가 느려질 수 있어.\
✅ 최신 반도체 공정(미세 공정), 병렬 처리, 배선 최적화 등을 통해 전파 지연을 최소화하는 것이 중요해.\
✅ CPU와 같은 고속 회로는 전파 지연을 극복하기 위해 다양한 기술을 사용하며 발전해 왔어.

즉, **전파 지연을 줄이는 것이 컴퓨터 속도를 높이는 핵심 기술 중 하나!** 🚀💡

### 4️⃣출력 유형

#### **1) 게이트 출력의 종류와 특징**

게이트의 입력에 대한 논의는 많았지만, 출력 방식도 중요해.\
출력 방식은 논리 회로의 특성에 따라 다르게 설계되며, 사용 목적에 따라 몇 가지 방식이 있어.

#### **2) 토템폴 출력 (Totem-Pole Output)**

<figure><img src="../../.gitbook/assets/image (173).png" alt=""><figcaption></figcaption></figure>

토템폴 출력은 **게이트에서 가장 일반적인 출력 방식**이야.\
이 방식은 **트랜지스터가 토템폴(기둥)처럼 수직으로 배치되어 있기 때문에** 이런 이름이 붙었어.

**토템폴 출력의 동작 방식**

* 출력이 **1(High)** 이면 **위쪽 트랜지스터가 활성화되어 전압이 출력됨.**
* 출력이 **0(Low)** 이면 **아래쪽 트랜지스터가 활성화되어 출력이 접지(Ground)에 연결됨.**
* **빠른 응답 속도**를 제공하지만, 서로 다른 토템폴 출력을 직접 연결하면 **단락(Short Circuit)** 이 발생할 위험이 있어.

**토템폴 출력의 장점과 단점**

✅ **장점:** 빠른 응답 속도, 강한 드라이빙 능력\
❌ **단점:** 여러 개를 직접 연결할 수 없음 <mark style="color:blue;">(출력끼리 연결하면 음극, 양극을 서로 연결하는 단락 발생)</mark>

#### **3) 오픈 컬렉터(Open-Collector) / 오픈 드레인(Open-Drain) 출력**

<figure><img src="../../.gitbook/assets/image (175).png" alt=""><figcaption></figcaption></figure>

토템폴 출력과 다르게, **오픈 컬렉터(BJT 기반) 또는 오픈 드레인(MOSFET 기반) 출력은 하단 트랜지스터만 존재함.**

**오픈 컬렉터 / 오픈 드레인의 동작 방식**

* 출력이 **0(Low)** 일 때, 트랜지스터가 켜지고 출력이 **접지(Ground)에 연결됨.**
* 출력이 **1(High)** 일 때, 트랜지스터가 꺼지고 **출력 단자가 떠 있는 상태(Hi-Z, High Impedance)** 가 됨 ⇒ 출력 값을 알 수 없음
* 따라서, **외부에서 풀업 저항(Pull-up Resistor)을 추가해야만 정상적인 1(High) 출력을 얻을 수 있음.**

**오픈 컬렉터 / 오픈 드레인의 장점과 단점**

✅ **장점:**

* 여러 개의 게이트 출력을 직접 연결할 수 있음 (와이어드 AND, 와이어드 OR 가능)
* 다른 전압 레벨과도 호환 가능 (다른 논리 게이트 패밀리와 연결 가능)

❌ **단점:**

* 별도의 **풀업 저항이 필요**함.
* 응답 속도가 **토템폴보다 느림** (저항을 통해 전압이 올라가야 하므로)

#### **4) 와이어드 AND (Wired-AND) / 와이어드 OR (Wired-OR)**

오픈 컬렉터 출력을 활용하면 여러 출력들을 하나의 선에 연결해서 **논리 연산을 자연스럽게 구현**할 수 있어.

**와이어드 AND (Wired-AND)**

* 여러 개의 오픈 컬렉터 출력을 **공통 풀업 저항을 통해 연결하면 AND 연산을 수행**할 수 있음.
* 모든 출력이 1일 때만 최종 출력이 1이 됨.
* **산업용 I²C 통신 등에 사용됨.**

**와이어드 OR (Wired-OR)**

* 와이어드 AND를 부논리(Negative Logic)로 해석하면 **와이어드 OR** 이 됨.
* 즉, 출력 중 하나라도 1이면 최종 출력이 1이 됨.

✅ **와이어드 AND / OR의 장점:**

* **여러 개의 논리 회로를 간단하게 연결 가능.**
* **트랜지스터 개수를 줄일 수 있음.**

❌ **단점:**

* **속도가 느림** (저항을 통해 신호가 올라오는 데 시간이 걸림).

#### **5) 트라이스테이트(Tri-State) 출력**

일반적인 논리 게이트 출력은 **0 또는 1** 이지만,\
트라이스테이트 출력은 **0, 1, 그리고 Hi-Z(High Impedance, 높은 임피던스) 상태** 세 가지를 가질 수 있어.

**트라이스테이트 출력의 동작 방식**

* **활성화(Enable) 신호가 1이면, 정상적으로 0 또는 1을 출력.**
* **활성화(Enable) 신호가 0이면, 출력이 Hi-Z 상태(연결이 끊어진 상태)로 유지됨.**

**트라이스테이트 출력의 장점과 단점**

✅ **장점:**

* 여러 개의 장치를 **한 개의 데이터 버스에 연결할 수 있음.**
* 병렬 데이터 전송에 유용함.

❌ **단점:**

* **출력 충돌(Output Contention) 방지를 위해 적절한 제어가 필요함.**

> 📌 **트라이스테이트 출력은 컴퓨터의 데이터 버스, 메모리 인터페이스 등에 많이 사용됨.**

#### **6) 출력 방식 비교 정리**

| 출력 방식          | 동작 원리                  | 장점             | 단점           | 주요 용도               |
| -------------- | ---------------------- | -------------- | ------------ | ------------------- |
| **토템폴**        | 상단 & 하단 트랜지스터로 0, 1 출력 | 빠른 응답 속도       | 직접 연결 불가능    | 일반 논리 게이트           |
| **오픈 컬렉터/드레인** | 하단 트랜지스터만 존재, 풀업 저항 필요 | 다중 출력 연결 가능    | 풀업 저항 필요, 느림 | 와이어드 AND/OR, LED 구동 |
| **트라이스테이트**    | 활성화 신호에 따라 Hi-Z 상태 추가  | 데이터 버스에서 활용 가능 | 적절한 제어 필요    | 메모리, 데이터 버스         |

#### **7) 결론**

* **토템폴 출력**: 가장 일반적인 논리 게이트 출력 방식, 빠른 응답 속도를 제공하지만, 여러 게이트를 직접 연결할 수 없음.
* **오픈 컬렉터/드레인 출력**: 와이어드 AND/OR 구현이 가능하고 전압 레벨 변환이 쉬우나, 별도의 풀업 저항이 필요하고 속도가 느림.
* **트라이스테이트 출력**: 데이터 버스처럼 다중 장치 연결이 필요한 곳에서 사용되며, 적절한 활성화(Enable) 신호가 필요함.

> 결론적으로, **출력 방식은 논리 회로의 용도에 따라 달라지며, 각각의 방식이 최적화된 사용처가 있음!** 🚀

***

## 5. 게이트를 조합한 복잡한 회로

### 0️⃣ 들어가기

#### **1) 하드웨어 설계가 단순해진 이유**

초창기에는 **트랜지스터와 개별 부품을 직접 조립하여 논리 회로를 구성**해야 했지만, `게이트가 포함된 집적 회로(IC)`가 등장하면서 하드웨어 설계가 크게 단순화되었어.

**✅ 게이트를 직접 구성할 때의 문제점**

* **부품 수 증가**: 단순한 NAND 게이트 하나를 만들기 위해서도 10개 이상의 부품이 필요함.
* **회로 설계 복잡성**: 모든 회로를 직접 배선해야 해서 설계 과정이 복잡함.
* **부피 증가**: 회로가 커질수록 차지하는 공간이 커지고, PCB(인쇄회로기판) 제작도 어려워짐.

**✅ 집적 회로(IC)를 사용할 때의 장점**

* **NAND, NOR 같은 논리 게이트가 하나의 칩 안에 내장됨** → 개별 부품을 조립할 필요 없음.
* **크기가 작아지고 회로 설계가 간단해짐** → 공간 절약 및 설계 효율 증가.
* **생산 비용 절감** → 대량 생산이 가능해져 가격이 저렴해짐.

#### **2) 집적 회로(IC)의 발전 과정**

집적 회로는 **게이트 조합의 크기와 복잡성에 따라 구분**할 수 있어.

| 집적 회로(Integration)    | 특징                      | 예제                     |
| --------------------- | ----------------------- | ---------------------- |
| **SSI (소규모 집적 회로)**   | 한 패키지에 몇 개의 논리 게이트만 포함됨 | 7400 (4개의 NAND 게이트 포함) |
| **MSI (중간 규모 집적 회로)** | 자주 사용되는 게이트 조합이 포함됨     | 가산기(Adder), 디코더, 멀티플렉서 |
| **LSI (대규모 집적 회로)**   | 복잡한 기능을 수행하는 부품 포함      | CPU의 일부, 레지스터, 메모리     |
| **VLSI (초대규모 집적 회로)** | 수백만 개 이상의 트랜지스터 포함      | 현대적인 CPU, GPU, RAM     |

**✅ 예제: SSI vs. MSI vs. LSI 비교**

* **SSI**: NAND 게이트 IC(7400)에는 4개의 NAND 게이트가 들어 있음.
* **MSI**: 8비트 가산기(Adder) IC에는 여러 개의 논리 게이트가 미리 조합되어 있음.
* **LSI**: CPU의 일부 기능(예: ALU)이 하나의 칩에 내장됨.
* **VLSI**: **CPU, GPU처럼 수십억 개의 트랜지스터가 들어간 복잡한 칩**.

#### **3) 논리 게이트 조합으로 복잡한 시스템 만들기**

게이트를 조합하면 **단순한 논리 연산을 넘어 더 복잡한 디지털 시스템을 설계할 수 있음.**\
프로그래밍에서 작은 함수들을 조합해 더 큰 프로그램을 만드는 것과 같은 개념이야.

**✅ 게이트 조합으로 만든 주요 부품들**

1. **조합 논리 회로**
   * 가산기(Adder)
   * 디코더(Decoder)
   * 멀티플렉서(Multiplexer)
2. **순차 논리 회로**
   * 플립플롭(Flip-Flop)
   * 레지스터(Register)
   * 카운터(Counter)
3. **더 높은 수준의 집적 회로**
   * 연산 논리 장치(ALU, Arithmetic Logic Unit)
   * 메모리(RAM, ROM)
   * 중앙처리장치(CPU)

#### **4) 결론**

* **초기에는 트랜지스터와 개별 부품을 직접 연결해 회로를 구성해야 했음.**
* **NAND 같은 논리 게이트가 포함된 IC가 등장하면서 회로 설계가 단순해짐.**
* **집적 회로(SSI → MSI → LSI → VLSI) 기술이 발전하면서 더 복잡한 기능을 수행할 수 있게 됨.**
* **게이트를 조합해 단순한 논리 연산뿐만 아니라 CPU, 메모리 같은 복잡한 시스템도 설계 가능.**

> 즉, **집적 회로(IC)의 발전 덕분에 하드웨어 설계가 더 단순해지고, 작은 공간에서도 강력한 연산이 가능해진 것!**&#x20;

### 1️⃣ 가산기





## 정리

#### **2장 정리: 비트와 조합 논리 회로의 발전**

**1) 숫자 대신 비트를 사용하는 이유**

* \*\*비트(Binary)\*\*는 0과 1로 표현되며, **전압(ON/OFF) 상태로 쉽게 변환 가능**.
* 전자 회로에서는 **2진법(비트) 기반 연산이 하드웨어적으로 더 단순하고 신뢰성이 높음**.
* 10진법을 사용할 경우, 문턱값을 10개로 구분하는 복잡한 회로가 필요하지만, **비트 기반 설계는 문턱값을 단순화할 수 있음**.

**2) 논리 회로의 발전 과정**

* **릴레이(Relay)** → **진공관(Vacuum Tube)** → **트랜지스터(Transistor)** → **집적 회로(IC, Integrated Circuit)**
* 하드웨어 기술이 발전하면서 **더 작고, 빠르고, 전력 효율적인 논리 회로가 가능해짐**.

**3) 조합 논리 회로(Combinational Logic)**

* **입력 값에 따라 즉시 출력이 결정됨** → 메모리 기능이 없음.
* NAND, NOR, XOR 등 다양한 \*\*게이트(Gate)\*\*를 조합하여 복잡한 논리 회로를 설계 가능.
* **가산기(Adder), 멀티플렉서(Multiplexer) 등 여러 디지털 장치 구성 가능**.

**4) 조합 논리의 한계**

* **출력이 항상 입력의 함수**이므로, **정보를 저장하는 기능이 없음**.
* **메모리 기능이 필요한 경우 순차 논리(Sequential Logic)가 필요함**.
* 즉, **출력을 ‘고정’하여 시간이 지나도 기억하는 기능이 필요**.

**5) 다음 장에서 배울 내용: 순차 논리(Sequential Logic)**

* 출력을 유지하여 기억하는 기능을 추가하는 방법.
* 래치(Latch)와 플립플롭(Flip-Flop)을 활용한 저장 장치 구현.
* 클럭(Clock) 신호를 이용한 상태 변화 제어.

> 📌 **결론**\
> **2장은 비트를 사용한 디지털 논리 설계의 기초와 조합 논리의 한계를 이해하는 과정이었다.**\
> **3장에서는 데이터를 ‘기억’하는 순차 논리 회로를 배우면서 저장 기능이 어떻게 구현되는지 알아볼 것이다.**&#x20;



출처 및 참고

* [컴퓨터구조-컴퓨터-구조와-기능 CPU](https://velog.io/@ckstn0777/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%EA%B8%B0%EB%8A%A5-CPU)
