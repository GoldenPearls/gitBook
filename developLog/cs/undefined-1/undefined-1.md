---
icon: '8'
---

# 프로그래밍 언어 처리 – 코드가 컴퓨터에서 실행되기까지의 여정

이번 장에서 프로그래밍 언어가 어떻게 구현되는지를 살펴봅니다. 기계어라는 실행 가능한 형태로 어떻게 변환되는지를 배우게 돼요\~

우리 인간은 고수준 언어(Python, Java 등)로 프로그램을 씁니다. 하지만 CPU는 기계어만 이해하죠. 그렇다면 질문이 생깁니다.

> "내가 짠 코드는 CPU가 어떻게 이해하는 걸까?"

이 질문에 답하기 위해, **프로그래밍 언어 처리**의 긴 여정을 함께 따라가봅시다.

프로그래밍 언어의 계층은 사진과 같습니다!

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### 1. 기계어는 너무 괴로워! 어셈블리 언어의 등장

&#x20;기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어입니다.



컴퓨터 초창기, 프로그래머들은 **모든 명령어를 직접 이진수로 작성**해야 했습니다. 예를 들어, 피보나치 수를 계산하려면 `1010001000001010` 같은 기계어 명령어를 하나하나 입력해야 했죠. 너무 고통스러운 일이었기 때문에, 사람들은 **좀 더 인간적인 방법**을 고민하게 됩니다.

#### &#x20;그래서 등장한 것이 바로 **어셈블리 언어**입니다.

{% hint style="danger" %}
기계어의고통을 줄이기 위해, 인간 친화적인 **니모닉(mnemonic)**&#xC744; 사용하는 어셈블리 언어가 등장했습니다.
{% endhint %}

니모닉(mnemonic) : `LOAD`, `STORE`, `ADD` 같은 읽기 쉬운 단어로 기계어를 표현합니다.

```
load #0
store first
```

➡ 이것이 기계어로 번역되는 작업은 어셈블러가 담당합니다.

* 주소에는 `심볼`이라는 이름을 붙여 가독성을 높이고,  `의사명령어(Pseudo-instruction)`로 **메모리 할당**도 명시할 수 있죠.
* **레이블(label)** : 명령어 주소에 의미 있는 이름을 붙여줍니다.
* **주석(comment)** : 코드에 설명을 달 수 있어 다른 사람이 이해하기 쉬워집니다.



예를 들어, 아래는 피보나치 수열을 어셈블리 언어로 작성한 예입니다.

```asm
load #0       ; first를 0으로 설정
store first
load #1       ; second를 1로 설정
store second

again: load first
add second
store next

load second
store first
load next
store second
cmp #200
ble again

first: bss 1
second: bss 1
next: bss 1
```

`bss`는 **변수를 위한 공간만 확보**하고 초기화는 하지 않는 의사 명령어입니다. 어셈블러는 이 코드로부터 **실제 기계어를 생성**합니다.

컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 **기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 됩니다.**&#x20;

컴퓨터 CPU마다 지원하는 오퍼레이션의 타입과 개수는 제각각이며, 레지스터의 크기와 개수, 저장된 데이터 형의 표현도 각기 다릅니다. 모든 범용 컴퓨터는 기본적으로 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행할지는 다를 수 있으며, 이런 차이는 어셈블리어에 반영되게 돼요.

> 그래서 개발자들은 어려운 방식, 즉 직접 손으로 모든 비트를 알아내는 방법으로 최초의 어셈블러를 작성해야 했습니다.&#x20;

물론입니다! 방금 공유해주신 \*\*『한권으로 읽는 컴퓨터 구조와 프로그래밍』 8장 "프로그래밍 언어 처리"\*\*의 내용을 아래와 같이 발표용 스크립트 형식으로, 이야기하듯 풍부하게 정리해드리겠습니다



## 2. 어셈블리어도 너무 장황해! 고수준 언어의 탄생

어셈블리 언어도 여전히 사람이 작성하기엔 복잡한 면이 있었습니다. 그래서 더 높은 수준의 추상화를 제공하는 `고수준 언어(high-level language)`가 등장합니다.

#### 대표적인 고수준 언어:

* **포트란(FORTRAN)**: 수식을 계산할 수 있는 최초의 고수준 언어
* **베이직(BASIC)**: 초보자를 위한 명령어 기반 언어
* **C 언어**: 구조적 프로그래밍의 대표, 이후 많은 언어의 기반이 됨

```fortran
I = 0
J = 1
5 K = I + J
I = J
J = K
IF (J .LT. 200) GOTO 5
```

GOTO가 많아서 **스파게티 코드**가 되기 쉬웠고, 구조적인 코드 작성을 위해 **구조적 프로그래밍(structured programming)**&#xC774; 대두됩니다.



## 3. 구조적 프로그래밍이란?

### 1) 구조적 프로그래밍의 핵심 개념

1. **순차(Sequence)**
   * 명령은 위에서 아래로, 한 줄씩 차례로 실행됩니다.
2. **분기(Selection)**
   * if, switch 등을 통해 조건에 따라 흐름을 분기합니다.
3. **반복(Iteration)**
   * while, for 같은 반복문을 통해 일정 조건 동안 반복합니다.

> 이 세 가지 요소로 **모든 프로그램의 논리 구조를 만들 수 있다**는 것이 구조적 프로그래밍의 핵심입니다.

### 2) 구조적 언어 vs 비구조적 언어

특징 구조적 언어 비구조적 언어

| 코드 흐름 | 명확한 순서, 조건, 반복          | GOTO로 아무 데나 이동    |
| ----- | ----------------------- | ----------------- |
| 유지보수  | 쉬움 (읽기 쉬움)              | 어려움 (스파게티 코드 발생)  |
| 예시 언어 | C, Pascal, Java, Python | 초기 Fortran, Basic |

### 3) 스파게티 코드란?

> **GOTO 문을 남용하면 코드가 여기저기 점프하게 되어**\
> 마치 **스파게티처럼 복잡하고 꼬인 코드**가 됩니다.

```
10 PRINT "HELLO"
   GOTO 10
```

위처럼 레이블(10)을 붙이고 GOTO로 점프하면, 프로그램 흐름이 제어하기 어려워집니다.\
→ 오류 수정, 로직 파악이 매우 힘들어지죠.

### 4) 구조적 언어의 대표 예시

언어 특징

| **C**            | 실용적이며 구조적 프로그래밍의 대표 주자 |
| ---------------- | ---------------------- |
| **Pascal**       | 교육용 언어로 GOTO 금지, 구조 강조 |
| **Python, Java** | 현대 언어 대부분 구조적 프로그래밍 기반 |
| **JavaScript**   | 예외는 있지만 대체로 구조적 흐름을 따름 |

### 5) 요약

* 구조적 언어는 순차 + 조건 + 반복으로 프로그램을 구성하는 언어예요.
* GOTO 없이 흐름이 명확하게 보여서 **이해와 유지보수가 쉬워요**.
* 현대 언어는 거의 다 구조적입니다. (C, Python, Java, JS, Go 등등)

> 💬 **"구조가 있어야 사람이 이해할 수 있다."**\
> 이것이 구조적 프로그래밍의 시작점이자 이유입니다!

## 어휘 분석과 정규식: 문장을 '토막내는' 기술&#x20;

### 1) 컴파일이란?&#x20;

**주어진 언어로 작성된 컴퓨터 프로그램**을 **다른 언어의 동등한 프로그램으로 변환**하는 프로세스입니다.

* 보통 `high-level 프로그래밍 언어`를 실행 프로그램으로 만들기 위한 `lower level언어(어셈블리어,기계어)`로 바꾸는데 사용합니다.
* 원래의 문서(high-level)를 **소스 코드** 혹은 원시 코드라고 부름
* 출력된 문서(low-level)를 **목적 코드**라고 부름

> 출처 : [https://velog.io/@dbstjd0924/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-1.Lexical-Analysis](https://velog.io/@dbstjd0924/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-1.Lexical-Analysis)

### 2) Compiler의 조건 <a href="#compiler" id="compiler"></a>

1. 옮김의 과정에서 **프로그램의 뜻이 보존**되어야 함 즉, 입력받은 <mark style="color:red;">프로그램의 의미를 충실히 따라야 합니다.</mark>
2. 입력으로 들어온 프로그램을 실용적으로 개선해야 함

### 3) 컴파일 과정 <a href="#undefined" id="undefined"></a>

![](https://velog.velcdn.com/images/dbstjd0924/post/0f7e30a0-0301-4581-9278-01fc37cb0f63/image.png)

### 4) 어휘 분석

{% hint style="warning" %}
컴파일러의 첫 번째 단계는 소스 코드를 정규 문법 (regular grammar)에 따라 토큰 (token)으로 분류하는 어휘 분석 또는 스캐닝 (scanning)입니다.
{% endhint %}

> 💡 예를 들어, “Hello world"라는 문장에서 'H', 'e', 'l', 'l', 'o'을 따로 놓으면 어떠한 의미도 없지만, "Hello"라는 하나의 조각으로 보면 의미를 갖게 됩니다.

이제 컴퓨터가 프로그래밍 언어를 어떻게 **분해해서 이해하는지** 살펴보겠습니다. 언어를 어떤 식으로 처리하는지 살펴봅시다. 먼저, 어휘 분석을 알아보는 거로!

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

컴파일러의 첫 번째 단계는 **소스 코드를 정규 문법에 따라 토큰으로 분류하는 어휘 분석** 또는 스캔입니다.

#### 1단계: 어휘 분석(Lexical Analysis)

* **문자 → 토큰(token)**: 예를 들어 `lex luthor` → `["lex", " ", "luthor"]`
* 토큰은 이름, 숫자, 연산자 등 다양한 타입을 가짐

정규식을 사용하여 부동소수점 숫자를 인식하는 예:

```regex
[+-]?(([0-9]*\.?[0-9]+)|([0-9]+\.?[0-9]*))([Ee][+-]?[0-9]+)?
```

이 정규식은 `1.23`, `-0.5`, `2e10` 등 다양한 형태의 수를 인식할 수 있습니다.



다른예를 들어, "Lexical analysis is the first step of compiler"이라는 문장에서 'L', 'e', 'x', 'i', 'c', 'a', 'l'을 따로 놓으면 어떠한 의미도 없지만, "Lexical"이라는 하나의 조각으로 보면 의미를 갖게 됩니다.

어휘 분석 단계에서 검출되는 의미 있는 조각을 어휘항목이라고 하며, 어휘 분석기는 소스 코드에서 어휘항목을 검출해서 토큰을 생성합니다.

> 여기서 용어를 정의해봅시다.

* 어휘 항목 : 소스 코드에 존재하는 의미있는 문자열, 식별자, 숫자, 키워드 등을 의미합니다.
* 패턴 : 토큰이 어휘항목을 서술하는 규칙으로써 정규문법에 따라 표현됩니다.
* 토큰 : 토큰이름과 속성값으로 구성되는 데이터쌍으로써, 각 토큰은 토큰의 패턴을 부합하는 어휘항목을 갖습니다.
* Lexer (Scanner) :  어휘 분석기를 뜻하며, 토큰을 추출하는 역할

| 구분             | 정의                                                                                 | 예시                          |
| -------------- | ---------------------------------------------------------------------------------- | --------------------------- |
| 어휘 항목( lexeme) | 소스코드에 있는 실제 단어                                                                     | x, 42, int                  |
| 패턴(pattern)    | <ul><li>어휘 항목을 서술하는 규칙</li><li>token이 lexeme를 서술하는 규칙으로써, 정규문법에 따라 표현 됨</li></ul>  | \[a-zA-Z\_]\[a-zA-Z0-9\_]\* |
| 토큰(toekn)      | <ul><li>토큰 이름 + 어휘 항목</li><li>각 token은 token의 pattern에 부합하는 lexeme를 갖는다.</li></ul> | (IDENTIFIER, "x")           |

토큰을 추출하는 것만으로는 충분하지 않을 수 있습니다.



<figure><img src="../../.gitbook/assets/image (275).png" alt=""><figcaption></figcaption></figure>

lexeme는 token의 예시라고 생각하면 되고, token은 카테고리라고 생각하면 된다. 그리고 **lexeme와 token을 잇는 규칙**이 `pattern`입니다.&#x20;

* `pattern = lexeme(index,indentifier)`

아래의 그림의 코드가 있다고 생각해봅시다.

![](https://velog.velcdn.com/images/dbstjd0924/post/774abb5f-e6c2-475c-90b9-a42491d07b82/image.png)

소스 코드상으로는 저렇게 보이는 코드지만,

> `\tif(i==j)\n\t\tz=0;\n\teles\n\t\tz=1;` 이런 식으로 이루어져 있어요.

여기서 우리가 해야할 일은 특정한 문법으로 나누어줘야 하는 것입니다.\
\
이런 패턴이 존재한다면 위의 식을 패턴에 맞게 나타낼 수 있습니다. 이러한 작업을 하기 위해서 **token-lexeme 패턴이 필요한 것!!**

<figure><img src="https://velog.velcdn.com/images/dbstjd0924/post/974421b6-56db-45a6-a903-2db87364d7d4/image.png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
즉, 우리가 쓴 코드 한줄한줄에 대해 의미 단위로 끊어주는 역할이라고 생각하면 편합니다.
{% endhint %}

여기서는 문법에 대한 오류는 잡아내지 않습니&#xB2E4;**.(parsing만)**

### **5) 정규 표현식** <a href="#undefined" id="undefined"></a>

#### 📍 정수인지 문자(key)인지, 정규표현식으로 어떻게 구분할까?

프로그래밍 언어나 컴파일러를 만들 때, 우리는 소스 코드를 "토큰" 단위로 쪼개는 작업을 해요. 이걸 \*\*어휘 분석(Lexical Analysis)\*\*이라고 하죠.

예를 들어 다음과 같은 코드가 있다고 해봅시다.

```c
x = 2;
```

여기서 `x`는 변수 이름이고 `=`는 대입 연산자이며 `2`는 정수입니다.

<figure><img src="https://velog.velcdn.com/images/dbstjd0924/post/9721317e-9bb9-4cb2-a1c1-df81253d6cd4/image.png" alt=""><figcaption></figcaption></figure>

그런데 컴퓨터는 처음엔 이걸 그저 **문자의 나열**, 즉 `'x'`, `'='`, `'2'` 이렇게밖에 몰라요.\
그래서 중요한 문제가 생깁니다.

> ❓ **"2는 문자일까? 정수일까? 혹은 변수 이름일까?"**

이걸 구분해주기 위해 `정규표현식(Regular Expression)`이 사용됩니다.

#### 🧠 정규표현식이란?

정규표현식은 우리가 평소에 문자열 찾을 때 쓰는 그 **regex**와 같은 개념이에요.

![](https://velog.velcdn.com/images/dbstjd0924/post/1d25b9ca-1adb-436d-8be5-03039d8e2b20/image.png)

예를 들어,

* 정수는 `[0-9]+` (0\~9 숫자가 하나 이상 반복)
* 식별자는 `[a-zA-Z_][a-zA-Z0-9_]*` (문자 또는 \_로 시작하고, 그 뒤에 숫자 또는 문자가 올 수 있음)
* 공백은 `[ \t\n\r]+`

이런 식으로 \*\*각 lexeme(어휘 단위)\*\*가 가져야 할 패턴을 정규표현식으로 정의해요.

정리하면,

| 타입            | 정규표현식 예시                 | 의미 설명                     |
| ------------- | ------------------------ | ------------------------- |
| `int_literal` | `[0-9]+`                 | 정수는 숫자 하나 이상              |
| `id` (식별자)    | `[a-zA-Z_][a-zA-Z0-9_]*` | 변수 이름이나 키워드로 사용될 수 있는 문자열 |
| `keyword`     | \`if                     | else                      |

정규표현식 덕분에 **문자열이 어떤 역할을 할지를 자동으로 판단**할 수 있는 거예요.

#### 🔍 정규표현식은 왜 중요할까?

정규표현식은 단지 문자열을 찾는 도구가 아니라, **프로그래밍 언어에서 '어떤 단어가 어떤 역할을 할지'를 정해주는 기준**이기도 해요.\
어휘 분석기는 이 정규표현식을 기준으로 소스코드를 스캔하며, 규칙을 벗어나는 경우엔 에러를 발생시킵니다.

> 📌 예를 들어, `2hello`는 변수명 규칙에 맞지 않기 때문에 에러!

#### ✅ 요약

| 개념    | 설명                                             |
| ----- | ---------------------------------------------- |
| 정규표현식 | 문자열 패턴을 정의하는 수학적 방법                            |
| 역할    | 어떤 문자열이 변수인지 정수인지 키워드인지 구분                     |
| 사용 이유 | 어휘 분석기의 핵심 기준. 규칙에 어긋나면 에러 발생                  |
| 예시    | `[0-9]+` → 정수 / `[a-zA-Z_][a-zA-Z0-9_]*` → 식별자 |

> **정규 표현식**은 수학적으로 정의된 기호와 연산을 이용하여 언어를 귀납적으로 정의하기 위한 방법입니다.&#x20;

정규 표현식에서 정의되는 연산은 접합, 클린 클로저, OR이 있으며, 피연산자는 기호의 유한 집합인 알파벳이나 기호가 됩니다.

말이 어렵게 되어있지만 그냥 우리가 아는 문자열 정규식이랑 동일해요. 정규식안에는 각 lexeme가 가져야하는 규칙이 들어가 있고 그 **규칙을 벗어나는 경우에는 에러를 발생시킵니다!**

## 🧠 파싱과 파스 트리: 문법적으로 해석하기

어휘 분석으로 토큰을 얻었으면, 이제 이 토큰들이 **문법적으로 맞는지 파악**해야 합니다. 이 과정을 \*\*파싱(parsing)\*\*이라고 합니다.

#### 파스 트리(Parse Tree)

토큰들의 구조를 **트리 형태**로 표현한 것

예: `1 + 2 * 3`

```
      +
     / \
    1   *
       / \
      2   3
```

이 트리를 구성하면 컴파일러나 인터프리터는 이 구조를 **실행하거나 최적화**할 수 있게 됩니다
