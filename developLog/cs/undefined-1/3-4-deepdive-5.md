---
description: 발표용이자 공유용
icon: books-medical
---

# 3장 - 4장 DeepDive 5개만 발표용

## 1. 정렬되지 않은 접근이 문제가 되는 이유

### 🏙️ 비유로 이해하는 메모리 정렬

#### 🏘️ 건물(포플렉스) = 메모리 블록

컴퓨터 메모리는 일정 크기의 **블록(= 건물)**&#xC73C;로 나뉘어 있어.\
예를 들어, 32비트 컴퓨터라면 하나의 건물(블록)은 **4바이트 = 32비트**로 되어 있고, 이게 <mark style="color:red;">하나의 워드</mark>라고 보면 돼!

즉,

* 주소 0 \~ 3번 바이트 → 0번 건물 (포플렉스 0)
* 주소 4 \~ 7번 바이트 → 1번 건물 (포플렉스 1)
* 주소 8 \~ 11번 바이트 → 2번 건물 (포플렉스 2)\
  이런 식으로 나뉘는 거죠.

#### 🚌 버스 = 데이터 버스

“도심을 오가는 버스”는 **CPU와 메모리 사이를 오가는 데이터 버스**를 말해

> 한 번 버스를 태우면 <mark style="color:red;">한 건물(포플렉스)에서 4바이트를 한꺼번에 실어올 수 있어</mark>\
> &#xNAN;**= 정렬이 맞을 때**의 이상적인 상황!

### 🧩 문제 상황: 정렬이 맞지 않을 때

이제, 어떤 프로그램이 **주소 5번부터 8번까지 4바이트**를 읽으려 한다고 해보자

> 주소 58은 1번 건물(47)과 2번 건물(8\~11)에 걸쳐 있어\
> 즉, **한 건물에서만 데이터를 읽을 수 없어.**

그래서 CPU는…

1. 1번 건물에서 5\~7번 바이트를 읽고
2. 2번 건물에서 8번 바이트를 다시 읽어서
3. 두 번을 나눠 읽고 조립해야 해.

### 🐢 왜 이게 문제일까?

* 메모리 접근이 **두 번** 일어나서 느려짐
* **CPU 내부에서도 조립** 과정이 필요 → 복잡함
* 일부 아키텍처는 이런 접근 자체를 **허용하지 않음**

그래서 요즘 대부분의 시스템은 다음과 같은 규칙을 따른다:

> **"4바이트 데이터를 읽을 땐 반드시 4의 배수 주소에서 시작해야 한다!"**

\= 즉, 주소가 **0, 4, 8, 12…** 여야 한다는 거\
이걸 `정렬(alignment)`이라고 부른다.



## 2. 클럭을 만들어주는 클리스털  발진기 는 어디에 있을까?

### 🧠 **즉, 발진자가 곧 클록이다!**

* `발진자(Oscillator)`는 **주기적으로 0과 1의 신호**를 만들어내는 장치야.\
  → 그 주기적인 전기 신호가 바로 `클록(Clock Signal)`이 되는 거고!
* 이 **클록 신호**는 컴퓨터 회로 전체에 **"지금 계산해!"**, **"기억해!"** 같은 **동기화 신호**를 계속 보내주는 역할을 하지.

### 🖥️ **그럼 발진자는 어디 있냐?**

* **CPU 안에도 클록 신호를 받는 회로가 있어.**
* 하지만 발진자(클록 자체)는 **보통 메인보드(메인 회로판)에 따로 탑재**돼 있어!

즉...

> ⛏️ **발진자**는 메인보드 위에 따로 있음 →\
> ⏱️ 그게 클록 신호를 만들어냄 →\
> 🧠 CPU와 다른 부품들이 그 클록 신호에 맞춰 동작함

#### 예를 들어

1. 너의 컴퓨터 메인보드에는 작은 **크리스털 발진자**가 있어. (보통 금속 캔 모양이야 ⛓️)
2. 이게 **1초에 수억\~수십억 번** 전기적 신호를 깜빡깜빡 만들어내.
3. 이 신호를 CPU가 받아서 **정해진 타이밍대로 동작**하는 거지!

### 🔍 덧붙여서…

* 요즘 고급 CPU는 내부적으로도 복수의 **클록 도메인(clock domain)**&#xC744; 가져.
  * 예: **연산 부**, **캐시 메모리**, **버스** 등이 서로 다른 속도로 움직이기도 해!
* 이런 구조 덕분에 CPU는 복잡한 연산을 더 효율적으로 처리할 수 있어.

요약하자면:

> ✅ **발진자 = 클록 신호 생성기**\
> ✅ **클록 = CPU의 박자**\
> ✅ **발진자는 메인보드에 있지만, CPU는 그 신호에 맞춰 움직인다!**

## 3. “일반적인 논리 회로 설계 오류는 **최댓값이나 최솟값을 사용하지 않고 전형적인 값**을 사용하기 때문에 생긴다.”

### 🤔 무슨 상황일까?

컴퓨터 회로나 CPU 같은 `디지털 회로`는 **전기가 얼마나 빨리 흐르느냐(=전파 지연 시간)**&#xC5D0; 따라 동작 속도가 달라져.\
근데 이 전파 지연 시간은 항상 **딱 고정**된 값이 아니야!

왜냐하면:

* 만드는 공정에서의 미세한 차이,
* 온도 변화,
* 전압 차이 등등에 따라\
  **느려지기도** 하고 **빨라지기도** 하거든.

그래서 제조사는 보통 이렇게 말해:

* **최솟값**: “이 정도면 가장 빨리 반응해요!”
* **전형값**: “보통은 이 정도 속도예요\~”
* **최댓값**: “이 이상 느려지는 경우도 있으니 대비하세요!”

### ❗ 그런데 문제는 뭐냐면…

논리 회로를 설계할 때 **“보통 이 정도니까 괜찮겠지\~”** 하고\
`전형적인 값(typical value)`만 가지고 회로를 짜는 사람이 많다는 거야.

그런데 만약, 현실에서는 그 회로에 **최댓값** 수준의 지연이 생긴다면?

* 회로는 **예정보다 더 느리게 반응**하게 되고,
* 다음 단계가 그걸 **기다리지 않고 실행**해버리면
* **오류 발생!** ❌

#### 💥 예시로 정리해보자

```plaintext
A라는 회로가 2ns 안에 출력을 내야 한다고 가정해볼게.
근데 전형적인 회로는 보통 1.5ns 안에 끝나.
그래서 “1.5ns면 되겠지~” 하고 설계를 함.

하지만 어떤 환경에서는 그 회로가 2.2ns 걸릴 수도 있어.
그럼 문제 생기겠지? → 지연이 생겨서 오작동.
```

### 🔍 그래서 안전하게 설계하려면?

* **최악의 경우(Worst case)**&#xB97C; 생각해서
* **가장 늦게 반응할 수 있는 시간(최댓값)**&#xC744; 기준으로 설계해야 해!

이렇게 해야 예상치 못한 환경에서도 **안정적으로 동작**하는 회로가 되는 거야.\
그래서 ‘전형값만 보고 회로를 짜면 오류 생긴다’는 거지!

### 🧠 요약하면?

| 항목        | 설명                                       |
| --------- | ---------------------------------------- |
| **전형값**   | 평균적인 상황에서의 반응 속도                         |
| **최댓값**   | 가장 느리게 반응할 수 있는 상황                       |
| **설계 오류** | 전형값만 고려하면, 실제 사용 중 최악의 상황에서 회로가 망가질 수 있음 |
| **해결책**   | 항상 \*\*=최악의 시나리오(최댓값)\*\*를 고려해서 설계해야 안전함 |



## 4. 인버터와 OR 게이트 래치의 차이

### **🔄 인버터(=NOT 게이트)는?**

* 입력이 `0`이면 출력이 `1`
* 입력이 `1`이면 출력이 `0` → 즉, **무조건 반대로 바꿔주는 게이트**야.

이걸 되먹임(feedback)으로 자기 자신한테 연결하면 어떻게 돼?

* 처음에 `0` 넣으면 → 출력이 `1`
* 근데 그게 다시 입력으로 들어가니까 → `1` → 출력은 `0`
* 다시 `0` → `1` → `0` … 무한 반복!

그래서 **계속 0 → 1 → 0 → 1 … 진동이 생겨!** → 이걸 `발진기(oscillator)`로 쓰는 거야.

### 🧩 그런데 OR 게이트는?

#### OR 게이트는?

* 입력 중 **하나라도 1이면 출력이 1**
* **둘 다 0일 때만 출력이 0**

예를 들어, OR 게이트에 이런 피드백을 걸면?

**회로 구조:**

* 입력: `in`, `feedback`
* 출력: `out`
* `out` → 다시 OR 게이트 입력으로 들어감 (되먹임)

### 🔍 예시로 따라가보자!

#### 초기 상태:

* `in = 0`, `feedback = 0`
* → OR 게이트 출력 `out = 0`

#### 그다음, in을 1로 바꿔!

* `in = 1`, `feedback = 0`
* → OR(1, 0) = 1 → `out = 1`

이제 출력이 1이 됐지? 그럼 되먹임 입력도 1이 돼!\
→ **`feedback = 1`**

#### 이제 다시 in을 0으로 바꿔볼까?

* `in = 0`, `feedback = 1`
* → OR(0, 1) = 1 → 여전히 `out = 1`

와! `in`은 0으로 바뀌었는데도 **출력은 계속 1로 유지돼!**

### 🎯 핵심 차이: **인버터는 반전**, OR은 **고정화**

| 회로         | 특징                              | 결과          |
| ---------- | ------------------------------- | ----------- |
| 인버터 피드백    | 계속 반전해서 입력/출력이 교차 → **진동 발생**   | 발진기 역할      |
| OR 게이트 피드백 | 한 번 1이 되면 계속 1 유지 → **안정적인 기억** | 래치 역할 (메모리) |

### 💡 인버터는 ‘동그라미’가 핵심

맞아, 네가 말한 대로 **인버터에는 동그라미(⊙)** 가 붙어 있는데\
그건 “출력을 **반대로** 바꿔라”는 의미야.\
그래서 반전 → 반전 → 반전 반복 = **진동**이 가능해.

그에 반해 OR 게이트는 동그라미가 없으니까,\
**출력을 반전하지 않아.** 그냥 "둘 중 하나라도 1이면 무조건 1!"이야.



**✨ 그래서 정리하면!**

* 인버터는 **입력 값을 반전시키기 때문에**, 피드백이 들어오면 계속 바뀌고 → **진동!**
* OR 게이트는 **반전 없이 값만 유지**하기 때문에 → 한 번 1 되면 계속 1 → **기억 회로!**
* 그래서 OR 게이트 래치는 **진동하지 않고**, 대신 **1비트 기억하는 회로**로 사용돼!



## 5. 디스크, 메모리, CPU 중 100% 넘을 수 없는 것? 넘으면 어떻게 되는가?

### 💻 CPU: **100% 넘는 것처럼 보일 수 있다 (멀티코어 때문)**

#### 1) CPU 사용률은 어떻게 계산될까?

* 단일 코어가 100% 사용되면 → `1코어 = 100%`
* 멀티코어 시스템에서는 **전체 CPU % = (코어 수 × 100%)**\
  예) 4코어면 전체 400% 가능\
  → `htop`에서는 프로세스 CPU%가 400%까지도 가능함

#### 2) CPU 100%면 무슨 일이 일어날까?

* 컨텍스트 스위칭 발생!\
  → 다른 프로세스가 CPU를 사용하기 위해 **현재 프로세스를 잠시 멈추고** 다른 걸 실행
* **선점형 스케줄러**가 CPU 점유를 강제로 나눔\
  → `타임 슬라이스` 단위로 번갈아 실행

✅ 그래서 CPU가 100%라도 "동작이 멈추는" 건 아니고, **속도가 느려질 뿐** 동작은 계속함

### 💾 디스크 I/O: **100%가 넘는다기보단 병목이 생김**

* 디스크는 병렬 연산이 제한적이기 때문에 `100% 사용`이라는 개념이 좀 달라
* **I/O wait** 비율이 높아지면 → CPU가 디스크 작업 끝날 때까지 "놀고" 있게 됨

### 📌 확인 방법:

```bash
$ iostat -x 1
```

→ `%util`이 100% 가까우면 **디스크 I/O가 병목 중**

또는 `htop`의 CPU 막대 중 \*\*회색(아이오 대기 시간)\*\*이 많으면 디스크 병목 상태

### 🧠 메모리: **100% 넘으면? → 스왑(SWAP) 사용 → 시스템 느려짐**

1\) 메모리가 다 차면?

* 커널은 **디스크의 일부 공간을 SWAP으로 사용**함 (가상 메모리)
* 디스크에 저장해두고, 다시 쓸 때 RAM으로 불러옴 (매우 느림!)

2\) SWAP도 다 차면?

* OOM(Out of Memory) Killer가 동작 → 커널이 메모리를 많이 먹는 프로세스를 **강제로 종료시킴**

3\) 확인 방법:

```bash
$ free -m
```

* RAM과 SWAP 사용량 확인 가능

#### 정리 ✨

| 자원  | 100%일 때 현상    | 넘어가면?         | 컨텍스트 스위칭     |
| --- | ------------- | ------------- | ------------ |
| CPU | 논리 코어 기준 100% | 가능 (멀티코어 합산)  | O (스케줄러가 분배) |
| 디스크 | I/O 대기로 느려짐   | 병목 생김         | CPU가 대기함     |
| 메모리 | SWAP 사용 시작    | OOM으로 프로세스 죽음 | X (메모리는 점유됨) |

### 💬 그래서 "100% 넘을 수 있나요?" 요약하면:

* **CPU는 논리코어 기준이기 때문에 "100% 넘는 값도 있음"**
* **디스크는 100% 넘는다기보다 병목 현상이 생김**
* **메모리는 넘으면 스왑 → OOM → 죽음의 사이클**\


