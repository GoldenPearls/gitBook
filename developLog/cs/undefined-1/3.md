---
description: 컴퓨터는 비트를 어떻게 기억하는가
icon: '3'
---

# 3장 : 메모리와 디스크의 핵심:  순차 논리

## 1. 개요

### 1) 조합 논리의 한계: 지금 입력만 본다?

앞에서 배운 **조합 논리 회로**는 어떤 특징이 있었는지 기억나?

> 👉 **입력 값이 바뀌면 즉시 출력도 바뀌는 회로**였지!

예를 들어,\
&#xNAN;**“0 + 1”을 입력하면 즉시 1이 출력**되고,\
&#xNAN;**“1 + 1”을 입력하면 즉시 0과 자리올림 1이 나오는 식**이었어.

그런데 여기엔 중요한 문제가 있어.

> <mark style="color:red;">**‘기억’이 없다!**</mark>

지금 입력만 보고 판단하니까,\
&#xNAN;**“그 전엔 무슨 일이 있었는지”** 전혀 모르는 거야.

이런 상태에서는 컴퓨터가\
“지금까지 숫자를 얼마나 더했는지” 같은 걸 절대 기억할 수 없다!! 두둥

그래서 등장한 게 순차 논리 회로야!

### 2) 순차 논리의 등장! 기억력을 갖춘 회로

순차 논리는 이름부터 \*\*sequence (순서)\*\*에서 왔어.\
즉, **시간의 흐름을 다루는 논리**야.

> 조합 논리 = 입력 ➜ 즉시 출력\
> `순차 논리` = 입력 + 과거 상태 ➜ 현재 출력

예를 들어, 우리가 1부터 100까지 더할 때 **지금까지의 합계**를 계속 기억해둬야 하지?\
그걸 가능하게 해주는 게 바로 순차 논리야.

{% hint style="warning" %}
즉,\
🧠 **기억이 있는 회로**\
🕒 **시간의 흐름을 반영하는 회로**
{% endhint %}

그게 순차 논리 회로야!

### 3) 디지털 회로엔 ‘시간’이 없다?

그런데 여기서 재밌는 게 하나 있어.

우리는 시간을 너무 당연하게 느끼지만,\
디지털 회로 자체엔 시간이 없어.\
<mark style="color:red;">전기 흐름은 순간이잖아.</mark>

그래서 우리는 **회로 안에서 ‘시간’을 인위적으로 만들어줘야 해.**

어떻게? 바로 `클럭(clock)`이라는 회로를 통해서!

#### 💡 한줄 요약

> 조합 논리는 “지금 입력”만 보고 판단하는 회로\
> 순차 논리는 “과거의 상태 + 지금 입력”을 함께 고려해서 판단하는 회로

컴퓨터가 **상태를 기억하고, 명령의 흐름을 제어하고, 복잡한 연산을 이어서 수행**할 수 있는 건\
전부 이 순차 논리 덕분이야!



## 2. 시간 표현과 상태 기억

### ⏱️ 컴퓨터는 어떻게 시간을 알까?

#### 1) 시간이라는 건 ‘흐름’이 필요해!

앞에서 조합 논리는 **입력에 따라 즉시 출력이 결정되는 구조**라고 했지?\
근데 컴퓨터가 무언가를 기억하거나, \*시간이 지나면서 상태를 바꿔야 할 때”는 얘기가 달라져.

예를 들어

* 알람이 울릴 시간이 됐는지 알려줘야 하고
* 애니메이션을 1초에 몇 프레임씩 보여줄지 정해야 하고
* 입력이 들어온 시점에 따라 이벤트를 다르게 처리해야 할 때!

이럴 땐 단순한 ‘지금 상태만 보는 회로’로는 안 돼.\
`시간`이라는 개념이 필요해지는 거야!

#### 2) 시간은 어떻게 정의할 수 있을까?

시간이란 건 사실 되게 **추상적**이지.\
우리도 눈에 보이는 건 아니잖아?

근데 인간은 오래전부터 **시간을 ‘반복되는 무언가’로 측정**해왔어.

예를 들어 볼까?

* 🌍 **지구가 한 바퀴 도는 걸 하루(24시간)**&#xB77C;고 부르고
* 🕰️ 하루를 60분씩, 60초씩 잘게 나눠서 **1초 = 하루의 1/86,400**이라고 정의했어!

이처럼 시간은 **주기적으로 반복되는 사건**을 기준으로 측정할 수 있어.\
이걸 우리는 "주기 함수(Periodic Function)"라고 불러!

#### 3) 고전 방식: 진자 시계

좀 더 감성적인 예시도 있어.\
바로 **진자 시계**! (틱톡-틱톡 하는 괘종시계 알지?)

* 진자가 왔다 갔다 하는 **주기적인 움직임**을 이용해서
* “1초당 몇 번 움직이는지”를 세서 시간을 측정했어.

{% hint style="danger" %}
근데 문제는…

> 진자 시계는 **느려!**\
> 컴퓨터처럼 **초당 수십억 번 연산**하는 데엔 전혀 안 맞아. 😅
{% endhint %}

게다가 중력, 마찰, 바람, 진동… 너무 민감해서 **정확도도 떨어져.**

#### 4) 그럼 컴퓨터는 어떻게 시간을 측정할까?

컴퓨터는 전기로 작동하니까, **전기적 방식으로 주기적인 움직임**을 만들어내야 해.

즉,

> 전자적으로 "틱톡틱톡" 신호를 만드는 장치 = `클럭(Clock)`!

이 클럭 회로는 일정한 주기로 **전압을 0 ➜ 1 ➜ 0 ➜ 1** 이렇게 반복해.\
이게 마치 **“전자 진자”**&#xCC98;럼 시간의 흐름을 표현해주는 거야.

그리고 이 클럭 신호에 맞춰서 컴퓨터 내부 회로가\
“이제 연산 시작!”, “이제 저장!”, “이제 전송!” 이런 식으로 행동을 결정하지.

#### 💡 정리하자면…

* 시간은 **반복되는 무언가**를 기준으로 정의된다.
* 예전엔 지구 자전이나 진자처럼 물리적인 방식으로 시간을 쟀지만,
* 컴퓨터는 `주기적인 전기 신호(클럭)`를 만들어서 시간을 관리한다.

> 이 클럭이 **순차 논리 회로의 ‘심장박동’** 같은 역할을 하면서,\
> 컴퓨터 내부 모든 동작을 동기화시켜주는 거야! ⚡️

### 1️⃣ 발진자

**컴퓨터는 어떻게 '시간'을 만들어낼까?**

#### 1) 인버터를 활용한 시간 만들기 🌀

자, 이제 본격적으로 **컴퓨터가 시간의 흐름을 어떻게 구현하는지** 알아보자.

먼저, 가장 간단한 방식은 `인버터(Inverter)`를 사용하는 트릭이야.

> 인버터란?\
> 입력이 1이면 출력이 0, 입력이 0이면 출력이 1이 되는 **NOT 게이트**!

이 인버터의 **출력을 다시 자기 자신의 입력에 연결**하면 어떤 일이 생길까?

* 출력이 1이 되면, 그게 입력으로 다시 들어가니까 0이 되고
* 그 0이 다시 출력으로 되돌아와서 1이 되고...
* 무한 반복!!

즉, **출력이 0과 1 사이에서 계속 진동하게 돼.**\
이걸 `발진(oscillation)`이라고 하고, 이런 회로를 `발진자(oscillator)`라고 불러.

<figure><img src="../../.gitbook/assets/image (231).png" alt=""><figcaption></figcaption></figure>

> 💡 이건 마치 마이크를 스피커에 너무 가까이 뒀을 때 **삐— 하는 피드백음**이 생기는 거랑 비슷해. `되먹임` 이라고도 해

그림을 보면 인버터의 **출력을 입력**에 연결할 수 있는데 이런식의 연결을 바로 `되먹임`이야.

#### 2) 왜 이렇게 진동시키는 게 중요할까? ⏲️

이 진동하는 신호는 일정한 **"주기적인 신호"**, 즉 **클럭(Clock)**&#xC73C;로 사용돼.\
컴퓨터는 이 신호에 맞춰서 "지금 연산해!", "지금 저장해!" 같은 동작을 동기화시키는 거야.

그런데 문제는…

> 이 인버터 기반 발진자는 **속도가 온도나 전파 지연에 따라 달라질 수 있어.**\
> 그러니까, 안정성도 정확성도 조금 떨어지는 거지.

그래서 나온 해결책이 바로…

<figure><img src="../../.gitbook/assets/image (233).png" alt=""><figcaption></figcaption></figure>

#### 3) 진짜 정확한 '시간'을 만드는 비밀 무기: 크리스털! 🔮

<figure><img src="../../.gitbook/assets/image (232).png" alt=""><figcaption></figcaption></figure>

{% hint style="success" %}
이제 진짜 멋진 과학이 등장해.\
바로 **크리스털 발진자(Crystal Oscillator)**!
{% endhint %}

📌 여기서 말하는 크리스털은 그냥 반짝이는 장식용이 아니야.

> **석영(Quartz)** 같은 특정 고체 물질을 말해. 이 물질엔 신기한 능력이 있어!

**💡 피에조 전기 효과 (Piezoelectric Effect) or 압전 효과**

* 전극을 크리스털(결정이라는 뜻)에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어냄
* 크리스털에 전기를 가하면 → 크리스털이 **미세하게 구부러져!**
  * 크리스털은 음성 진동을 잡아낼 수 있어 → 마이크를 만들 때 이를 쓸 수 있어!
  * 또한 크리스털에 전기를 가해 음성 진동을 만들어냄으로써 여러 전기 기구에서 다양한 경보음을 낼 수 있음
* 반대로, 크리스털을 누르면 → **전기를 만들어내!**

#### 4) 크리스털 발진자의 작동 원리 ⚙️

자, 이제 이걸 컴퓨터에 어떻게 쓰는지 보자.

1. 크리스털에 전기를 가하면 **구부러지면서 진동**함.
2. 이 진동을 **회로로 받아서 다시 전기로 바꿔냄**.
3. 이 과정을 반복하면?\
   → **정확한 주기**로 전기 신호가 나오는 거야!

즉, <mark style="color:red;">**정확한 '틱톡틱톡'을 전기적으로 만들어주는 장치**</mark>지.

#### 5) 왜 석영(Quartz)을 쓸까?

* 석영은 **온도 변화에 강하고**,
* **진동 주기**가 **매우 정확하게 일정**해서,
* **시계, 컴퓨터, 전자기기**의 클럭에 많이 쓰여.

그래서 예전 전자시계 광고에 보면

> "정확한 석영 시계"\
> 이런 말 많이 들어봤을 거야. 그게 바로 이 원리야!

#### 📌 요약하자면…

* 인버터로도 진동하는 신호는 만들 수 있지만, **정확도가 떨어져.**
* 그래서 나온 게 **크리스털 발진자**, 특히 석영 같은 정밀한 재료!
* 크리스털은 전기를 주면 진동하고, 진동으로 전기를 만들고…\
  이걸 통해 컴퓨터는 정확하고 일정한 **클럭 신호**를 만들어서\
  **모든 연산과 저장 타이밍을 조절**하는 거야!

### 2️⃣ 클록

**⏱️ 컴퓨터 속 '시간' — 단순한 시계가 아니다!**

#### 1) 클록(Clock)이란 무엇일까?

우리가 **2장에서 논리 회로**와 **전파 지연**을 배웠잖아?\
그 회로들이 안정적으로 작동하려면 <mark style="color:red;">"타이밍"이 정말 중요해.</mark>

> 그걸 도와주는 게 바로 `클록(Clock)`이라는 존재야.

말 그대로 컴퓨터 내부에서 **“지금 계산해!”, “기억해!”, “이제 결과 내!”** 같은 신호를 주기적으로 보내주는 **심장박동 같은 역할**을 해.

클록은 밴드에서 <mark style="color:blue;">드러머가 일정한 박자(템포)를 맞춰주는 것과 똑같아!</mark>

#### 2) 왜 클록이 필요할까?

{% hint style="warning" %}
컴퓨터는 **모든 계산이 논리 회로에서 전기 신호로 움직이는 과정**이야.
{% endhint %}

그런데 이게 아무리 빠르다고 해도, **0.000000001초의 지연**도 생겨.\
이걸 `전파 지연(Propagation Delay)`이라고 부르지.

이 지연이 문제를 일으키지 않게 하려면,\
<mark style="color:orange;">"모든 계산이 끝났을 법한 타이밍</mark>"까지 **기다렸다가 다음 단계로 넘어가야 해.**

> 그러려면 <mark style="color:red;">시간을 셀 수 있는 기준</mark>이 필요하잖아?

그 기준이 바로 `클록 신호(Clock Signal)`인 거야! 🕐

#### 3) 발진자가 클록을 만든다!

앞에서 배운 것처럼, 컴퓨터는 내부에 `발진자(Oscillator)`를 가지고 있어.\
대표적으로 **크리스털 발진자**!

{% hint style="success" %}
이 발진자가 일정한 주기로 **0과 1을 오가는 전기 신호**를 만들어내고, 이걸 `클록`으로 사용해
{% endhint %}

즉, **"틱톡틱톡"** 전기적 박자가 되는 거지!

> 이 박자에 맞춰 **CPU는 연산, 저장, 출력 등 모든 작업을 동기화**해.

#### 4) 회로 속도 = 클록 속도?

**그럼 클록은 무조건 빠를수록 좋은 걸까?**

음… 아니야! 🙅

<mark style="color:blue;">회로마다</mark> <mark style="color:blue;"></mark><mark style="color:blue;">**처리 속도에 한계**</mark><mark style="color:blue;">가 있거든.</mark>

> 예를 들어, 가산기 같은 회로는 **입력이 들어오고 출력이 안정되기까지 약간의 시간**이 필요해.

{% hint style="danger" %}
클록이 너무 빨라지면?\
→ **아직 계산이 끝나지도 않았는데 다음 연산을 하라고 지시하는 꼴이 돼.**\
→ 그러면 **에러나 잘못된 결과**가 나올 수도 있지!
{% endhint %}

그래서 <mark style="color:red;">"최악의 경우를 감안한 지연 시간"을 기준으로, 클록 속도를 정해야 해.</mark>

**🤔 컴퓨터 제작에 필요한 통계❓**

> * 컴퓨터 컴포넌트 제작에는 여러 가지 통계가 필요함\
>   👉 컴포넌트를 이루는 부품들 사이에 편차가 크기 때문

#### 5) '클록 속도'는 어떻게 정해질까?

자, 이제 중요한 건 **부품마다 성능이 다르다는 점**이야.\
어떤 트랜지스터는 빠르고, 어떤 건 느릴 수 있어.

그래서 부품을 공장에서 만들고 나면, <mark style="color:red;">각각의 성능을</mark> <mark style="color:red;"></mark><mark style="color:red;">**테스트해서 등급별로 나누는 작업**</mark><mark style="color:red;">을 해. = 비닝</mark>



🧪 **비닝(Binning)이란?**

**비닝**은 반도체나 전자 부품을 생산한 다음,\
각 부품이 **얼마나 성능이 좋은지**에 따라 **분류하는 작업**을 말해.



**📦 예를 들어 CPU에서 비닝을 하면?**

CPU는 공장에서 생산하면 성능이 다 **완전히 똑같지 않아**.

> 왜냐하면 **생산 공정에서 아주 미세한 차이**가 생기기 때문이야.

그래서 공장에서 이렇게 테스트하지:

1. “이 CPU는 3.5GHz에서도 안정적으로 잘 돌아가네? → **고성능 빈**에 넣자.”
2. “이건 3.0GHz까지만 안정적이네… → **중간 성능 빈**으로.”
3. “이건 2.5GHz 정도가 한계야… → **저성능 빈**으로 넣자.”

**🧠 그럼 왜 비닝을 하냐면?**

* **성능별 제품을 다양하게 팔 수 있어** (고급형/보급형)
* **불량은 줄이고, 수율은 높일 수 있어**
* 같은 설계를 썼지만 성능차를 이용해서 **가격을 다르게 설정**할 수 있음



그래서 우리가 같은 모델 CPU를 사도, 어떤 건 **클록 속도를 더 높게 설정해도 안정적으로 돌아가고**,\
어떤 건 **조금만 속도를 올려도 불안정해져서 에러가 날 수 있어.**

#### 6) 오버클로킹이란?

혹시 `오버클로킹(Overclocking)`이라는 말 들어봤어?

이건 말 그대로 **제조사가 보장한 클록 속도보다 더 빠르게 CPU를 돌리는 것**이야.

> 성능이 올라가서 게임이나 영상 편집에 더 좋은 성능을 낼 수 있지만…\
> 대신 **발열이 심해지고, 고장 위험도 높아져!** 🔥

왜냐하면, 그 CPU가 **비닝에서 중간쯤 위치했던 부품**일 수 있어서\
**진짜 한계가 어디인지 알 수 없기 때문이야.** (일종의 도박인 셈이지!)

#### 📌 요약하자면?

* 컴퓨터는 **발진자 → 클록 → 회로 동기화**로 시간을 컨트롤한다!
* 클록은 컴퓨터의 **심장박동**, 모든 동작을 리듬에 맞게 조율해 줘.
* 클록 속도는 회로의 **전파 지연 시간**보다 빨라지면 안 돼!
* 부품마다 다르기 때문에, `비닝(Binning)`으로 등급 나눔.
* 오버클로킹은 속도 향상이 가능하지만, **위험 부담도 있음.**

> 일반적인 논리 회로 설계 오류는 최댓값이나 최솟값을 사용하지 않고 전형적인 값을 사용하기 때문에 생겨

### 3️⃣ 기억 장치의 출발점: 래치(Latch)

⏳ **컴퓨터는 어떻게 '기억'을 할까?**

우리가 “기억하는 회로”를 만들기 위해 어떤 식으로 발전해왔는지, **OR 게이트 래치 → AND-OR 래치 → S-R 래치** 순서

#### 🧩 1) ‘기억’이 필요해! 순차 논리의 등장

앞에서 우리가 조합 논리를 배웠잖아?\
그런데 조합 논리는 딱 하나만 알아 — **현재의 입력 → 현재의 출력**\
즉, “과거에 뭐였는지?”는 전혀 기억 못 해.

> “1부터 100까지 더하라”고 하면?\
> 내가 지금 어디까지 더했는지를 기억 못 하면 안 되겠지?

그래서 등장한 게 **순차 논리**야!\
순차 논리는 `현재 입력 + 과거 상태(메모리)`까지 고려해서 출력을 결정해!\
그리고 이걸 구현하려면 컴퓨터가 **시간의 흐름을 알 수 있어야 해.**

#### 🔁 2) 시간을 만드는 회로: 발진자 & 클록

**🌀 인버터 되먹임 회로 (기초 발진자)**

* 인버터 출력 → 다시 자기 입력으로 연결!
* 계속 0 → 1 → 0 → 1 반복 → **진동 발생!**

> 마치 마이크랑 스피커를 가까이 두면 “삐-” 하고 울리는 것처럼 피드백 현상이 생기는 거야!

📌 이걸 `발진자(oscillator)`라고 해.\
출력 신호가 일정하게 반복되니까 **시간의 기준**으로 쓸 수 있어.

**🧭 좀 더 정확한 시간? → 크리스털 발진자!**

* 인버터 발진자는 온도, 전기적 조건에 따라 흔들릴 수 있어.
* 그래서 쓰는 게 **크리스털(석영) 발진자!**
* **압전 효과**를 이용해 **매우 일정한 주기로 진동**해줘.
* 컴퓨터 안에서 이 발진자가 **클록(clock) 신호**를 생성함.

> 이 클록이 “하나, 둘, 셋!” 하고 컴퓨터 회로가 동기화돼서 움직이도록 도와주는 리듬감인 거야! 🥁

#### 💾 3) 기억 장치의 출발점: 래치(Latch)

이제 시간을 표현할 수 있게 되었으니, "정보를 기억하는 회로”를 만들 차례야.



**📍 OR 게이트 래치 (OR Latch)**

<figure><img src="../../.gitbook/assets/image (238).png" alt=""><figcaption></figcaption></figure>

**구조**

* OR 게이트 출력 → 다시 입력으로 연결하는 **되먹임(Feedback)** 구조
  * OR 게이트의 출력을 입력에 묶는 방식의 `되먹임`을 사용하면 정보를 기억할 수 있음
* 이 회로는 **값을 반전시키지 않기 때문에** 발진자에서 본 회로와 달리 <mark style="color:red;">진동을 만들어내지는 않아.</mark>

**동작 방식**

* `in = 1`이면 출력도 1이 되고, 이 출력이 다시 입력으로 들어가면서 **출력이 계속 1로 유지돼**
* 그 후에 `in = 0`이 되어도 **출력은 바뀌지 않아**\
  → 즉, 상태를 “기억”하는 구조!
* OR 게이트 회로 out이 0부터 시작한다고 가정함
  * &#x20;in이 1이 되면 out도 1이 됨
  * &#x20;**출력**이 게이트의 (in이 아닌 다른 쪽) 입력에 연결되어 있기 때문에 이제부터는 out이 1로 유지됨
  * &#x20;in이 0이 돼도 출력은 그대로 1로 유지됨
  * 결론: 이 회로는 자신의 과거 상태를 기억한다

<mark style="color:red;">📌 문제점: 한 번 1이 되면</mark> <mark style="color:red;"></mark><mark style="color:red;">**다시 0으로 만들 방법이 없음!**</mark>



**📍 AND-OR 게이트 래치 (AND-OR Latch)**

<figure><img src="../../.gitbook/assets/image (239).png" alt=""><figcaption></figcaption></figure>

이제 OR 래치에 `초기화 기능(reset)`을 추가해보자!

#### ⚙️ 주요 요소 정리

* **reset‾**: 이름에 "바"가 붙은 건, **0일 때 작동(Active Low)** 한다는 뜻이야.
* **reset = NOT(reset‾)**: 이건 인버터를 거친 값이야. 즉, reset‾이 0이면 reset은 1이 돼.
* **AND 게이트**: 두 입력이 모두 1일 때만 출력이 1이야.
* **OR 게이트**: 하나라도 1이면 출력이 1이야.
* **feedback**: 이전 출력(out)을 AND 게이트에 되돌려주는 입력이야.

**구조**

* AND와 OR 게이트로 구성
* **Set 입력**과 **Reset 입력**이 따로 존재
* 인버터가 연결되어 있는 Reset 입력이 핵심!

```
            ┌────────┐
      set ─►│        │
            │  AND   ├──┐
feedback ─►│        │  │
            └────────┘  ▼
                       ┌────────┐
       reset‾ ─────────│        │
                       │  OR    ├───► out
                       └────────┘
```

**동작 방식**

```
set ─► AND ─┐
            │       ┌───────┐
feedback ───┘       │       │
            └─────► OR ────► out
                    ▲
              reset‾ (0이면 리셋)
```

* Set 신호가 1이면 → 출력은 1로 세팅됨
* <mark style="color:red;">Reset 신호가 1이면 → 인버터 통해 0으로 강제로 초기화됨</mark>

**⛓️ 어떻게 동작하냐면?**

**1) 기본 상태 – 기억 유지**

* `reset‾ = 1` (즉, reset 기능은 꺼짐)
* OR 게이트는:
  * "set"에서 오는 AND 게이트 출력
  * 이전 출력값(feedback)

→ 즉, 예전 값이 유지돼! (= 래치처럼 작동)

**2) reset 작동시킴!**

* `reset‾ = 0` (이제 reset을 하겠다는 의미!)
* 이 값은 OR 게이트의 입력으로 들어가고,
* OR 게이트는 **0 + feedback = feedback** 이니까 변화 없어 보이지만…

> <mark style="color:red;">이 신호는</mark> <mark style="color:red;"></mark><mark style="color:red;">**강제로 OR 게이트 출력을 0으로 만들고**</mark><mark style="color:red;">,</mark>\ <mark style="color:red;">되먹임을 끊어버리는 역할을 해.</mark>

➡ 결국 **출력이 0으로 리셋되면서 '기억'을 초기화**하는 거야!





**"reset 바"는 뭐야?**

* `reset` 위에 선이 그어져 있으면 **"reset 바(reset‾)"** 라고 읽어.
* 이건 **Active Low 신호**를 뜻하는데,&#x20;
  * #### "0"일 때 작동하는 신호란 뜻이야!
  * 보통은 1이 들어오면 "작동해!" 이런 느낌인데,  Active Low 신호는 **"0이 들어오면 작동해!"** 라고 되어 있어.
  * 예를 들어, `reset‾ = 0` 이면 "reset 기능을 실행해!"\
    반대로 `reset‾ = 1` 이면 "아무것도 하지 마!" 라는 뜻이야

> Reset이 1일 때 아무것도 안 했던 " 왜냐하면 이 회로는 **액티브 로우** 방식이라서...
>
> * **Reset이 0일 때**만 리셋 동작이 발생해! → Q가 0으로 초기화됨
> * **Reset이 1일 때**는 → “지금은 리셋 안 해\~” 하고 넘어가는 거야



**✨ 한 줄 요약!**

* **reset 바**는 **0일 때 작동하는 "반전 신호"**
* **AND-OR 래치**는 기본적으로 OR 되먹임 구조인데,
* reset 바가 0이 되면 **되먹임이 깨지고 out이 0으로 리셋됨!**



> 💡 이 회로는 간단하지만, 아직은 **비대칭적**이야. <mark style="color:red;">Set과 Reset 신호 처리 속도가 다를 수 있음.</mark>



#### 📍 S-R 래치 (Set-Reset Latch)

<figure><img src="../../.gitbook/assets/images_yun2021_post_61bfe0fd-8171-4b8d-8d4d-931fe21d81e3_s-r 래치.gif" alt=""><figcaption></figcaption></figure>

이제 **대칭적이고 안정적인 래치 회로**로 발전시켜 보자!

**구조**

* **NAND 게이트 2개**로 구성된 래치
* 입력: **Set(S)**, **Reset(R)**
* 출력: **Q**, 그리고 **보수 출력 Q̅** (즉, Q가 1이면 Q̅는 0)

**진리표**

| S | R | Q (출력) | 의미          |
| - | - | ------ | ----------- |
| 0 | 1 | 1      | Set (설정)    |
| 1 | 0 | 0      | Reset (초기화) |
| 1 | 1 | 유지     | 이전 상태 유지    |
| 0 | 0 | ❌ 불안정  | 사용 금지!      |

> **S = 0, R = 0**은 “동시에 설정도 하고 리셋도 해라”는 거라서 회로가 헷갈려. 절대 쓰면 안 돼!

**장점**

* **대칭적 설계**로 속도 편차 적음
* AND-OR 래치보다 **더 안정적**
* 실제 **메모리 셀 구조의 기본 단위**로 많이 사용됨!
* 회로가 대  칭이기 때문에 set과 reset 신호의 지연 시간이 거의 비슷하다는 뜻이다.

**🖼 회로 이미지 모음**

| 회로 이름     | 이미지                                                                           | 설명                      |
| --------- | ----------------------------------------------------------------------------- | ----------------------- |
| OR 래치     | <img src="../../.gitbook/assets/image (234).png" alt="" data-size="original"> | 기본 되먹임 구조로 상태 유지        |
| AND-OR 래치 | <img src="../../.gitbook/assets/image (235).png" alt="" data-size="original"> | Set/Reset 신호가 따로 있는 개선형 |
| S-R 래치    | <img src="../../.gitbook/assets/image (236).png" alt="" data-size="original"> | 실용적인 대칭 구조, NAND 기반     |

**🔚 정리 한마디!**

* **조합 논리만으로는 기억이 안 돼!**
* 그래서 순차 논리를 도입해서 시간 흐름과 상태 기억 가능!
* 시간을 표현하는 회로는 **발진자** (→ 클록 신호 생성)
* 기억을 만드는 회로는 **래치(Latch)** — OR → AND-OR → S-R 순서로 발전!
* **S-R 래치는 1비트를 기억하는 가장 기초적인 메모리 구조**



### 4️⃣ **게이트가 있는 래치 – 기억을 "언제" 할 것인가?**

#### 🔁 먼저 복습! S-R 래치가 뭐였더라?

* S-R 래치는 **1비트를 기억하는 아주 기본적인 회로**야.
* 입력에 **set과 reset** 신호를 넣어서 출력을 1로 만들거나 0으로 만들 수 있어.
* 그래서 정보를 기억할 수 있었지.
* 단점은?
  * <mark style="color:red;">set/reset 신호가 동시에 들어오면 출력이 이상해져!</mark>
  * 그리고 **언제 기억할지 `타이밍`을 제어하는 장치가 없어**.

#### ⏰ **그래서 등장하는 게이트(Gate)!**

S-R 래치에 **게이트 신호 하나**를 추가해봤어.\
이 회로는 “게이트가 열려 있을 때만 기억해!” 라는 개념을 가진 래치가 되는 거야.

> 우리가 말을 듣는다고 항상 기억하진 않잖아?\
> “지금 집중해!” 라고 누가 말해야 비로소 기억하려고 하지.\
> 이 회로에서도 `게이트(Gate)`가 그런 역할을 해주는 거야!

#### 🧱 **게이트가 있는 S-R 래치 구조**

<figure><img src="../../.gitbook/assets/image (242).png" alt=""><figcaption></figcaption></figure>

* 회로에 **gate 입력**이 추가되어 있어.
* **gate가 거짓(하이 1)**&#xC77C; 땐 아무 것도 기억하지 않아. <mark style="color:red;">그냥 상태 유지.</mark>
* **gate가 참(로우 0)**&#xC77C; 때만 <mark style="color:red;">set/reset 신호에 따라 동작해!</mark>



**🔄 그런데 아직도 불편해!**

* 여전히 set/reset을 따로 넣어줘야 하고,
* 실수로 둘 다 눌리면 회로가 망가질 수 있어.
* 이걸 더 단순화하려면? → **입력을 하나로 줄이자!**

#### 📌 **D 래치(D Latch)의 등장**

<figure><img src="../../.gitbook/assets/image (241).png" alt=""><figcaption></figcaption></figure>

**D 래치란?**

> **D 래치(D Latch)** 회로에서는 "gate 신호"가 **0일 때 활성화**되는 구조야.\
> 즉, 이 회로는 **"액티브 로우(Active Low)"** 방식으로 동작해!

* S-R 래치에 **게이트**도 붙이고,
* `입력을 하나(D)`로 합쳐서 아주 쓰기 편하게 만든 래치야!

💡 정리해서 말하면:

| **gate 값**   | 의미                      | 동작                                 |
| ------------ | ----------------------- | ---------------------------------- |
| `0` (**로우**) | 🔓 게이트가 _열림_ → **활성화됨** | D 값을 Q에 전달 → _기억됨_                 |
| `1` (**하이**) | 🔒 게이트가 _닫힘_ → **비활성화** | Q는 **그 상태 그대로 유지** (D가 바뀌어도 영향 없음) |

🎯 예시로 한 번 볼까?

```plaintext
시간    gate    D    Q (출력)
----    ----    --   --------
  t1      1      0      1     ← gate가 닫힘. D는 바뀌지만 Q는 그대로 유지.
  t2      0      0      0     ← gate가 열림! D=0이니까 Q도 0으로 바뀜.
  t3      0      1      1     ← gate 열려있으니까 D=1이 반영돼서 Q=1
  t4      1      0      1     ← gate 닫힘. D가 0이지만 Q는 여전히 1 유지
```



**어떻게 만들었냐면?**

* set엔 D 신호 그대로,
* <mark style="color:red;">reset엔 D의 반대(!D)를 넣어주는 거야.</mark>\
  → 이렇게 하면 둘이 동시에 1이 될 일은 없겠지?



**🎯 D 래치의 동작 원리**

#### 타이밍 신호가 중요해!

타이밍 다이어그램을 보면 이렇게 돼 👇

```
gate:   ━━▁▁━━━━▁▁━━━━
D:      ━━▁▁━━━━━━━▁▁━━━
Q:      ━━━━━▁▁━━━━━▁▁━━
```

* **gate가 열릴 때(D 래치 활성화)**: D 값을 Q에 전달해. 기억되는 순간!
* **gate가 닫힐 때(D 래치 비활성화)**: Q 값은 **그 순간의 D를 그대로 기억**하고 유지해.

> 즉, gate가 열리는 순간에만 D를 받아들이고\
> 그 외에는 그냥 조용히 기존 값을 유지하는 거야.

**😰 하지만 아직 한 가지 아쉬운 점**

* **게이트가 열려 있는 동안(D 래치 활성)에 D가 바뀌면?** → Q도 계속 따라 바뀌어버려.

그래서 D가 “게이트가 열려 있는 동안 얌전히 있으라”고 마치 말 잘 듣는 아이이길 바라는 수밖에 없어 😂

**🧩 그래서 다음 단계는?**

바로 `플립플롭(flip-flop)`이야!\
게이트가 열리는 **"찰나의 순간"에만 D를 받아들이고**,\
그 외에는 철저하게 닫아버리는 똑똑한 기억 회로지.

### 5️⃣ 플립플롭

<figure><img src="../../.gitbook/assets/image (243).png" alt=""><figcaption></figcaption></figure>



**🧠 D 플립플롭: 컴퓨터의 '1비트 기억 장치'**

D 플립플롭은 우리가 **1비트를 기억**하려고 할 때 사용하는 **순차 논리 회로**야. 쉽게 말해서, 특정 시점에 **입력값 D를 저장해서 나중에도 계속 유지**할 수 있게 도와주는 회로지.

#### 🔄 1) 플립플롭은 왜 필요할까?

우리가 앞에서 봤던 D 래치는, **게이트(Gate)가 열려 있는 동안에는 D가 변하면 Q도 따라 바뀌는 구조**였어. 그래서 약간 위험했지.

* 예: 게이트가 열려있는데 D가 자꾸 바뀌면? → Q도 흔들리게 돼! 😱
* 우리는 “딱 이 순간에만 기억해줘!”라는 **정확한 타이밍**이 필요해.

그래서 등장하는 게 바로 **플립플롭**이야!

#### ⏱️ 2) 플립플롭의 핵심: "에지(Edge)에서만 저장!"

> 클럭이 변할 때 D의 값이 저장한다. 에지에 의해 데이터 변화가 촉발된다는 플립플롭의 정의

<figure><img src="../../.gitbook/assets/image (244).png" alt=""><figcaption></figcaption></figure>

플립플롭은 **게이트가 열린 동안**이 아니라, <mark style="color:red;">**클록 신호가 0에서 1로 바뀌는 그 찰나**</mark>에만 D 값을 저장해.

이걸 “**양의 에지(Positive Edge)에서 트리거된다**”고 말해.

만약 1에서 0으로 바뀌는 시점에 저장되면, 그건 `음의 에지 트리거(Negative Edge-Triggered)`라고 해.

> 쉽게 말해: "지금이다!" 하는 찰나에 D 값을 보고 그걸 기억하는 거야.

D라는 입력값은 회로에 저장하고 싶은 데이터를 의미해

그리고 `클록`이 **0에서 1로 변하는 순간이 바로 이 D라는 입력값을 회로에 저장하라는 신호야,**

* 이러한 신호를 우리는 **에지(edge)**&#xB77C;고 부르며, 이것이 바로 위에서 우리가 희망하던 회로에 데이터를 저장하라고 명령을 내리는 입력값이라고 볼 수 있어.
* 특히 D 플립플롭은 `양의 에지`<mark style="color:red;">에 의해 변화가 촉발된다고 하였는데</mark>, 그 의미가 <mark style="color:red;">바로 클록이 0에서 1로 변화할 때 D의 값을 저장한다는 의미</mark>이다. 만약 클록이 1에서 0으로 변할 때 변화가 촉발될 경우 음의 에지에 의해 변화가 촉발(negative edge-triggered)된다고 정의되었을 것이다.\


#### ⚙️ 3) 내부 회로는 어떻게 생겼을까?

플립플롭 내부는 사실 꽤 정교해!

* **3개의 S-R 래치**가 단계적으로 연결돼 있고,
* D와 Clock 값을 받아서
* 어떤 조건일 때만 Q 값을 바꿔줘.

그림을 보면 클록이 0일 땐 아무 일도 안 일어나. D를 아무리 바꿔도 Q는 그대로야.\
하지만 클록이 0 → 1로 올라가는 순간!\
그 순간의 D 값을 잡아서 기억하고 Q에 출력해주는 거지.

#### 🔐 4) 클록 에지 시점에 D는 고정돼 있어야 한다!

<figure><img src="../../.gitbook/assets/image (245).png" alt=""><figcaption></figcaption></figure>

여기서 진짜 중요한 포인트가 있어!\
클록이 0 → 1로 올라갈 때, D 값을 잡아야 하잖아?

> 그런데 **그 찰나의 순간에 D가 흔들리면**? → 어떤 값을 저장해야 할지 애매해져 😵

그래서 D는 **클록이 바뀌기 "조금 전부터", 바뀌고 "조금 뒤까지"는 안정적이어야 해.**

이걸 `셋업 타임(Setup Time)`과 `홀드 타임(Hold Time)`이라고 불러:

* **셋업 타임**: 클록이 변하기 전, D가 고정돼 있어야 하는 시간
* **홀드 타임**: 클록이 변한 후, D가 계속 고정돼 있어야 하는 시간

이 시간을 지키지 않으면 → 회로가 **잘못된 데이터를 저장**하거나, **오작동**할 수 있어.

> 마치 누군가가 “말해!”라고 했을 때 이미 입을 다물고 있으면 못 듣고, 너무 늦게 말해도 못 듣는 거랑 같아.

#### 💾 5) 클록이 '고정된 상태'일 땐? D 바뀌어도 상관없어!

그림처럼 클록이 그냥 0이거나 1인 상태에서는  D 값을 아무리 바꿔도 Q엔 **전혀 영향이 없어.**\
즉, 저장이 일어나지 않아.

> 저장하려면 꼭 “클록의 에지(전이)”가 필요해!

#### 🧱 정리해보자!

| 개념            | 설명                      |
| ------------- | ----------------------- |
| **플립플롭**      | 1비트를 저장하는 기억 회로         |
| **D 플립플롭**    | D 값을 클록 에지에서 저장         |
| **양의 에지 트리거** | 클록이 0 → 1 되는 순간에만 D를 기억 |
| **셋업 타임**     | 클록 바뀌기 전에 D가 고정돼야 하는 시간 |
| **홀드 타임**     | 클록 바뀐 후에도 D가 고정돼야 하는 시간 |
| **클록이 일정할 땐** | D가 바뀌어도 아무 영향 없음        |



* 플립플롭은 말 그대로 “딱 정해진 순간”에 데이터를 기억해.
* 그래서 시계처럼 **동기화된 컴퓨터 회로를 만들 수 있는 핵심 기술**이야.
* 실제 CPU의 **레지스터나 메모리 셀**을 구현할 때 꼭 들어가는 친구지!

### 6️⃣ 카운터

<figure><img src="../../.gitbook/assets/image (247).png" alt=""><figcaption></figcaption></figure>

> 카운터는 말 그대로 **신호의 개수를 세는 회로**야.\
> 예를 들어 컴퓨터가 시간을 계산하려면 "틱, 틱, 틱…" 하고 계속 올라가는 숫자가 필요하잖아?\
> 이 숫자를 만들어주는 게 바로 **카운터**야.

* 플립플롭을 응용한 회로

<figure><img src="../../.gitbook/assets/image (248).png" alt=""><figcaption></figcaption></figure>

#### 🔁 리플 카운터 (Ripple Counter)

**동작 방식**

* <mark style="color:red;">하나의 플립플롭이 상태가 바뀌면, 그 출력이 다음 플립플롭의 클록 입력으로</mark> 들어가!
  * 각 플립플롭은 자신의 CK 신호가 0에서 1로 전이될 때마다 상태가 바뀜
* 그래서 마치 **도미노처럼 ripple(물결)**&#xC774; 퍼져나가는 구조야.

**특징**

* 구조가 간단하고 구현이 쉬움
* **전파 지연(delay)**&#xC774; 발생해서, 각 비트의 출력이 **조금씩 시차를 두고 바뀜**
  * 비동기 카운터asynchronous counter라고도 부른다
* 빠른 연산에는 적합하지 않아

**예시**: 디지털 시계처럼 ‘순서대로 셀’ 필요가 있을 때 적절

#### ⏱️ 동기 카운터 (Synchronous Counter)

<figure><img src="../../.gitbook/assets/image (249).png" alt=""><figcaption></figcaption></figure>

**동작 방식**

* 모든 플립플롭이 **같은 클록**을 동시에 받아!\
  → 하나의 박자에 맞춰 **동시에 상태가 바뀌는 구조**
* 출력이 어느 시점에 올바른지 알려면 전파 지연을 여전  히 고려 필요
  * 플립플롭을 연속적으로 연결해서 생기는 문제는 없어져

**특징**

* 전파 지연이 거의 없음 → **정확하고 빠름**
* 회로가 조금 더 복잡하지만, **고속 시스템에 적합**

**예시**: 고속 연산, 정밀 타이밍 제어가 필요한 컴퓨터 회로

#### 📊 타이밍 관점에서 차이점

| 항목    | 리플 카운터           | 동기 카운터               |
| ----- | ---------------- | -------------------- |
| 클록 입력 | 비트마다 다름 (연쇄적)    | 모든 플립플롭이 동시에         |
| 전파 지연 | 존재함 (점점 누적)      | 거의 없음                |
| 속도    | 느림               | 빠름                   |
| 회로 구성 | 단순               | 복잡                   |
| 사용 예  | 단순 시계, 간단한 수 카운팅 | CPU 내부, 고속 메모리 주소 계산 |

> 이제 우리는 플립플롭으로 **1비트를 기억**할 수 있을 뿐 아니라,\
> 여러 개의 플립플롭을 연결해서 `시간의 흐름(숫자)`도 만들 수 있게 된 거야!\
> 이게 바로 **기억 + 흐름**, 즉 **순차 논리의 진짜 힘**이야. 💪

다음은 이 카운터를 더 발전시켜서 **더 많은 데이터**를 저장하는 **레지스터와 메모리**

### 7️⃣ 레지스터

#### 🧠 **D 플립플롭이 모이면? 바로 레지스터!**

&#x20;**D 플립플롭이 기억하는 1비트**

* 앞에서 배운 것처럼 D 플립플롭은 **클록 신호가 들어올 때 D의 값을 Q에 저장**해.
* 이걸 이용해서 **1비트를 기억할 수 있었지!**

> 그럼 이제, "1비트 말고 **여러 비트를 한 번에 기억**하려면 어떻게 하지?”

바로 **여러 개의 D 플립플롭을 나란히 붙이면 돼!**

이렇게 만든 회로를 `레지스터(Register)`라고 불러.

<figure><img src="../../.gitbook/assets/image (251).png" alt=""><figcaption></figcaption></figure>

#### 🧱 **레지스터란?**

📦 정의

* 레지스터는 **여러 개의 D 플립플롭이 나란히 묶인 기억 장치**
* 일반적으로 **클록을 공유**하면서 동시에 여러 비트를 저장함

📥 하는 일

* 주로 **계산 결과나 입력값을 잠깐 보관**할 때 사용돼.
* CPU 안에서도, ALU의 결과를 잠깐 보관하거나, 다음 연산에 사용할 중간값 저장 등에 활용돼!



**➕ 레지스터로 가산기 결과 저장하기 (예제)**

<figure><img src="../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

#### 🔧 그림 3-18 설명

* 위 회로는 **가산기의 출력 결과**를 D 플립플롭으로 구성된 **레지스터**에 저장하는 예시야!
* **D0\~D7**는 가산기에서 나온 8비트 결과고, 각각을 **Q0\~Q7** 레지스터에 저장하고 있어.
* 클록이 들어오면 한 번에 딱! **8비트 전체가 기억**돼.

#### 🎯 핵심 동작

1. **가산기**는 피연산자1과 피연산자2를 받아서 결과를 만들어냄
2. 이 결과가 **D 입력 라인**을 통해 **레지스터**로 들어감
3. 클록이 ‘똑’ 하고 울리는 순간, D의 값이 Q에 저장됨
4. **피연산자를 바꿔도**, 레지스터 안의 Q는 **그 순간 저장된 결과를 계속 유지**함

**🧩 Enable 입력이란?**

* 어떤 레지스터에는 `EN (Enable)`이라는 제어 신호도 있어
* EN이 **참일 때만** 레지스터가 값을 저장함\
  → 클록이 와도 EN이 꺼져 있으면 값은 무시되고, 저장 안 돼!

**📌 왜 필요할까?**

* 모든 클록 주기마다 저장하면 필요 없는 연산 결과도 저장될 수 있음\
  → 그래서 꼭 필요한 순간에만 저장되도록 **Enable 신호로 제어**하는 거야!

📌 요약

| 구성 요소  | 역할                           |
| ------ | ---------------------------- |
| D 플립플롭 | 1비트 기억 장치                    |
| 레지스터   | 여러 D 플립플롭이 모인 회로 (여러 비트를 기억) |
| 클록     | 기억하는 타이밍을 정함                 |
| Enable | 저장 여부를 제어함 (조건부 저장)          |

이제 우리는 **비트를 기억하는 플립플롭**,\
**그걸 모아 다비트를 기억하는 레지스터**,\
**연산 결과를 저장하는 구조**까지 이해했어!

이 레지스터들이 모이면 **어떻게 더 큰 기억 장치, 즉 메모리가 됨**

## 3. 메모리 조직과 주소 지정

<figure><img src="../../.gitbook/assets/image (252).png" alt=""><figcaption></figcaption></figure>

### 🧠 컴퓨터는 어떻게 '기억'을 확장할까?

앞에서는 **D 플립플롭**으로 1비트를 기억하고, 여러 개를 묶은 **레지스터**로 여러 비트를 기억하는 걸 배웠어. 그런데 만약 우리가 **수많은 계산 결과**를 기억하고 싶다면? 단순히 `레지스터`만 쌓아서는 안 되겠지.&#x20;

> 이제부터는 본격적인 **메모리 회로(memory circuit)** 이야기를 해보자.

#### 📦 1) 레지스터를 많이 쓰면 생기는 문제

"여러 개의 레지스터를 만들면 되지 않나?" 라고 생각할 수 있지만, 문제는...

* **어떤 레지스터에 저장할지, 어떤 레지스터에서 읽어올지** 구분하는 게 어려워.

예를 들어, 아래 그림처럼 여러 레지스터가 있다고 해보자:

```
[레지스터 1]  [레지스터 2]  [레지스터 3]  ...  [레지스터 n]
```

* 이 중에서 **지금 사용할 레지스터**를 골라야 하잖아?
* 이럴 때 필요한 게 바로 **주소(address)**!

각 레지스터에 번호(주소)를 붙여주고, 이 주소에 따라 회로가 동작하도록 하면 돼.

#### 🔡 2) 디코더와 실렉터의 역할

이제 우리가 기억한 내용을 잘 써먹어야 할 때야!

* 주소를 받아서 <mark style="color:red;">해당 레지스터 하나만 "선택"</mark>하는 역할 → **디코더**
* 여러 레지스터 중 **출력값을 선택**해서 <mark style="color:red;">외부로 내보내는 역할</mark> → **실렉터**

디코더와 실렉터를 조합하면, **우리가 지정한 레지스터에만 데이터를 쓰고, 또 거기서만 읽어올 수 있어!**

> 📌 메모리에서는 디코더와 실렉터가 핵심 구성 요소야.

#### ⚙️ 3) 메모리 회로의 구성

> 시스템에서 **여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있어**. 이런 경우 `트라`> \
> `이스테이트 출력`이라는 또 다른 기본 요소가 필요해.

<figure><img src="../../.gitbook/assets/image (253).png" alt=""><figcaption></figcaption></figure>

**기억 저장을 위한 메모리 회로**는 다음과 같이 생겼어:

```
입력 → [디코더] → [여러 개의 레지스터] → [실렉터] → 출력
```

* 디코더: 주소에 해당하는 레지스터를 선택
* **레지스터:** 선택된 곳에 값을 저장하거나 불러옴
* **실렉터:** 여러 레지스터 중 필요한 값만 출력

그리고 여기에 제어 신호들이 더해져:

* **쓰기 활성화(write enable)**: 데이터를 쓸지 말지
* **읽기 활성화(read enable)**: 데이터를 읽을지 말지

#### 🔌 4) 실제 메모리 칩의 구조

<figure><img src="../../.gitbook/assets/image (254).png" alt=""><figcaption></figcaption></figure>

> 주소address와 데이터data에는 개별 신호 대신 큰 화살표를 사용한 것 ⇒ **연관된 신호를 버스bus**

현실에서 메모리 회로는 훨씬 복잡해져(연결지점이 많고.. **32비트**를 다루고 싶으면 **입출력 32개씩 연**결) 그걸 단순화한 게 바로 **메모리 칩**이야!

* 메모리를 동시에 읽고 쓸 필요가 있는 경우는 거의  &#x20;없다는 사실을 활용해 연결을 줄였어.&#x20;
  * <mark style="color:red;">**입력과 출력 데이터 연결을 합치고**</mark> <mark style="color:red;"></mark><mark style="color:red;">read/write 제어 신호    를 사용하면</mark> 연결을 많이 줄일 수 있어!
* 데이터를 저장하는 `레지스터`들이 내부에 있고,
* 주소와 데이터를 전달하는 `버스(bus)`를 통해 신호가 주고받아져.

> 🚌 "버스"는 여러 비트의 데이터를 한꺼번에 실어 나르는 대량 교통 수단이야!

**버스 종류:**

* **주소 버스(address bus)**: 어떤 레지스터를 사용할지 지정
* **데이터 버스(data bus)**: 실제 데이터를 주고받음

#### 🧮 5) 메모리의 주소 지정 - 행과 열로 나누기

메모리 크기가 커지면, 필요한 주소 선도 많아져. 예: 4GiB 메모리 → 32비트 주소 필요

이 문제를 해결하기 위해 **행(row)과 열(column)**&#xB85C; 주소를 나눠서 처리해. 마치 격자처럼!

* **행 주소 → 디코더 → 행 선택**
* **열 주소 → 디코더 → 열 선택**

<figure><img src="../../.gitbook/assets/image (255).png" alt=""><figcaption></figcaption></figure>

📌 이걸 **멀티플렉싱**이라고 해. → 주소 라인의 개수를 절반으로 줄일 수 있어!

단, 이렇게 하려면 **행 주소와 열 주소를 따로 보관할 레지스터**가 필요해.

<figure><img src="../../.gitbook/assets/image (256).png" alt=""><figcaption></figcaption></figure>

* 주소가 두 부분으로 나뉘어 들어오기 때문에, **한 번에 한 부분씩만 변경할 수 있다면 성능이 더**  \
  **좋아질 수 있어**
  * 예를 들어 행 주소를 먼저 지정하고, 열 주소만 변화시키면 좀 더 빨리 처리&#x20;
  * 오늘날 사용 중인 대형 메모리 칩에서는 이런 식으로 주소를 처리

#### 🧰 6) 메모리 칩 기호와 입력 설명

복잡한 회로를 간단히 나타내기 위해 **스키매틱 기호**를 사용해.\
메모리 칩의 기본 입력은 다음과 같아:

* **주소(address)**: 저장 위치를 지정
* **read/write**: 읽기 or 쓰기 모드 설정
* **enable**: 메모리를 사용할지 여부
* **데이터(data)**: 저장하거나 읽어오는 실제 정보

#### 📏 7) 메모리의 크기 표기법

* 메모리는 보통 **깊이 × 너비**로 표기해.
* 예: `256 × 8` → 256개 셀, 각 셀마다 8비트 저장 가능
* 예: `64Mib × 1` → 64메가비트 크기, 한 번에 1비트 저장

#### ✨ 정리!

* 레지스터만으론 부족하다 → 그래서 **주소를 부여해 선택하는 구조**가 필요
* **디코더, 실렉터, enable 신호** 등을 조합해서 메모리 회로를 구성
* 회로가 커질수록 **버스와 멀티플렉싱** 기술이 중요해짐
* 메모리도 결국 플립플롭의 확장판! 단지 좀 더 체계적으로 설계된 거야



### 1️⃣ 임의 접근 메모리(RAM) : 컴퓨터의 기억 저장소, RAM의 세계

<figure><img src="../../.gitbook/assets/image (260).png" alt=""><figcaption></figcaption></figure>

#### 🧠 우리가 지금까지 만든 건 ‘기억 장치’야

앞에서 배운 래치, 플립플롭, 그리고 레지스터들을 조합하면\
컴퓨터는 비트를 저장하고 꺼내 쓸 수 있는 ‘메모리’를 만들 수 있어.

근데 여기서 질문!

> 비트를 몇 개만 저장하면 충분할까?

당연히 아니지.\
**컴퓨터는 수십억 개의 비트를 저장하고 빠르게 꺼내 써야 해.**\
그래서 우리는 ‘RAM’이라는 **더 강력한 기억 장치**를 만들게 돼.

#### 💡 RAM이란?

**RAM(Random Access Memory)** = **임의 접근 메모리**

* ‘임의 접근’이란 말은 → 메모리 위치에 관계없이 원하는 곳에 바로 접근 가능하다는 뜻이야.
* <mark style="color:red;">메모리 주소만 알면, 순서 상관없이 언제든 읽고 쓸 수 있어!</mark>

#### ⚙️ RAM의 종류는 크게 두 가지!

<figure><img src="../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

**1) 📦 SRAM (Static RAM)**

<figure><img src="../../.gitbook/assets/image (262).png" alt=""><figcaption></figcaption></figure>

* **구조**: 하나의 비트를 저장하기 위해 **6개의 트랜지스터**를 사용해!
* **속도**: 정말 빠르다! 클록 속도에 바로 반응할 수 있을 정도.
  * 전원이 공급되는 한 저장된 데이터가 유지되기 때문에 D램(DRAM)과 달리 **리프레시가 필요하지 않음**
* **장점**: 읽기/쓰기가 빠르고 안정적이야.
* **단점**: 공간 많이 차지함 + 비쌈
  * 그래픽카드 등 주로 소용량의 메모리로 사용

> 그래서 SRAM은 **CPU 안의 캐시 메모리**처럼\
> 작지만 빠른 메모리가 필요한 곳에서 사용돼.

**2) 💧 DRAM (Dynamic RAM)**

<figure><img src="../../.gitbook/assets/image (263).png" alt=""><figcaption></figcaption></figure>

* **구조**: **1개의 트랜지스터 + 1개의 커패시터(콘덴서)**\
  → 아주 작은 전기 ‘버킷’에 전자를 담는 방식!
* **장점**: 공간 절약 → 고용량 메모리 구현 가능! (집적도 짱!)
* **단점**: 이 ‘버킷’은 시간이 지나면 **샌다(방전됨)**\
  → 주기적으로 새로 충전(=리프레시)해줘야 해
* 그래서 (이미 비트가 들어 있는) **버킷에 전자를 채우는 시점과 버킷에 정보를 쓰는 시간  이 서로 겹치지 않게 조심!**

> 그래서 DRAM은 **메인 메모리(우리가 흔히 말하는 RAM)**&#xB85C; 쓰이고 있어.

<figure><img src="../../.gitbook/assets/image (264).png" alt=""><figcaption><p>커패시터</p></figcaption></figure>

#### 📸 잠깐, DRAM에는 이런 부작용도 있어!

* **빛을 비추면** 버킷이 더 빨리 샐 수 있어.\
  → 이 현상을 활용한 게 **디지털 카메라 센서**야.\
  → 센서가 빛의 영향을 받아서 전하 변화 = 이미지로 저장됨!

#### 📌 SRAM vs DRAM 한눈에 비교

| 항목   | SRAM       | DRAM               |
| ---- | ---------- | ------------------ |
| 구성   | 6개 트랜지스터   | 1개 트랜지스터 + 1개 커패시터 |
| 속도   | 빠름         | 느림                 |
| 집적도  | 낮음 (덜 저장됨) | 높음 (많이 저장됨)        |
| 가격   | 비쌈         | 저렴                 |
| 쓰임   | CPU 캐시     | 메인 메모리 (RAM)       |
| 방식   |            | 주소 멀티플렉싱 방식        |
| 휘발여부 | 휘발성 메모리    | 휘발성 메모리            |

#### 🧲 비휘발성 메모리: 코어 메모리

예전에는 <mark style="color:blue;">전원이 꺼져도 데이터를 유지할 수 있는 메모리가 있었어.</mark>\
바로 **코어 메모리(core memory)**!

* 도넛 모양의 자석(토러스)에 자화 방향으로 비트를 저장해
* 읽으려면 자화 상태를 바꾸고, 그 반응을 감지해야 해
* 읽으면 원래 상태가 파괴되므로 → 다시 기록해야 함 (읽기=파괴적 읽기)

> 비휘발성이지만, **너무 복잡하고 크기 때문에** 지금은 안 써.\
> 하지만 여전히 이 개념은 현대 메모리 기술의 밑바탕이야.

#### 🌐 DRAM 내부 구조도 생각보다 정교해

* **행(Row)과 열(Column)**&#xB85C; 주소를 나눠서 → 메모리를 격자처럼 관리해
* 행 주소  스트로브를 사용해 **행 주소를 저장하는 속도가** 열 주소 스트로브로 열 주소를 변경하는 것보다  \
  **더 빠르다.**
  * 행을 페이지page라고 부르기도 해.
  * 마치 책에    서는 페이지를 넘기는 속도보다 한 페이지 안에서 각 줄을 건너뛰는 게 더 빠른 것과 비슷
* 주소 라인을 줄이기 위해 **주소 멀티플렉싱(Multiplexing)** 기법을 써
* 그래서 DRAM 안에는 행 레지스터와 열 레지스터도 있음!

이 방식은 <mark style="color:yellow;">성능 향상</mark>에도 도움이 돼.

> 왜냐하면 행은 그대로 두고 열만 바꾸면 더 빠르게 데이터를 꺼낼 수 있으니까!

🌐 동작방식

DRAM에서는 데이터를 읽을 때 이렇게 동작해:

1. **먼저 "행 주소"를 설정하고 → 전체 행을 메모리로 복사해온다**\
   이걸 \*\*행 주소 스트로브(RAS)\*\*라고 불러. → 약간 느리지만 **한 번에 한 페이지를 준비**하는 느낌이야.
2. **그다음, 열 주소 스트로브(CAS)**&#xB97C; 통해\
   행 안의 ‘특정 열’에서 데이터를 뽑아오는 거야. → 이건 페이지 안에서 "몇 번째 줄"을 선택하는 느낌. 빠르지!

#### 📙 이 모든 걸 정리하면?

1. RAM은 **데이터를 빠르게 읽고 쓰는 임시 기억 장치**야.
2. **SRAM**은 빠르고 비싸고 공간 차지 많음 → CPU 캐시에 사용.
3. **DRAM**은 느리지만 작고 싸고 대용량 저장 가능 → 메인 메모리에 사용.
4. **DRAM 내부**는 격자 구조 + 행/열 멀티플렉싱으로 효율을 극대화함.
5. 예전에는 **코어 메모리**도 있었고, 지금은 비휘발성 메모리에 대한 연구도 계속돼!

### 2️⃣ 읽기 전용 메모&#xB9AC;**, ROM의 모든 것**

#### 1) ROM은 진짜 '읽기 전용'일까?

먼저 이름부터 짚고 넘어가자.\
**ROM**이라는 말, 즉 **Read-Only Memory(읽기 전용 메모리)**&#xB294; 사실 _조금 과장된_ 이름이야.

> “읽기만 되고 쓰기는 안 되는 메모리? 그럼 아무 쓸모가 없잖아?”

맞아. 그래서 실제로는 이렇게 말하는 게 더 정확해:

> “**한 번만 쓸 수 있는 메모리**” → 그게 바로 진짜 ROM의 개념이야.

<mark style="color:red;">즉, 데이터를 한 번 저장하면, 그 이후에는 여러 번 읽을 수만 있고 다시 쓸 수는 없어.</mark>

#### 2) ROM이 필요한 이유

생각해봐. 매번 전자레인지에 코드를 새로 입력해야 한다면 얼마나 귀찮을까?\
ROM은 이런 장치의 **프로그램을 '영구히' 저장**하는 데 딱이야!

#### 3) ROM의 시작은… 종이에 뚫린 '구멍'?

ROM의 가장 초창기 형태는 **구멍 뚫린 카드**였어.\
우리가 컴퓨터라고 생각하지도 않을 시절, IBM에서 `천공 카드(Hollerith Card)`를 썼지.

<figure><img src="../../.gitbook/assets/image (12) (1).png" alt=""><figcaption><p>천공 카드</p></figcaption></figure>

* 카드를 기계에 넣으면 **구멍의 위치가 비트 값**을 나타냈어.
* 처음엔 금속 접촉 방식, 나중엔 **빛 + 광센서**로 더 빨리 읽게 됐지.

> 이 아이디어는 사실 1700년대 방직기에서도 사용됐던 기술이야.\
> 즉, ROM의 시작은 직물 디자인에서 온 셈이야!

#### 4) 카드보다 나은 게 필요했다: 천공 테이프

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

IBM 카드가 순서에 민감하고 엉키기 쉬워서 나온 게 **천공 테이프**였어.

* 구멍 뚫린 종이 테이프.
* 순서가 섞일 일은 없지만, **찢어지면 끝장이었지.**
* 비트를 읽으려면 카드와 테이프를 물리적으로 움직여야 했기 때문에 카드와 테이프는 아주 느  렸어

#### 5) 우주에서는 어떤 ROM을 썼을까? – 코어 로프 메모리

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p> <strong>코어 로프 메모리</strong></p></figcaption></figure>

아폴로호에는 **코어 로프 메모리**라는 진짜 특이한 ROM이 쓰였어.

* **바느질로 비트를 기록**했대!
* 전자기 간섭에 강해서 우주 환경에 적합했지.

#### 6) ROM은 왜 느릴까? – 순차적 메모리의 한계

카드와 테이프, 로프 메모리 모두 **순차적 메모리**야.

> <mark style="color:red;">데이터를 앞에서부터 하나하나 순서대로만 읽을 수 있었어.</mark>

그래서 실제 프로그램 실행을 하려면 항상 **RAM으로 옮겨야 했지.**

#### 7) 마이크로프로세서 등장, ROM의 진화

1971년, **인텔 4004**라는 첫 마이크로프로세서가 등장하면서\
"ROM도 좀 빠르게, 유연하게 만들자!"는 수요가 생겼어.

그래서 점점 진화하게 돼:

#### 🧱 ROM의 진화 단계

#### 1. **마스크 ROM (Mask ROM)**

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* 마스크 프로그래머블mask-programmable ROM
  * 마스크mask는 집적 회    로 생산 과정에서 사용하는 공판화stencil를 뜻
  * 반도체 업체에 돈 주고 **영구적인 회로를 새겨달라는 방식.**
  * **비트 패턴을 마스크로 바    꿔서** 여러분의 프로그램이 들어 있는 칩을 만들어서 돌려줘
* 정말 바꿀 수 없어서, 만들 때부터 완벽해야 해.
* 비용이 크니까 칩이 많을 때만 사용 가능
* 임의 접근이 가능해(아무 주소나 원하는 대로 읽을 수 있음).

#### 2. **PROM (Programmable ROM)**



* 프로그래머블 읽기 전용 메모리
* 사용자가 <mark style="color:red;">한 번은 직접 쓸 수 있어!</mark>
* 내부에 **퓨즈**가 있고, 프로그래밍할 땐 은 칩에 있는 니크롬nichrome(니켈-크롬 합금) 퓨즈를 ‘끊어서’ 데이터를 저장해.
* <mark style="color:red;">문제는…</mark> <mark style="color:red;"></mark><mark style="color:red;">**한 번 쓰면 끝**</mark><mark style="color:red;">이라는 거.</mark>
  * 프로그램을 개발하는 과정에서 (프로그램의 오류 등으로 버려진) PROM이 산처럼 쌓이기 쉬웠음

#### 3. **EPROM (Erasable PROM)**

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>EPROM</p></figcaption></figure>

* 지울 수 있는 읽기 전용 메모리EPROM,  erasable programmable ROM
* <mark style="color:red;">수정 가능한 PROM!</mark>
* **자외선**을 쬐면 내부 데이터를 지울 수 있어.
* 그래서 칩에 보면 **작은 창문** 같은 게 있었어.

#### 4. **EEPROM (Electrically Erasable PROM)**

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1) (1).png" alt=""><figcaption><p>EEPROM</p></figcaption></figure>

* 전기로도 지울 수 있음!
* 자외선 안 써도 돼. 너무 편해졌지.
* 단점은… **쓰기 속도가 느림** → 그래서 아직도 'ROM'이라고 불려.

✨ 정리하면!

| 단계 | 이름       | 쓰기           | 지우기     | 특징         |
| -- | -------- | ------------ | ------- | ---------- |
| 1  | Mask ROM | ❌ (제조 단계에서만) | ❌       | 대량 생산용     |
| 2  | PROM     | ✅ (1번만)      | ❌       | 퓨즈로 저장     |
| 3  | EPROM    | ✅            | ✅ (자외선) | 수정창 있음     |
| 4  | EEPROM   | ✅            | ✅ (전기)  | 가장 편하지만 느림 |

#### 💡 한 마디로!

> ROM은 '읽기 전용'이라기보다\
> '자주 안 바꾸는 프로그램을 한 번만(혹은 드물게) 써두는 메모리'야.

`EEPROM`은 **내부 데이터를 아무 순서로나 쓰고 읽을 수 있기 때문에 기술적으로는 RAM**이야.

하지만 데이터를 쓰는 데 시간이 오래 걸리고 RAM보다 비싸기 때문에 ROM을 대신하는&#x20;목적으로 쓰인다

#### 🔋 ROM은 왜 비휘발성이야? `ROM(Read-Only Memory)`은 **비휘발성 메모리**야. 즉, **전원이 꺼져도** 데이터가 **사라지지 않는 저장장치**지.



* RAM(휘발성)은 전원이 꺼지면 메모리 내용이 날아가.
* 반면 ROM은 내부 회로나 저장 방식 자체가 **전기를 끊어도 정보가 유지되도록 설계**되어 있어.



**📌 다시 한 번 기억해두자면:**

| 종류             | 특징                 | 전원 OFF 시  |
| -------------- | ------------------ | --------- |
| **RAM** (휘발성)  | 빠르고 읽고/쓰기 가능       | ❌ 데이터 사라짐 |
| **ROM** (비휘발성) | 보통 한 번만 쓰고 여러 번 읽음 | ✅ 데이터 유지  |

즉, ROM은 **한 번 쓰고 여러 번 읽을 수 있게 만든 비휘발성 메모리**고,\
전자레인지나 세탁기 같은 **임베디드 시스템**에 많이 들어가!

## 4. 블록 장치

### 💽 컴퓨터의 장기 기억장치 – 디스크와 저장소 이야기

> 컴퓨터에서 자주 듣는 **디스크 드라이브**가 도대체 어떻게 동작하고, 왜 RAM보다 느린지, 어떤 구조로 되어 있는지 알아보자.

<figure><img src="../../.gitbook/assets/image (7) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### 📦 1) 메모리에도 ‘거리’ 개념이 있다?

<mark style="color:red;">컴퓨터가 어떤 데이터를 쓰거나 읽을 때도 “시간”이 걸려.</mark>\
예를 들어,

> 밀가루가 필요할 때마다 매번 슈퍼마켓 가서 한 숟갈씩 사온다고 생각해봐... 😵\
> 차라리 한 포대 사 와서 집에 두고 쓰는 게 낫겠지?

이게 바로 **메모리와 저장 장치**의 차이야!

* **RAM**은 <mark style="color:red;">집 안에서 바로 꺼낼 수 있는 재료</mark>.
* **디스크 드라이브**는 좀 더 먼 창고 같은 거야.\
  → 속도는 느리지만 **용량은 훨씬 크고 싸지!**

#### 🔄 2) 디스크는 어떻게 생겼을까?

<figure><img src="../../.gitbook/assets/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

디스크 드라이브의 구조는 **중국집 회전판**을 떠올리면 좋아!

<figure><img src="../../.gitbook/assets/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **자화된 판(platter)**&#xC774; 돌고,
* 그 위에 **디스크 헤드**가 원하는 위치에서 데이터를 읽거나 써.
* 헤드는 고정돼 있고, 회전판이 **7200RPM**으로 빠르게 돌아가.

그래서 데이터가 헤드 바로 밑에 오지 않으면?

> 기다려야 해! → 이걸 **회전 지연 시간**이라고 해. (약 8ms 정도 걸림)

#### 🧭 3) 디스크는 어디에 데이터를 저장할까?

디스크는 **블록 단위로 데이터를 저장하고 읽어.**

* 예전엔 한 블록 = 512바이트였는데
* 요즘은 **한 블록 = 4096바이트**야!

그래서 딱 1바이트만 바꾸고 싶어도?

> 전체 블록을 읽고 → 수정하고 → 다시 써야 해 😬

#### 🎯 4) 디스크 안의 지도: 섹터와 트랙

디스크 안은 이렇게 구성돼 있어:

* **트랙(track)**: 회전판 위의 동심원 모양 경로
* **섹터(sector)**: 트랙을 나눈 조각 → 블록 단위 저장
* **클러스터(cluster)**: 여러 섹터 묶음
* **방사형 영역(radial zone)**: 바깥쪽엔 더 많은 섹터를 저장하는 최신 기술

> 바깥쪽 섹터가 더 넓은데, 같은 양의 데이터만 저장하면 낭비잖아!\
> 그래서 바깥쪽에는 더 많은 데이터를 넣게 한 거야.

#### ⏱ 5) 디스크의 느린 이유? 탐색 + 회전 지연

디스크는 데이터를 읽기 전에 두 가지 시간이 필요해:

1. **탐색 시간(seek time)**\
   → 헤드가 원하는 트랙으로 이동하는 시간
2. **회전 지연(rotational latency)**\
   → 원하는 데이터가 헤드 아래 올 때까지 기다리는 시간

> RAM은 이런 시간이 필요 없어!\
> → 그래서 수십\~수백 배 빠른 거야.

#### 💾 6) 디스크의 형제들: 다양한 저장 장치들

디스크 드라이브 외에도 여러 저장 장치가 있어:

**1. 플로피 디스크 (Floppy Disk)**

* 유연한 디스크 → 그래서 ‘플로피’라고 불려
* 저렴하고 탈착 가능했지만 지금은 거의 사라짐

**2. 자기 드럼(Magnetic Drum)**

* 회전하는 원통에 데이터를 저장
* 고전적인 방식의 비휘발성 저장소

**3. 자기 테이프(Magnetic Tape)**

* 릴에 감긴 테이프에 자화해서 저장
* 아주 느리지만 대용량 백업용으로 아직도 사용돼

**4. 광학 디스크 (CD, DVD 등)**

* **자성 대신 ‘빛’으로 데이터 읽기/쓰기**
* 읽기 전용(ROM), 한 번 쓰기(PROM), 재기록 가능(RW) 디스크 등 있음

#### ✨ 한 마디로 정리하면!

* 디스크는 **많은 데이터를 싸게 저장**할 수 있는 **비휘발성 장치**
* 하지만 RAM보다 **훨씬 느리다**
* 디스크 안에는 **섹터, 트랙, 클러스터**라는 정교한 구조가 있고,
* 데이터를 읽으려면 **찾아가야 하니까** 시간이 더 걸리는 거야.

> [https://velog.io/@ttomy/CPU](https://velog.io/@ttomy/CPU)

## 5. 플래시 메모리와 SSD

> 플래시 메모리flash memory는 가장 최근 나타난 EEPROM 유형의 매체이며, 음악 플레이어나 디지털> \
> 카메라 등의 응용에는 플래시 메모리가 적합해

#### 1) SSD vs HDD, 뭐가 다를까?

우리가 평소에 사용하는 저장 장치는 보통 **HDD(하드 디스크)** 아니면 **SSD(고체 상태 드라이브)**&#xC57C;.

H`DD`는 내부에 **회전하는 원판(platter)**&#xC774; 있고, 거기에 자성 물질로 데이터를 저장해.\
그 위에 있는 **헤드(head)**&#xAC00; 마치 턴테이블의 바늘처럼 움직이면서 데이터를 읽고 써.

그런데 SSD는 완전히 달라!

> ❗ SSD는 **움직이는 부품이 하나도 없어.**\
> 대신 **플래시 메모리**라는 반도체 기반 저장장치를 써서 데이터를 저장해!

그래서:

* **충격에 강하고, 조용하고, 전력도 적게 써.**
* 읽기 속도도 훨씬 빠르지!
* 대신 가격이 조금 비싸고, **쓰기 수명**이 제한적이라는 단점이 있어.

#### 2) 플래시 메모리는 어떻게 작동할까?

<figure><img src="../../.gitbook/assets/image (265).png" alt=""><figcaption></figcaption></figure>

플래시 메모리는 내부적으로 아주 작은 `셀(cell)`로 구성되어 있고,\
각 셀 안에는 **플로팅 게이트(floating gate)**&#xB77C;는 구조가 있어.

* 데이터를 `쓸 때(write)`는 전자를 플로팅 게이트에 **가둬**버려.
* 전원이 꺼져도 이 전자가 **빠져나가지 않고 그대로 유지**돼.
* <mark style="color:red;">이 전하의 유무(있냐, 없냐)</mark>로 **0과 1**을 표현하는 거야!

> 🔋 즉, 플래시 메모리는 **메모리인데도 비휘발성**이야.\
> 전원이 꺼져도 데이터가 사라지지 않지!

<figure><img src="../../.gitbook/assets/image (266).png" alt=""><figcaption></figcaption></figure>

이게 가능한 건 **플로팅 게이트 구조** 덕분이야. DRAM처럼 새는 구조가 아니라서!

플래시 메모리는 기본적으로 **DRAM처럼 '버킷에 전자를 담는 방식'**&#xC73C;로 동작해.\
하지만 큰 차이점이 하나 있어!

* **DRAM**의 버킷은 금방 샌다 → 그래서 수시로 `갱신(refresh)`해야 해.
* **플래시 메모리**는 더 튼튼한 구조라 전자가 잘 안 샘 → **비휘발성**이라는 거지!

> 즉, 전원을 꺼도 데이터가 유지돼서 디스크로도 쓸 수 있는 거야! 💾

#### 3) SSD는 정말 빠르기만 할까?

* 읽기는 아주 빠르고, **랜덤 액세스(random access)** 속도도 거의 일정해.
* **HDD는 헤드가 이동해야 하기 때문에** 어느 데이터를 읽느냐에 따라 속도가 달라.
* 하지만 SSD는 위치 상관없이 빠르게 읽을 수 있어!

다만, 쓰기(write)는 조금 복잡해:

* 데이터를 **1로 바꾸는 건 쉬워.**
* 하지만 **0으로 바꾸려면 블록 전체를 먼저 지우고 다시 써야 해!**
* 그래서 SSD는 내부 데이터를 **블록 단위**로 관리하고 있어.
* 이 때문에 쓰기 작업은 HDD보다 느려질 수 있어.

쓰기가 복잡한 이유는?

읽기는 자유롭게 할 수 있어. 하지만 **쓰기는 복잡한 규칙이 있어.**

> ❗ "0은 1로 바꿀 수 있지만, 1은 다시 0으로는 못 바꾼다!" 😮

즉, 한 번 값을 쓰면, 그걸 바꾸기 위해선 **전체 블록을 통째로 지우고 다시 써야 해.**

* **비트를 0으로 만드는 건 어렵다.**
* 그래서 보통은 일단 전체 블록을 **지우고(초기화)** → **다시 쓰는 방식**을 사용해.

이런 특성 때문에 플래시 메모리는:

* 읽을 때는 → **임의 접근 (Random Access)**
* 쓸 때는 → **블록 접근 (Block Access)**



#### 4) 쓰기를 많이 하면 SSD는 왜 망가질까?

플래시 메모리는 ‘뚜껑이 닳는다’는 표현이 있어.

* 여러 번 읽고 쓰기를 반복하면, <mark style="color:red;">셀의 플로팅 게이트가</mark> <mark style="color:red;"></mark><mark style="color:red;">**물리적으로 마모**</mark><mark style="color:red;">돼.</mark>
* 그래서 **블록을 너무 자주 쓰면 수명이 짧아져.**
  * 한 블록은 수천\~수만 바이트를 포함해.
  * 예를 들어, 512KB짜리 블록이 있다고 해보자.
  * 그 안에 있는 단 하나의 바이트만 바꾸고 싶어도 → **전체 블록을 지워야 해!**
  * 📌 이게 바로 플래시 메모리가 ‘읽기는 빠른데 쓰기는 느린’ 이유야.

이 문제를 해결하기 위해 SSD 내부에는 이런 기능이 있어:

> **웨어 레벨링(wear leveling)**\
> → 모든 블록이 **비슷한 횟수로** 쓰이도록 조절해서 수명을 고르게 만들어주는 전략!
>
> → SSD는 쓰기 횟수를 **자동으로 추적**해서, 같은 블록만 반복해서 쓰이지 않도록 조정해줘!
>
> → 이건 마치 일기장을 맨 앞장만 쓰면 종이가 다 닳을 테니, **페이지를 고르게 써서 오래 쓰는** 것과 비슷하지! 📓

#### 5) SSD는 디스크지만 ‘메모리’이기도 해!

**SSD는 메모리 기반의 디스크**라고 보면 돼.

* 내부에 DRAM도 있고, 플래시 메모리도 있고,
* SSD 자체가 RAM과 ROM의 특징을 섞어서 가진 저장장치지.

#### 6) 플래시 메모리의 종류도 다양해

| 종류          | 설명                                |
| ----------- | --------------------------------- |
| **EPROM**   | 자외선을 쬐면 지울 수 있는 ROM               |
| **EEPROM**  | 전기로 지울 수 있는 ROM (플래시 메모리는 여기 포함!) |
| **플래시 메모리** | 여러 셀에 전자 저장, 빠르고 비휘발성, SSD의 핵심 부품 |

### ✨ 요약 정리

* **SSD는 플래시 메모리를 사용한 저장장치야!**
* 플로팅 게이트에 전자를 저장해서 **비휘발성** 특성을 가지지.
* **HDD보다 빠르지만, 쓰기 수명은 제한적**이야.
* 그래서 **웨어 레벨링** 같은 기술로 수명을 관리해.
* 읽기는 빠르고 위치에 상관없지만, 쓰기는 블록 단위라 구조적으로 조금 복잡해.
* 플래시 메모리는 결국 **EEPROM의 발전형**이고,\
  **ROM처럼 비휘발성**, **RAM처럼 원하는 주소에 접근 가능**하다는 특성을 가지지!

## 6. 오류 감지와 정정

주제는 **데이터 오류 검출과 정정**이야!\
컴퓨터에서 **우주 방사선도 비트를 바꿀 수 있다**는 충격적인(!) 이야기부터,\
**패리티, 해밍 코드, 체크섬, CRC, 해시**까지 오류 검출의 전 과정을 보자

### 🛡️ **데이터 오류를 막아라! - 컴퓨터의 오류 검출과 복구 이야기**

#### 1) 정말로 비트가 바뀌는 일이 있다고?

맞아! 이론적으로가 아니라 **실제로 벌어지는 일**이야.

* **우주 방사선** 같은 외부 요인이 메모리 셀을 치면, **비트 하나가 바뀔 수도 있어!**
* 예를 들어, 0이던 비트가 갑자기 1로 바뀌는 일이 생긴다는 거야 😨

> 이런 일이 발생했을 때,
>
> * **빨리 감지**할 수 있으면 좋고
> * **스스로 고칠 수 있다면 더 좋겠지?**
> * 물론 이렇게 개선하려면 돈이 들어가기 때문에 일반 소비자에게 판매하는>   &#x20;제품 수준에서는 이런 기능이 들어가 있는 경우가 많지 않아...!&#x20;

#### 2) 가장 기본적인 방법! **패리티(Parity)**

> 패리티parity를 사용하면 단 1비트만 데이터가 잘못된 경우를 감지할 수 있어!

<figure><img src="../../.gitbook/assets/image (267).png" alt=""><figcaption></figcaption></figure>

**어떻게 동작하냐면...**

* <mark style="color:red;">데이터의</mark> <mark style="color:red;"></mark><mark style="color:red;">**1 비트 개수**</mark><mark style="color:red;">를 세어!</mark>
* **짝수 개수면 패리티 비트를 0**,\
  홀수 개수면 **패리티 비트를 1**로 설정해.

<figure><img src="../../.gitbook/assets/image (268).png" alt=""><figcaption></figcaption></figure>

> 이걸로 나중에 데이터를 검사했을 때,\
> **비트가 홀수 개 바뀌면 오류를 감지**할 수 있어.

모든 비트의 **XOR**을 취하면 쉽게 이런 비트를 만들 수 있어!

* 짝수 패리티even parity는 모든 비트를 서로 XOR 한 값을 사용
* 홀수 패  리티odd parity는 XOR 한 값의 보수를 사용

**예시로 보면?**

| 데이터       | 1의 개수   | 패리티 비트 (짝수 기준) |
| --------- | ------- | -------------- |
| 1010 0110 | 4개 (짝수) | 0              |
| 1001 0001 | 3개 (홀수) | 1              |

근데 문제는…

> ❗ **짝수 개** 비트가 동시에 바뀌면?\
> → 감지 못해! 😵\
> (패리티만으로는 "짝수 번 바뀐" 오류는 감지가 안 돼)

#### 3) 그럼 오류를 직접 고치는 건?

**등장! 해밍 코드(Hamming Code)**

> [https://m.blog.naver.com/ggggamang/221113176831](https://m.blog.naver.com/ggggamang/221113176831)

* **리처드 해밍**이라는 수학자가 만든 멋진 코드야.
* 단순히 "오류가 있다!"는 걸 넘어서,\
  → **오류가 생긴 비트의 위치까지 찾아내서 수정할 수 있어!**

> 예를 들어 8비트 데이터에 몇 개의 해밍 비트(패리티 역할)를 추가해\
> **어디에서 오류가 났는지 위치를 추적**하는 방식이야.

<figure><img src="../../.gitbook/assets/image (270).png" alt=""><figcaption><p><a href="https://m.blog.naver.com/ggggamang/221113176831">https://m.blog.naver.com/ggggamang/221113176831</a></p></figcaption></figure>

그래서 요즘 서버나 항공, 우주 분야처럼 **신뢰성이 매우 중요한 컴퓨터**는\
👉 **ECC 메모리**라는 걸 써.\
(ECC = **Error Checking and Correction**)

#### 4) 데이터가 자주 바뀌지 않는 경우엔?

예를 들어,

* 소프트웨어 파일이나
* 이미지 파일처럼 **정적인 데이터**의 무결성을 확인할 땐\
  더 간단하고 값싼 방법이 있어!

**✅ 체크섬(Checksum)**

* 모든 바이트 값을 쭉 더해서,
* 그 합을 특정 비트 수(n비트)로 잘라서 저장해.

→ 나중에 읽을 때 다시 더해보고 값이 맞는지 확인!

**✅ CRC (순환 중복 검사, Cyclic Redundancy Check)**

* 체크섬보다 훨씬 더 정교하고 수학적으로 강력한 방식!
* 네트워크 패킷이나 디스크 저장 등에 자주 쓰여.

**✅ 해시(Hash)**

* 아주 조금이라도 바뀌면 해시 값이 완전히 달라져!
* 보안이나 파일 무결성 검증에 널리 쓰여.

> 예: Git에서 커밋 ID도 해시값이지! 😎

#### 5) 우주에서도 안전하게? ‘트리플 복제 + 투표 시스템’

* 정말 중요한 시스템은\
  → 데이터를 3벌 저장하고\
  → 투표(Voting)로 다수결 판단을 해!

> "얘랑 얘랑 같으니까 너(혼자 다른 값)는 틀린 거야!" 이런 식으로!

→ NASA나 **스페이스 셔틀 컴퓨터**는 실제로 이 방식을 써.

### ✨ 마무리 정리

* 컴퓨터의 데이터는 **물리적 이유로 오류가 날 수 있다.**
* 오류를 막기 위한 기법:
  * **패리티 비트**: 1비트 오류 감지
  * **해밍 코드**: 1비트 오류 감지 + 정정
  * **ECC 메모리**: 해밍 코드 응용
  * **체크섬, CRC, 해시**: 정적인 데이터 검증
  * **트리플 복제 + 투표 시스템**: 신뢰성이 필수인 우주/항공/서버용



## 7. 소프트웨어냐 하드웨어냐, 그것이 문제로다?

**소프트웨어와 하드웨어의 경계가 얼마나 모호해졌는지**, 그리고 **하드웨어를 소프트웨어처럼 다룰 수 있는 시대가 왔다는 이야기**야.

#### 🔍 1) 하드웨어와 소프트웨어, 진짜 다를까?

우리는 보통 이렇게 생각해:

<figure><img src="../../.gitbook/assets/image (271).png" alt=""><figcaption></figcaption></figure>

* **하드웨어**는 눈에 보이고, 만질 수 있는 장치들.
* **소프트웨어**는 눈에 안 보이는 코드, 프로그램.

그런데 실제로는 **둘 사이의 경계가 생각보다 흐릿해.**\
왜냐하면, 우리가 사용하는 논리도 결국 전기 회로(하드웨어)로 구현되거나, 코드(소프트웨어)로 구현되는 거니까!

> 📌 “논리를 소프트웨어로 구현하느냐, 하드웨어로 구현하느냐”의 차이일 뿐이야.

#### 💡 2) ROM, PROM, EEPROM… 이건 다 뭐야?

이전에 우리가 본 **ROM 계열 메모리**들 있지?

* **ROM**: 한 번만 쓸 수 있고 읽기만 가능
* **PROM**: 사용자가 한 번만 쓸 수 있음
* **EPROM**: 자외선으로 지우고 다시 쓸 수 있음
* **EEPROM**: 전기로 지우고 다시 쓸 수 있음
* **플래시 메모리**: EEPROM의 진화형. SSD나 USB에 들어가!

이건 단순한 저장장치 얘기가 아니야.\
👉 <mark style="color:red;">이 방식들이 그대로</mark> <mark style="color:red;"></mark><mark style="color:red;">**회로 설계 기술로도 사용**</mark><mark style="color:red;">된다는 게 핵심이야!</mark>

#### ⚙️ 3) 하드웨어 설계도 ‘프로그래밍’이다

옛날엔 하드웨어를 설계하려면 필름 위에 마스킹 테이프를 붙이며 일일이 설계해야 했어.\
그런데 1979년, **카버 미드**와 **린 콘웨이**라는 두 과학자가 전자 설계를 자동화할 수 있는 방법을 제시하면서,\
**칩 설계도 소프트웨어처럼 작성하는 시대**가 열렸지.

> ✍️ 요즘은 **Verilog, VHDL, SystemC** 같은 프로그래밍 언어로 하드웨어를 설계해.

#### 🏗️ 4) 직접 회로를 ‘프로그래밍’한다? FPGA의 등장

자, 이제 진짜 재밌는 얘기!\
현대에는 아예 하드웨어 회로를 ‘프로그래밍’할 수 있는 칩도 있어.

* 그게 바로 **FPGA (Field-Programmable Gate Array)**&#xC57C;.
* 이름 그대로, **현장에서(Field) 직접 회로를 구성할 수 있는 칩**이야.

즉, 우리가 회로도를 그리는 대신, **소프트웨어로 로직을 짜서 회로를 구성**할 수 있어!

> 💡 “FPGA는 하드웨어처럼 생긴 소프트웨어다”라고 보면 돼.

#### 🔁 PROM\~FPGA까지 대응 구조로 보면 이렇게 정리돼:

| 저장 메모리       | 대응되는 회로 기술     | 특징                  |
| ------------ | -------------- | ------------------- |
| ROM          | 고정 회로          | 한 번만 쓸 수 있음         |
| PROM         | 커스텀 설계 회로      | 사용자 1회성             |
| EEPROM       | 고정 + 재설정 가능 회로 | 일부 재설계 가능           |
| Flash Memory | 유연한 회로 구성 가능   | 여러 번 재프로그래밍 가능      |
| FPGA         | 완전한 소프트웨어적 회로  | 회로를 직접 소프트웨어로 프로그래밍 |

#### 🚀 5) 소프트웨어만 아는 사람도, 하드웨어를 짤 수 있는 시대!

예전에는 컴퓨터 프로그래머는 **주어진 하드웨어 위에 소프트웨어를 얹는 사람**이었어.\
하지만 이제는, 하드웨어와 소프트웨어를 **함께 설계하고 최적화하는 프로젝트**도 많아졌어!

특히 **FPGA를 다루는 팀**에 들어가게 되면, 소프트웨어 지식만 가지고도\
**논리 회로를 구현하고, 성능 최적화까지 직접 할 수 있는 시대**가 온 거야!

> “코드로 회로를 설계하고, 코드로 하드웨어를 제어한다.”\
> 앞으로는 이 둘의 경계를 넘나드는 사람이 진짜 실력자가 될 수 있어.



## 딥다이브

### 1) 클럭을 만들어주는 클리스털  발진기 는 어디에 있을까?

#### 🧠 **즉, 발진자가 곧 클록이다!**

* `발진자(Oscillator)`는 **주기적으로 0과 1의 신호**를 만들어내는 장치야.\
  → 그 주기적인 전기 신호가 바로 `클록(Clock Signal)`이 되는 거고!
* 이 **클록 신호**는 컴퓨터 회로 전체에 **"지금 계산해!"**, **"기억해!"** 같은 **동기화 신호**를 계속 보내주는 역할을 하지.

#### 🖥️ **그럼 발진자는 어디 있냐?**

* **CPU 안에도 클록 신호를 받는 회로가 있어.**
* 하지만 발진자(클록 자체)는 **보통 메인보드(메인 회로판)에 따로 탑재**돼 있어!

즉...

> ⛏️ **발진자**는 메인보드 위에 따로 있음 →\
> ⏱️ 그게 클록 신호를 만들어냄 →\
> 🧠 CPU와 다른 부품들이 그 클록 신호에 맞춰 동작함

#### 예를 들어

1. 너의 컴퓨터 메인보드에는 작은 **크리스털 발진자**가 있어. (보통 금속 캔 모양이야 ⛓️)
2. 이게 **1초에 수억\~수십억 번** 전기적 신호를 깜빡깜빡 만들어내.
3. 이 신호를 CPU가 받아서 **정해진 타이밍대로 동작**하는 거지!

#### 🔍 덧붙여서…

* 요즘 고급 CPU는 내부적으로도 복수의 **클록 도메인(clock domain)**&#xC744; 가져.
  * 예: **연산 부**, **캐시 메모리**, **버스** 등이 서로 다른 속도로 움직이기도 해!
* 이런 구조 덕분에 CPU는 복잡한 연산을 더 효율적으로 처리할 수 있어.

요약하자면:

> ✅ **발진자 = 클록 신호 생성기**\
> ✅ **클록 = CPU의 박자**\
> ✅ **발진자는 메인보드에 있지만, CPU는 그 신호에 맞춰 움직인다!**

### 2) “일반적인 논리 회로 설계 오류는 **최댓값이나 최솟값을 사용하지 않고 전형적인 값**을 사용하기 때문에 생긴다.”

#### 🤔 무슨 상황일까?

컴퓨터 회로나 CPU 같은 `디지털 회로`는 **전기가 얼마나 빨리 흐르느냐(=전파 지연 시간)**&#xC5D0; 따라 동작 속도가 달라져.\
근데 이 전파 지연 시간은 항상 **딱 고정**된 값이 아니야!

왜냐하면:

* 만드는 공정에서의 미세한 차이,
* 온도 변화,
* 전압 차이 등등에 따라\
  **느려지기도** 하고 **빨라지기도** 하거든.

그래서 제조사는 보통 이렇게 말해:

* **최솟값**: “이 정도면 가장 빨리 반응해요!”
* **전형값**: “보통은 이 정도 속도예요\~”
* **최댓값**: “이 이상 느려지는 경우도 있으니 대비하세요!”

#### ❗ 그런데 문제는 뭐냐면…

논리 회로를 설계할 때 **“보통 이 정도니까 괜찮겠지\~”** 하고\
`전형적인 값(typical value)`만 가지고 회로를 짜는 사람이 많다는 거야.

그런데 만약, 현실에서는 그 회로에 **최댓값** 수준의 지연이 생긴다면?

* 회로는 **예정보다 더 느리게 반응**하게 되고,
* 다음 단계가 그걸 **기다리지 않고 실행**해버리면
* **오류 발생!** ❌

#### 💥 예시로 정리해보자

```plaintext
A라는 회로가 2ns 안에 출력을 내야 한다고 가정해볼게.
근데 전형적인 회로는 보통 1.5ns 안에 끝나.
그래서 “1.5ns면 되겠지~” 하고 설계를 함.

하지만 어떤 환경에서는 그 회로가 2.2ns 걸릴 수도 있어.
그럼 문제 생기겠지? → 지연이 생겨서 오작동.
```

🔍 그래서 안전하게 설계하려면?

* **최악의 경우(Worst case)**&#xB97C; 생각해서
* **가장 늦게 반응할 수 있는 시간(최댓값)**&#xC744; 기준으로 설계해야 해!

이렇게 해야 예상치 못한 환경에서도 **안정적으로 동작**하는 회로가 되는 거야.\
그래서 ‘전형값만 보고 회로를 짜면 오류 생긴다’는 거지!

#### 🧠 요약하면?

| 항목        | 설명                                       |
| --------- | ---------------------------------------- |
| **전형값**   | 평균적인 상황에서의 반응 속도                         |
| **최댓값**   | 가장 느리게 반응할 수 있는 상황                       |
| **설계 오류** | 전형값만 고려하면, 실제 사용 중 최악의 상황에서 회로가 망가질 수 있음 |
| **해결책**   | 항상 \*\*=최악의 시나리오(최댓값)\*\*를 고려해서 설계해야 안전함 |



### 3) feedback 값이란? OR 게이트 래치

### 📌 `feedback` 값이란?

출력값(out)을 다시 입력으로 되돌려 넣은 값이야.\
즉, **회로에서 스스로 기억하려고 자기가 만든 출력 값을 다시 입력으로 넘겨주는 것**이지!

### 🔁 어떻게 연결돼 있냐면?

OR 게이트는 보통 **입력이 두 개** 필요하잖아?\
그러면 이렇게 연결돼:

```
입력1: in (외부에서 주는 입력)
입력2: feedback (자기 자신이 낸 출력값을 다시 입력으로 돌림)
```

그리고 나서 이렇게 계산돼:

```
out = in OR feedback
```

### 🎯 예시로 한번 해보자!

#### 처음 상태

* in = 0
* feedback = 0 (out도 0이니까)

→ `out = in OR feedback = 0 OR 0 = 0`

#### 이제 in을 1로 바꿔보자!

* in = 1
* feedback = 0

→ `out = 1 OR 0 = 1`

💥 `out`이 1이 됐지?\
이 값은 다시 **feedback으로 되먹여서** OR 게이트 두 번째 입력으로 들어가.

#### 그다음, 다시 in을 0으로 바꾸면?

* in = 0
* feedback = **이전 out 값 = 1**

→ `out = 0 OR 1 = 1`

> 🤯 오! 입력을 다시 0으로 바꿨는데도\
> **output은 여전히 1이네?**

이게 바로 되먹임(feedback)의 힘이야!\
**한 번 상태가 바뀌면, 그걸 회로가 기억하고 유지하는 거지.**

### 🔁 정리하면

| 이름         | 의미    | 설명                        |
| ---------- | ----- | ------------------------- |
| `in`       | 외부 입력 | 우리가 주는 신호 (초기화/설정용)       |
| `feedback` | 내부 입력 | 회로의 출력값을 다시 입력으로 연결한 값    |
| `out`      | 출력    | in과 feedback 중 하나라도 1이면 1 |

### 🧠 이게 중요한 이유

이 구조 덕분에 회로가 **자기 출력을 기억할 수 있게 돼!**\
바로 **1비트 메모리의 시작**이 되는 거야.

### 4) 인버터와 OR 게이트 래치의 차이

**🔄 인버터(=NOT 게이트)는?**

* 입력이 `0`이면 출력이 `1`
* 입력이 `1`이면 출력이 `0` → 즉, **무조건 반대로 바꿔주는 게이트**야.

이걸 되먹임(feedback)으로 자기 자신한테 연결하면 어떻게 돼?

* 처음에 `0` 넣으면 → 출력이 `1`
* 근데 그게 다시 입력으로 들어가니까 → `1` → 출력은 `0`
* 다시 `0` → `1` → `0` … 무한 반복!

그래서 **계속 0 → 1 → 0 → 1 … 진동이 생겨!** → 이걸 `발진기(oscillator)`로 쓰는 거야.

#### 🧩 그런데 OR 게이트는?

#### OR 게이트는?

* 입력 중 **하나라도 1이면 출력이 1**
* **둘 다 0일 때만 출력이 0**

예를 들어, OR 게이트에 이런 피드백을 걸면?

**회로 구조:**

* 입력: `in`, `feedback`
* 출력: `out`
* `out` → 다시 OR 게이트 입력으로 들어감 (되먹임)

#### 🔍 예시로 따라가보자!

#### 초기 상태:

* `in = 0`, `feedback = 0`
* → OR 게이트 출력 `out = 0`

#### 그다음, in을 1로 바꿔!

* `in = 1`, `feedback = 0`
* → OR(1, 0) = 1 → `out = 1`

이제 출력이 1이 됐지? 그럼 되먹임 입력도 1이 돼!\
→ **`feedback = 1`**

#### 이제 다시 in을 0으로 바꿔볼까?

* `in = 0`, `feedback = 1`
* → OR(0, 1) = 1 → 여전히 `out = 1`

와! `in`은 0으로 바뀌었는데도 **출력은 계속 1로 유지돼!**

#### 🎯 핵심 차이: **인버터는 반전**, OR은 **고정화**

| 회로         | 특징                              | 결과          |
| ---------- | ------------------------------- | ----------- |
| 인버터 피드백    | 계속 반전해서 입력/출력이 교차 → **진동 발생**   | 발진기 역할      |
| OR 게이트 피드백 | 한 번 1이 되면 계속 1 유지 → **안정적인 기억** | 래치 역할 (메모리) |

#### 💡 인버터는 ‘동그라미’가 핵심

맞아, 네가 말한 대로 **인버터에는 동그라미(⊙)** 가 붙어 있는데\
그건 “출력을 **반대로** 바꿔라”는 의미야.\
그래서 반전 → 반전 → 반전 반복 = **진동**이 가능해.

그에 반해 OR 게이트는 동그라미가 없으니까,\
**출력을 반전하지 않아.** 그냥 "둘 중 하나라도 1이면 무조건 1!"이야.



**✨ 그래서 정리하면!**

* 인버터는 **입력 값을 반전시키기 때문에**, 피드백이 들어오면 계속 바뀌고 → **진동!**
* OR 게이트는 **반전 없이 값만 유지**하기 때문에 → 한 번 1 되면 계속 1 → **기억 회로!**
* 그래서 OR 게이트 래치는 **진동하지 않고**, 대신 **1비트 기억하는 회로**로 사용돼!

### 5) “reset가 로우이면 reset은 하이이므로, OR 게이트의 출력은 OR 게이트의 입력에 되먹임된다. reset가 하이로 가면 reset은 로우가 되고, 그에 따라 되먹임이 깨지고 out은 0이 된다.”

이건 Active Low 신호인 reset 바(`reset‾`)가 어떻게 작동하는지를 설명하는 거야.\
그럼 우리가 먼저 **reset‾이 뭔지**, **회로에서 어떤 흐름이 생기는지** 정리해보자.

#### 1️⃣ `reset‾`가 \*\*로우(0)\*\*일 때

* 기억해! **reset‾는 바(‾)가 붙었으니까 Active Low 신호야.**
* 즉, 0일 때 **리셋 기능이 작동**하는 거야.

하지만 이 문장은 **reset가 로우면 reset은 하이다**라고 말하지?

#### 그건 뭐냐면…

> 문장 안의 첫 번째 "reset"은 \*\*reset‾ (reset 바)\*\*를 의미하고,\
> 두 번째 "reset"은 **그 값을 반전시킨 일반 reset** 신호를 뜻해.

즉,

* `reset‾ = 0` → `reset = 1`
* 이 때는 **리셋 기능이 꺼져있는 상태**고,
* 출력 `out`은 **피드백을 유지한 채로 동작한다**는 말이야!

> 즉, out은 이전에 저장된 값 그대로 유지돼!\
> (기억하고 있는 상태)

#### 2️⃣ `reset‾`가 \*\*하이(1)\*\*일 때

* 바가 붙은 `reset‾ = 1`
* 그럼 일반 `reset = 0`

즉, **reset이 작동함!**

* 이때는 AND 게이트의 출력이 **무조건 0**이 되고,
* OR 게이트도 0을 출력하게 돼.
* 이 출력이 다시 피드백을 통해 입력으로 돌아가도,\
  계속 0이기 때문에 **out이 0으로 고정!**

> 결과: 래치가 **리셋(초기화)**&#xB3FC;서 out = 0!

🧩 정리해서 풀어보면!

| `reset‾` 값 | 작동 상태           | 결과                   |
| ---------- | --------------- | -------------------- |
| `0` (로우)   | reset 활성화 (리셋함) | `out = 0`            |
| `1` (하이)   | reset 비활성화 (안함) | 이전 out 유지 (기억된 값 유지) |

🌟 핵심 요약

* **reset 바(`reset‾`)는 0일 때 리셋 동작을 하라는 뜻**이야!
* OR 게이트 회로에서 \*\*되먹임(feedback)\*\*은 `reset‾`이 1일 때만 유지돼.
* `reset‾ = 0`이면 회로가 강제로 `out = 0`이 되게 만들어서 "기억을 지워버리는" 거고,
* `reset‾ = 1`이면 **되먹임이 연결돼서 이전 값을 계속 유지하게 돼!**



> 즉. r**eset 바(`reset‾`)는 0일 때 리셋 동작을 하라는 뜻**

### **6) 게이트가 열렸다가 뭘까**

**왜냐면 "참/거짓"이 우리가 일반적으로 생각하는 거랑 회로에서 쓰는 "신호 레벨"이 다를 수 있거든.**

#### ✅ **gate 신호가 "하이(1)"일 때 → 회로는 닫힘 (입력 무시)**

* **입력이 NAND 게이트를 통해 들어가잖아?**
* 그런데 gate가 1이면,\
  `NAND(gate=1, set)` 또는 `NAND(gate=1, reset)`은\
  **결국 set/reset 입력값이 제대로 전달되지 않아.**
* 그래서 **출력은 이전 상태(Q)를 그대로 유지**하게 돼!

#### ✅ **gate 신호가 "로우(0)"일 때 → 회로가 열림 (입력 반영)**

* gate가 0이면? `NAND(gate=0, set)`은 **무조건 1**이 돼.
* 이렇게 되면 실제로 S-R 래치 안에서\
  set과 reset이 정상적으로 작동하고, **출력이 바뀔 수 있어.**

#### 💡 그래서 핵심 정리는?

| gate 값     | 의미       | 회로 상태            |
| ---------- | -------- | ---------------- |
| **1 (하이)** | "게이트 닫힘" | **입력 무시, 출력 유지** |
| **0 (로우)** | "게이트 열림" | **입력 반영, 출력 갱신** |

#### 🤔 그럼 왜 "gate=0"일 때 "게이트가 열렸다" 고 표현할까?

이건 **액티브 로우(Active Low)** 방식이기 때문이야!

* **논리적으로는 "게이트가 열려 있다" → 동작 가능 상태**
* 근데 회로 구조상, **0일 때 동작하게 만든 구조**인 거야.
* 그래서 "게이트가 열리면(Gate=0)", D나 set/reset 신호가 반영돼.



결론적으로 네 말:

> **gate가 거짓(하이 1)일 땐 아무 것도 기억하지 않아. 그냥 상태 유지.**\
> **gate가 참(로우 0)일 때만 set/reset 신호에 따라 동작해!**

👉 **맞아! 완벽하게 정확해.**

### 7) 디스크, 메모리, CPU 중 100% 넘을 수 없는 것? 넘으면 어떻게 되는가?

#### 💻 CPU: **100% 넘는 것처럼 보일 수 있다 (멀티코어 때문)**

#### 1) CPU 사용률은 어떻게 계산될까?

* 단일 코어가 100% 사용되면 → `1코어 = 100%`
* 멀티코어 시스템에서는 **전체 CPU % = (코어 수 × 100%)**\
  예) 4코어면 전체 400% 가능\
  → `htop`에서는 프로세스 CPU%가 400%까지도 가능함

#### 2) CPU 100%면 무슨 일이 일어날까?

* 컨텍스트 스위칭 발생!\
  → 다른 프로세스가 CPU를 사용하기 위해 **현재 프로세스를 잠시 멈추고** 다른 걸 실행
* **선점형 스케줄러**가 CPU 점유를 강제로 나눔\
  → `타임 슬라이스` 단위로 번갈아 실행

✅ 그래서 CPU가 100%라도 "동작이 멈추는" 건 아니고, **속도가 느려질 뿐** 동작은 계속함

#### 💾 디스크 I/O: **100%가 넘는다기보단 병목이 생김**

* 디스크는 병렬 연산이 제한적이기 때문에 `100% 사용`이라는 개념이 좀 달라
* **I/O wait** 비율이 높아지면 → CPU가 디스크 작업 끝날 때까지 "놀고" 있게 됨

📌 확인 방법:

```bash
$ iostat -x 1
```

→ `%util`이 100% 가까우면 **디스크 I/O가 병목 중**

또는 `htop`의 CPU 막대 중 \*\*회색(아이오 대기 시간)\*\*이 많으면 디스크 병목 상태

#### 🧠 메모리: **100% 넘으면? → 스왑(SWAP) 사용 → 시스템 느려짐**

1\) 메모리가 다 차면?

* 커널은 **디스크의 일부 공간을 SWAP으로 사용**함 (가상 메모리)
* 디스크에 저장해두고, 다시 쓸 때 RAM으로 불러옴 (매우 느림!)

2\) SWAP도 다 차면?

* OOM(Out of Memory) Killer가 동작 → 커널이 메모리를 많이 먹는 프로세스를 **강제로 종료시킴**

3\) 확인 방법:

```bash
$ free -m
```

* RAM과 SWAP 사용량 확인 가능

#### 정리 ✨

| 자원  | 100%일 때 현상    | 넘어가면?         | 컨텍스트 스위칭     |
| --- | ------------- | ------------- | ------------ |
| CPU | 논리 코어 기준 100% | 가능 (멀티코어 합산)  | O (스케줄러가 분배) |
| 디스크 | I/O 대기로 느려짐   | 병목 생김         | CPU가 대기함     |
| 메모리 | SWAP 사용 시작    | OOM으로 프로세스 죽음 | X (메모리는 점유됨) |

#### 💬 그래서 "100% 넘을 수 있나요?" 요약하면:

* **CPU는 논리코어 기준이기 때문에 "100% 넘는 값도 있음"**
* **디스크는 100% 넘는다기보다 병목 현상이 생김**
* **메모리는 넘으면 스왑 → OOM → 죽음의 사이클**\


## 전체 요약 개괄

1. **논리회로만**으로는 +, -를 할 수 없음&#x20;
2. 기억을 못하기 때문에
3. 그래서 전기흐름은 순간이라 시간의 흐름이 없어 인버터를 이용해서 출력을 입력으로 쓰는 `발진자`를 만듦
4. 발진자를 기반으로 `클럭`이 만들어짐
5. 기억을 하기 위해 `래치가` 만들어짐

* 래치에는 **or 래치**의 단점인 1로 됐을 때 되돌릴 수 없어서 **and-or**로 그 단점을 고치려고 했지만 그렇게 되면 비대칭으로 지연시간 차이가 너무 나서 그걸 조절하기 위해 S-R로 했어 근데 이것도 단점이 있어
* 그래서 타이밍을 기억하기 위해 `게이트`를 추가
* 그렇게 래치 게이트도 탄생

6. 하지만 래치 게이트도 문제가 있는데, 그것을 해결하기 위해 메모리 회로의 핵심 플립플롭이 나옴.. 0-> 1 양의 에지에 의해 변화가 있을 때만 D를 저장해서 클럭에 의해 조절 가



## 참고&#x20;

* [https://velog.io/@yun2021/CS-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%8B%9C%EA%B0%84-%ED%91%9C%ED%98%84%EA%B3%BC-%EC%83%81%ED%83%9C-%EA%B8%B0%EC%96%B5](https://velog.io/@yun2021/CS-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%8B%9C%EA%B0%84-%ED%91%9C%ED%98%84%EA%B3%BC-%EC%83%81%ED%83%9C-%EA%B8%B0%EC%96%B5)
* [https://bugoverdose.github.io/computer-science/latch-and-flip-flop/](https://bugoverdose.github.io/computer-science/latch-and-flip-flop/)

