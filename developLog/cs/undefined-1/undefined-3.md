---
description: 고수준 언어와 저수준 언어  프로그래밍 방식 비교
---

# 🔟 애플리케이션 프로그래밍과  시스템 프로그래밍

## 1. **애플리케이션 vs 시스템 프로그래밍: 동물 퀴즈로 알아보기**

### 1) 웹 브라우저는 '고급 컴퓨터'다?

우리는 지난 장까지 **브라우저**를 마치 고차원의 가상 컴퓨터처럼 바라봤어요.

{% hint style="success" %}
즉, 브라우저는 HTML, CSS, JavaScript 등 '명령어'를 받아서 `DOM(Document Object Model)`을 조작하는 구조입니다.
{% endhint %}

#### ● 브라우저가 제공하는 고수준 인터페이스

* DOM API
* 이벤트 핸들러
* Ajax / Fetch 등 통신 API

이러한 고수준 API는 **운영체제와 I/O 장치의 복잡성을 감춰줍니다.**

그럼 이번 장에서는 **브라우저를 거치지 않고** 같은 프로그램을 만들면 어떻게 다를지 직접 비교해 봅시다.

### 2) 애플리케이션 vs 시스템 수준의 프로그래밍 비교

#### ● 그림 10-1의 구조 요약

<figure><img src="../../.gitbook/assets/image (323).png" alt=""><figcaption></figcaption></figure>

```
[사용자 인터랙션 프로그램 구조 비교]

프로그램 A (고수준)
 └→ 웹 브라우저 (DOM, JS로 제어)
     └→ 운영체제
         └→ I/O 장치 (키보드, 화면 등)

프로그램 B (저수준)
 └→ 직접 OS API 호출 (예: C 언어)
     └→ 운영체제
         └→ I/O 장치
```

👉 **웹 브라우저 기반**은 사용자가 다루기 쉽고 빠르게 만들 수 있습니다.\
👉 **시스템 수준 프로그래밍(C 언어 등)**&#xC740; 하드웨어와 OS 동작을 더 정확히 이해하고 제어할 수 있습니다.

### 3) 예제 프로그램: '동물 맞히기 게임'

우리가 만든 프로그램은 사용자가 생각한 동물을 컴퓨터가 질문을 통해 추측하는 간단한 지식 기반 게임입니다.

#### ● 예시 대화 흐름

```
컴퓨터: 동물을 생각해보세요.
컴퓨터: 동물이 짖습니까?
사용자: 예
컴퓨터: 개입니까?
사용자: 아니요
컴퓨터: 졌습니다. 무슨 동물입니까?
사용자: 케르베로스
컴퓨터: "머리가 3개입니까?" 라는 질문으로 구분하겠습니다.
```

#### ● 핵심 기능

1. 질문을 통해 트리 구조를 따라 내려감
2. 잎(Leaf) 노드에 도달하면 동물을 추측
3. 추측 실패 시 새로운 동물과 질문을 받아 트리 확장
4. 다음 라운드부터는 더 똑똑해짐 (학습함)

### 4) 프로그램 구조: 순서도 이해하기

#### ● 그림 10-2: 동물 퀴즈 트리 순서도 요약

<figure><img src="../../.gitbook/assets/image (324).png" alt=""><figcaption></figcaption></figure>

그림을 보면 **동물에 대한 지식으로 이뤄진 트리를 따라 내려가되,** 질문을 던지면서 어느 경로로&#x20;내려갈지를 결정합니다.&#x20;

* 제대로 동물을 추측하면 기뻐한다.&#x20;
* 동물을 맞히지 못하면 사용자에게 정  답을 물어본 후 해당 동물을 마지막에 확인한 동물과 구분하는 데 필요한 질문을 요청해서, 그  &#x20;정보를 트리에 추가하고 처음부터 다시 시작한다.

이 프로그램은 (순서도의 왼쪽에서) **지식 트리를 따라 내려가면서 질문을 던지고 답을 얻습니다.**

> 오른쪽에서 경로의 끝에 도달하면 답을 맞혔는지 여부에 따라 잘난 체를 하거나 동물에 대한 지> 식을 지식 기반knowledge base에 추가합니다.

이 순서도를 코드로 바꾸면 아래와 같은 흐름이 됩니다:

```js
if (isLeaf(node)) {
  if (userAnswer === node.answer) {
    alert("맞췄습니다!");
  } else {
    learnNewAnimal();
  }
} else {
  if (userAnswer === "예") {
    node = node.yes;
  } else {
    node = node.no;
  }
}
```





### 5) 시스템 수준과 애플리케이션 수준의 차이

| 구분        | 애플리케이션 수준 (JS/웹)      | 시스템 수준 (C/콘솔)          |
| --------- | --------------------- | ---------------------- |
| 사용자 인터페이스 | HTML + CSS + DOM 조작   | 콘솔 출력, scanf/printf    |
| 데이터 저장    | LocalStorage, 서버      | 파일 I/O, 메모리 직접 제어      |
| 입력 처리     | `prompt`, `click` 이벤트 | `scanf`, `getchar()` 등 |
| 확장성       | 빠르고 직관적               | 복잡하지만 강력함              |

> 웹 브라우저는 이미 많은 기능이 추상화되어 있지만, **시스템 프로그래밍은 메모리, 파일, 버퍼 등 세세한 부분까지 관**리해야 합니다.

### 📌 부가설명: JSON → DB → 프론트까지 흐름도

앞서 요청하신 예시 흐름도도 아래와 같이 이어집니다.

#### ● JSON 기반 데이터 흐름

```mermaid
graph LR
  A[프론트엔드: 입력폼] --> B[JSON 생성]
  B --> C[API로 서버 전송]
  C --> D[DB에 저장 (예: MongoDB)]
  D --> E[API로 클라이언트에 재전송]
  E --> F[프론트엔드 렌더링 (React, Vue)]
```

→ 이 흐름은 현대적인 SPA 프레임워크에서 CRUD 처리의 전형적인 구조입니다.



브라우저가 '컴퓨터 같은 프로그램'이라는 비유

> 고수준 프로그래머는 DOM API만 알면 되지만,\
> 시스템 프로그래머는 '그 아래'까지 봐야 합니다.

## 2. 부가정리 :  동물 퀴즈 트리: JSON 구조 & C 구조체 변환

### 1) 동물 퀴즈 트리 구조란?

동물 맞히기 게임은 질문을 던지고 그에 따라 **예/아니오**로 가지를 뻗는 **이진 트리 구조**를 사용합니다.

예:

```
질문: 동물이 짖습니까?
 ├─ 예 → 질문: 머리가 3개입니까?
 │    ├─ 예 → 케르베로스
 │    └─ 아니요 → 개
 └─ 아니요 → 고양이
```

### 2) JSON 구조로 저장하기

```json
{
  "question": "동물이 짖습니까?",
  "yes": {
    "question": "머리가 3개입니까?",
    "yes": { "animal": "케르베로스" },
    "no": { "animal": "개" }
  },
  "no": {
    "animal": "고양이"
  }
}
```

#### 📌 JSON 저장 포인트

* 질문 노드는 `"question"` 키를 가짐
* 동물(잎 노드)은 `"animal"` 키만 있음
* `"yes"`, `"no"`로 자식 노드를 연결

### 3) C 구조체로 표현하기

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int is_question;        // 1이면 질문, 0이면 동물
    char text[128];         // 질문 or 동물 이름
    struct Node* yes;       // 예 답변
    struct Node* no;        // 아니요 답변
} Node;
```

#### 📌 사용법 예시

```c
Node* create_animal(const char* name) {
    Node* node = malloc(sizeof(Node));
    node->is_question = 0;
    strcpy(node->text, name);
    node->yes = node->no = NULL;
    return node;
}

Node* create_question(const char* question, Node* yes_node, Node* no_node) {
    Node* node = malloc(sizeof(Node));
    node->is_question = 1;
    strcpy(node->text, question);
    node->yes = yes_node;
    node->no = no_node;
    return node;
}
```

### 5) JSON ↔ 구조체 변환 개념 요약

| 항목     | JSON 저장                    | C 구조체 표현                 |
| ------ | -------------------------- | ------------------------ |
| 노드 식별  | `"question"` or `"animal"` | `is_question` (1/0)      |
| 질문 내용  | `text` 필드에 저장              | `char text[128]`         |
| 하위 노드  | `"yes"`, `"no"`            | `struct Node* yes`, `no` |
| 추가 확장성 | 구조적으로 유연함                  | 메모리 직접 할당 필요             |

### 마무리 정리

> JSON 구조는 웹과 서버에서 다루기 좋고,\
> C 구조체는 시스템 수준에서 메모리를 제어할 수 있어 강력합니다.





## 4. 동물 추측 게임: HTML/CSS/JS vs C 코드 비교 분석

### **1) 프로그램 구조 비교**

| 항목        | 브라우저 기반 (HTML+JS)                | 시스템 기반 (C 터미널)                  |
| --------- | -------------------------------- | ------------------------------- |
| 실행 환경     | 브라우저 (웹페이지)                      | 터미널 (CLI)                       |
| 사용자 인터페이스 | HTML `<button>`, `<input>`       | 콘솔 출력 `printf`, 입력 `scanf`      |
| 지식 트리 구조  | HTML `<div string="질문/동물">` 트리   | 구조체 기반 이진 트리 (노드 구조체)           |
| 트리 저장 방식  | DOM 노드에 숨겨서 저장                   | 메모리 내 구조체 + 포인터                 |
| 이벤트 처리    | `onclick`, `$(selector).click()` | `if/else`, `scanf()` 입력 분기      |
| 상태 전환     | DOM 탐색 및 자식 노드 이동                | 구조체 포인터 이동 (`node = node->yes`) |
| 초기화       | `restart()` 함수                   | 루트 포인터 초기화                      |
| 반복 구조     | 사용자 클릭 이벤트 중심                    | 무한 루프 (`while(1)`)              |
| 메모리 관리    | 자동 (DOM 트리 조작)                   | 수동 (`malloc` / `free`)          |
| 실행 흐름     | 비동기적 인터랙션 (이벤트 루프)               | 동기적 흐름 (입력 → 처리 → 출력)           |

### **2) 지식 트리 구현 코드 비교**

#### 🧱 HTML/JS (브라우저)

```html
<div id="root" class="invisible">
  <div string="동물이 짖습니까?">
    <div string="개"></div>
    <div string="고양이"></div>
  </div>
</div>
```

```js
function question(new_node, html) {
  $('#dialog').append(html);
  if ($(new_node).length == 0) return true;
  node = new_node;
  $('#dialog').append($(node).attr('string') + '?');
  return false;
}
```

* **데이터 구조**: 실제 구조는 HTML DOM, 데이터는 `<div>` 요소의 `string` 속성
* **노드 탐색**: `$(node).children(':first-child')` 식으로 DOM 탐색
* **확장 방식**: `wrap()`과 `prepend()`로 새로운 질문을 삽입

#### ⚙️ C 코드 (터미널)

```c
typedef struct node {
  char *string;
  struct node *yes;
  struct node *no;
} Node;

Node *newNode(char *str) {
  Node *n = malloc(sizeof(Node));
  n->string = strdup(str);
  n->yes = n->no = NULL;
  return n;
}
```

```c
void ask(Node *node) {
  if (node->yes == NULL && node->no == NULL) {
    printf("%s입니까? (y/n) ", node->string);
    char response;
    scanf(" %c", &response);
    if (response == 'y') printf("맞췄습니다!\n");
    else {
      // 새로운 질문/동물 추가...
    }
  } else {
    printf("%s (y/n) ", node->string);
    char response;
    scanf(" %c", &response);
    if (response == 'y') ask(node->yes);
    else ask(node->no);
  }
}
```

* **데이터 구조**: 구조체 기반 이진 트리, `malloc`으로 생성
* **노드 탐색**: 단순한 포인터 이동 (`node->yes`, `node->no`)
* **확장 방식**: `strdup()`으로 문자열 복사 후 새 노드 생성

### **3) 인터페이스 및 I/O 방식 비교**

| 기능       | HTML+JS                           | C (터미널)                                    |
| -------- | --------------------------------- | ------------------------------------------ |
| 입력 방식    | `<button>`, `<input>` 클릭 → 이벤트 발생 | `scanf`, `getchar` 등으로 동기 입력               |
| 출력 방식    | `<div>`에 문자열 append               | `printf()`로 터미널에 출력                        |
| 인터랙션     | 비동기 이벤트 기반 (`click`)              | 순차적 흐름, 입력 없으면 대기                          |
| 문맥 전환    | 브라우저가 처리, 사용자는 인식 못함              | `read()` → 시스템 콜 → 문맥 전환 발생                |
| 시스템 콜 사용 | 브라우저 내부에서 추상화됨                    | `read`, `write`, `malloc`, `free` 등 명시적 호출 |

### **4) 메모리 구조 및 관리 차이**

| 항목        | 브라우저 버전        | C 버전                            |
| --------- | -------------- | ------------------------------- |
| 메모리 할당    | 브라우저가 DOM으로 관리 | 직접 `malloc`, `free` 호출          |
| 트리 저장     | 문서 구조로 자동 저장   | 힙에 노드 구조체로 저장                   |
| 가비지 컬렉션   | 브라우저 GC 자동 처리  | 명시적 메모리 해제 필요                   |
| 메모리 오류 위험 | 낮음             | `메모리 누수`, `dangling pointer` 위험 |

### **5) 핵심 개념 비교 요약표**

| 구분       | 브라우저 환경            | C 환경                    |
| -------- | ------------------ | ----------------------- |
| 프로그래밍 모델 | 선언적 + 이벤트 기반       | 명령형 + 절차적               |
| 데이터 표현   | DOM 엘리먼트 속성        | 구조체 포인터                 |
| 유저 이벤트   | 클릭, 키 입력 → 이벤트 핸들러 | 문자 입력 → 조건 분기           |
| 렌더링      | 브라우저 엔진 자동 처리      | 텍스트 출력만                 |
| 버퍼링      | 브라우저 내부 버퍼 자동      | `stdio`, 드라이버, OS 레벨 버퍼 |
| 디버깅 방식   | 콘솔(log), 브라우저 툴    | gdb, printf 디버깅         |
| 운영체제 추상화 | 거의 완전 추상화          | 운영체제 호출 직접 사용           |
| 코드 복잡도   | 짧고 간단              | 길고 메모리 관리 필요            |

### ✅ 어떤 상황에 어떤 방식이 좋을까?

| 목적             | 브라우저 방식이 유리  | C 방식이 유리         |
| -------------- | ------------ | ---------------- |
| 사용자와 인터랙티브 UI  | ✅ 예          | ❌ 아니요            |
| 시스템 동작 원리 학습   | ❌ 한계 있음      | ✅ 아주 유리          |
| 빠른 프로토타입 제작    | ✅ 빠름         | ❌ 느림             |
| 메모리 최적화 / 고성능  | ❌ 브라우저 한계 있음 | ✅ 가능             |
| 장치 제어, 드라이버 구현 | ❌ 불가능        | ✅ 시스템 직접 접근 가능   |
| 유지보수           | ✅ DOM 트리 활용  | ❌ 포인터/메모리 관리 어려움 |

### 📌 결론

* **브라우저 버전**은 _빠르게 UI를 구성하고 사용자와 상호작용하기에 최적&#xD654;_&#xB418;어 있으며, 메모리나 I/O 처리를 브라우저가 도와주므로 학습이 쉬움
* **C 버전**은 _입출력, 버퍼링, 시스템 콜, 문맥 전환 등 시스템 프로그래밍의 핵심 개념을 모두 체&#xD5D8;_&#xD560; 수 있으며, 내부 동작을 정확히 이해하는 데 적합

