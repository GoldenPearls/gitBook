---
description: 컴퓨터 하드웨어는 어떻게 구성되는가
icon: '4'
---

# 4장 : 컴퓨터 내부 구조

이제까지 배운 내용을 바탕으로 **실제로 컴퓨터를 구성하는 전체 구조**를 다루는 거라서, 지금까지 배운 비트, 논리회로, 메모리 등이 실제로 **어떻게 유기적으로 연결되는지**를 이해하는 게 핵심

### 🖥️ 4장. 컴퓨터는 어떻게 구성되어 있을까?

#### 1) 비트 → 회로 → 컴퓨터

우리가 지금까지 배운 흐름을 잠깐 복습해볼게:

* **1장:** 비트와 이진수, 전기 신호로 정보를 표현하는 방법을 배웠고
* **2장:** 조합 논리를 통해 ‘계산하는 회로’를 만들었고
* **3장:** 순차 논리를 통해 ‘기억하는 회로’를 만들었지?

이제는 이 회로들을 조합해서 **'컴퓨터'라는 하나의 시스템**을 만든다는 거야.\
즉, 지금부터는 진짜로 **전기 신호로 작동하는 컴퓨터 전체의 뼈대**를 만들기 시작하는 거지.

#### 2) 컴퓨터의 세 가지 핵심 구성 요소

컴퓨터를 크게 나누면 이렇게 세 가지 구성으로 설명할 수 있어:

| 구성 요소                             | 설명                         |
| --------------------------------- | -------------------------- |
| **CPU** (Central Processing Unit) | 계산과 판단을 담당하는 '두뇌' 역할       |
| **Memory (메모리)**                  | 데이터를 '기억'해 두는 공간           |
| **I/O (Input/Output)**            | 바깥세상과 소통하는 창구 (입력장치와 출력장치) |

이 세 가지가 유기적으로 연결되면, 우리가 아는 컴퓨터가 되는 거야.

#### 3) 이 장에서는 ‘간단한 컴퓨터’를 만든다

이번 4장에서는 **설명이 쉬운 구조의 간단한 컴퓨터**를 만드는 게 목적이야.\
이 컴퓨터가 시장에서 팔리는 제품처럼 강력하거나 최적화되어 있는 건 아니야.\
하지만 **컴퓨터의 핵심 개념**은 담겨 있기 때문에, 이 구조를 이해하면 어떤 컴퓨터든 구조가 눈에 들어오기 시작할 거야.

> "간단한 구조로 본질을 꿰뚫고, 이후 복잡한 최적화를 이해하는 것"\
> 이게 우리가 이 장에서 추구하는 방향성이야.

#### 4) 컴퓨터 구조의 중심: 도심(CPU)

이 책에서는 CPU를 `도심(City Center)`에 비유하고 있어.\
**모든 정보와 계산이 집중되는 중심지라는 의미지.**\
CPU는 <mark style="color:red;">메모리에서 정보를 받아와서 계산하고, 그 결과를 다시 메모리나 I/O로 보내줘.</mark>

> 도심(CPU)이 메모리(창고)와 I/O(도로망, 창구)를 통해 정보들을 모으고,\
> 계산해서 다시 내보내는 구조라고 생각하면 돼.

## 1. 메모리 : **메모리는 어떻게 쓰일까?**

* 메모리는 물리적으로 어떻게 구성되나
* 메모리 주소체계
  * 여러 bit를 어떤 식의 주소로 쓰나
  * 페이징할 때의 주소는 어떤 형식
  * 프로그램 -> 메모리로 주소가 어떻게 변환되나
* 메모리 할당
  * protection memory
  * 메모리를 할당하는 방법과 단편화 문제
  * 페이징 시 주소변환, 효율적인 변환방법들
  * 프로세스 context switching 때 페이징 관리 , demanding page보완
  * 페이징 교체 알고리즘

1\) 메모리는 물리적으로 어떻게 구성되나?

메모리(메인 메모리)는 ram(random access memory)이라고도 하며 디스크보다 빠른 속도의 i/o가 가능하지만 휘발되는 저장공간이다.\
(주로 d-ram이 사용됨)

아래와 같이 생겼으며, 저 칩 하나하나에 몇 억 개의 셀이 존재한다.

![](<../../.gitbook/assets/image (1) (1).png>)\
`셀`은 **캐패시터와 트랜지스터로 전하를 저장/제어하는 단위**이다.\
이 셀에 전하가 저장되있냐 아니냐로 0,1을 표현해 기계어를 저장한다.

#### 2) 메모리는 ‘정렬된 집들’이다

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>



컴퓨터에서 **메모리**는 마치 **일렬로 정렬된 집들** 같아.

* 각각의 ‘집’은 **고정된 크기(보통 1바이트)**&#xB97C; 가지고 있고 **정해진 개수만큼 비트를 저장할 수 있는 방**이 있는 거지
* 모든 집에는 <mark style="color:red;">주소(address)</mark>가 붙어 있어!

예를 들어 컴퓨터에 64MiB의 메모리가 있으면,\
주소는 `0번`부터 `67,108,863번`까지 차례대로 붙어 있는 거지.\
👉 이걸 우리는 **메모리 주소 공간**이라고 불러.

#### 3) 메모리는 바이트 단위로 나뉘지만, CPU는 더 크게 읽기도 해

컴퓨터는 실제로 1 바이트 하나만 읽기보다는, 더 큰 단위로 데이터를 다루는 경우가 많아:

* **32비트 시스템**은 보통 4바이트씩 (긴 워드)
* **64비트 시스템**은 8바이트씩 데이터를 다뤄

그 이유는?

> 🚗 도로에 비유하자면, **한 차선으로 가는 것보다 4차선, 8차선 도로**가 훨씬 빠르게 데이터를 전송할 수 있기 때문이야.

메모리를 주소로 지정할 때는 <mark style="color:blue;">어떤&#x20;대상(1바이트, 4바이트, 8바이트 등)을 원하는지 지정</mark>해야 한다

#### 4) 포플렉스(Pourplex) 구조로 생각해보자!

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

> 바이트 → 듀플렉스(2바이트) → 포플렉스(4바이트) → 8바이트 구조까지…

이렇게 집을 묶어서 더 큰 단위의 블록으로 생각하면,\
CPU는 **한 번에 포플렉스(4바이트)** 단위로 메모리에 접근한다고 보면 돼!

* 32비트 컴퓨터의 메모리 구조를 포플렉스fourplex(집이 4개 연달아 붙어 있는 땅  \
  콩집)가 늘어서 있는 길로 생각할 수도 있어
  * 각 포플렉스에는 다시 `듀플렉스(집이 2개 붙어 있는     땅콩집)`가 **2개** 들어 있고, 각 듀플렉스에는 유닛(한 세대)이 2개 들어 있어.
  * &#x20;이 말은 우리가 각 유    **닛이나 듀플렉스 또는 건물 전체(포플렉스)의 주소를 지정할 수 있다**는 뜻



#### 5) 정렬된 접근 vs 정렬되지 않은 접근

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

메모리를 읽을 때도 규칙이 있어.

**📌 정렬된 접근 (Aligned Access)**

* 예: 4바이트 데이터를 주소 0번에서 읽는다 → 0,1,2,3번 바이트 딱 맞게 읽기
* 빠르고 효율적

**❌ 정렬되지 않은 접근 (Non-Aligned Access)**

* 예: 4바이트 데이터를 주소 5번부터 읽는다 → 5,6,7,8번 바이트인데 **건물 2개에 걸침**
* 비효율적 & 전통적으로 금지되는 경우가 많았음

> 📌 요약: **“정렬된 접근이 빠르고 안전하다”**&#xB294; 개념이 컴퓨터 설계의 중요한 원칙이야!

#### 🔄 5) 리틀 엔디안 vs 빅 엔디안

> 도심을 오가는 버스의 각 자리에는 누가 앉을까?  긴 단어의 경우 가장 왼쪽 자리에 0번 바이트> \
> 가 들어갈까, 3번 바이트가 들어갈까?

사용하는 프로세서에 따라 답이 달라져.

&#x20;두 방식이 모두 사용되기 때문에, 어느 방식을 사용하느냐는 프로세서를 설계하는 사람의 마음에 달렸음

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

큰 데이터를 여러 바이트에 나눠서 저장할 때, **순서를 어떻게 저장할까?**

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

**📌 리틀 엔디안 (Little Endian) – 인텔 방식**

* 인텔 프로세서
* **덜 중요한 바이트가 먼저**
* 예: `0x12345678` → 저장 순서: `78 56 34 12`

**📌 빅 엔디안 (Big Endian) – 모토로라 방식**

* 모토로라Motorola 프로  세서
* **더 중요한 바이트가 먼저**
* 예: `0x12345678` → 저장 순서: `12 34 56 78`

이 차이 때문에 시스템 간 데이터 전송 시에는 **엔디안 변환**을 신경 써야 해. . 엔디안을 무시하면 데이터 순서가 뒤섞일 수 있어.

> 유닉스를 다른 컴퓨터로 옮겼다가 `Unix`가 `nUxi`로 출력된 걸 "눅시 신드롬(Nuxi syndrome)"이라고 불러 😅

#### 🧭 6) 메모리 주소는 프로그램이 직접 지정하지 않는다!

우리가 코드를 작성할 때는 `int a = 12345;`처럼 변수 이름만 쓰잖아?\
근데 컴퓨터 입장에서는 **“a가 어디 있는지”** 알아야 해.

이 과정은 다음과 같이 진행돼:

| 단계                      | 설명                      |
| ----------------------- | ----------------------- |
| **Symbolic Address**    | 사람이 쓴 변수 이름 (예: `a`)    |
| **Relocatable Address** | 컴파일러가 만든 가상의 주소         |
| **Absolute Address**    | 링커가 배치한 프로그램 내의 실제 주소   |
| **Physical Address**    | 운영체제가 RAM 안에서 배정한 물리 주소 |

> 이 주소 변환을 실제로 수행하는 하드웨어가 **MMU (Memory Management Unit)**&#xC57C;!

<mark style="color:red;">프로그램은 0x00000000 ... 0xFFFFFFFF의 물리주소를 그대로 사용할까?</mark>\
**결론은 아니야**

```c
int a = 12345;
```

이는 실행되기 전까지는 디스크에 저장된 일종의 .exe파일일 뿐이야.

* 이게 실행될 때 a라는 변수가 메모리의 어느 주소에 있는지를 할당하는 것은 정해져있지 않아.(symbolic할 뿐이다)
* 이를 지정은 컴파일러가 수행
* 코드의 변수 a와 같은 **symbolic한 변수를 컴파일러가 메모리에 할당가능한 가상의 주소로 바꿔서 어셈블리어로 서술**하는 것야.
* 이 relocable한 주소는 **링커(linker)** 를 통해 absolute address가 정해지고, **로더(loader)**&#xB97C; 통해 프로세스가 물리적으로 어디부터 어디의 메모리 주소(physical address)를 사용할지 할당을 os의 커널을 통해 수행해

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

> symblic address -> relocable address -> absolute address -> physical address

**즉 이 logical한 가상의 주소를 물리주소로 바꿔서 할당하고 접근하는 작업을 os가 수행하면서 주소변환,프로세스간의 메모리 보호 기능도 수행해**

#### 🛡️ 5) 메모리는 보호되어야 한다

> mmu(memory management unit)이라고 하는 물리적인 장치를 이용해 수행해

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption><p><a href="https://velog.io/@ttomy/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C%EC%B2%B4%EA%B3%84%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80">https://velog.io/@ttomy/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C%EC%B2%B4%EA%B3%84%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80</a></p></figcaption></figure>

한 도시 안에 여러 사람이 살아도 서로 **집 안에 무단 침입**하면 안 되잖아?\
컴퓨터도 마찬가지야!

* **메모리 보호 기능: 프로세스가 서로 별도의 메모리 공간을 사용해야하므로 이를 위한 제약을 구현해야 해**
* **프로세스 A가 프로세스 B의 메모리**를 건드리면 안 돼
* 이를 막기 위해 CPU는 **base register와 limit register**를 사용해
  * base: 시작 주소
  * limit: 사용 가능한 범위
  * &#x20;base register와 limit register를 통해 cpu에서 메모리로의 접근 범위를 제한해서 가능하게 해.

> 메모리 보호 기능의 핵심이야! (이 개념은 페이징에서도 다시 나와)

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

#### 📌 요약 정리

| 개념              | 설명                                 |
| --------------- | ---------------------------------- |
| **메모리 주소**      | 바이트 단위로 나열된 ‘집’에 붙은 번호             |
| **워드 단위 접근**    | 32비트 → 4바이트, 64비트 → 8바이트 단위        |
| **정렬된 접근**      | 메모리 블록 경계에 맞게 읽는 것 (속도 ↑)          |
| **리틀 vs 빅 엔디안** | 바이트를 저장하는 순서 차이                    |
| **주의사항**        | 다른 시스템과의 통신이나 네트워크 전송 시 엔디안 고려 필수! |

## 2. 입력과 출력

### 🧃 **컴퓨터는 왜 I/O가 필요할까?**

컴퓨터가 혼자 계산만 하고 외부와 소통하지 않으면 무슨 의미가 있을까?\
우리에게 필요한 건…

* 키보드, 마우스, 센서처럼 정보를 **입력하는 장치**
* 화면, 스피커, 프린터처럼 정보를 **출력하는 장치**

👉 이런 장치들을 통틀어 I/O Device (입출력 장치)라고 해!\
그리고 컴퓨터와 I/O 장치가 소통하는 방법을 **I/O (Input/Output)**&#xC774;라고 부르지.

이들은 컴퓨터의 주변부에 위치하기&#x20;때문에 주변장치peripheral device라고 부르며, 영어로는 퍼리퍼럴peripheral이라고 해.

### 🛣️ **I/O도 메모리처럼 '거리'가 있다!**

이제 도시 비유로 설명해볼게!

* 📍 도시 중심: CPU (도심이라고 했지!)
* 🏠 메모리 거리: RAM 주소들이 줄줄이 있는 구역
* 🏭 I/O 거리: 주변기기들이 위치한 별도의 산업 지구 같은 곳

과거엔 컴퓨터의 물리적 구조가 커서, 메모리 거리와 I/O 거리를 **분리**해서 관리했어.\
&#xNAN;**→ 각자의 버스를 탔던 셈이지!**

그림 4-5처럼 이렇게 나눠져 있었지:

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>



```
[도심]───[메모리 거리 버스]───[메모리들]
     └───[I/O 거리 버스]───[I/O 장치들]
```

과거에는 **메모리 거리에 집이 많지 않았기 때문에**, 제한된 주소를 I/O를 지원하느라고 낭비하는 일은 바람직하지 않았어!

### 💡 그런데 요즘은 왜 I/O도 메모리 거리 안에 들어오게 됐을까?

#### 이유는 바로… “주소 공간이 너무 많아졌기 때문”!

요즘 컴퓨터는 32비트, 64비트라서 주소 공간이 **엄청 넓어졌어.**\
그래서 메모리 거리에 `빈 집(주소)`이 많아졌고,\
<mark style="color:red;">그 빈 집 일부를</mark> <mark style="color:red;"></mark><mark style="color:red;">**I/O 장치에게 할당**</mark><mark style="color:red;">해버린 거야.</mark>

이걸 **Memory-Mapped I/O (메모리 매핑 입출력)**&#xC774;라고 해.

### 🧭 **Memory-Mapped I/O vs Port-Mapped I/O**

| 구분                    | 설명                                      | 비유                        |
| --------------------- | --------------------------------------- | ------------------------- |
| **Memory-Mapped I/O** | I/O 장치도 메모리처럼 주소를 가짐                    | 산업 지구를 도시 안에 포함시킨 느낌      |
| **Port-Mapped I/O**   | I/O 주소를 따로 관리 (예: x86의 `in`, `out` 명령어) | 메모리와 I/O를 아예 다른 거리로 구분한 것 |

요즘 대부분의 시스템은 메모리 맵 방식으로 설계돼. 효율적이니까!

### 🧱 **I/O 슬롯 = I/O를 꽂는 자리**

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

* 컴퓨터에는 표준화된 `I/O 슬롯(slot)`이 있어.
* 이 슬롯마다 일정한 주소 범위가 할당되고,
* **그 범위 내에서만 해당 장치가 활동 가능**해!

> 마치 도시의 산업 구역을 “공장용”, “발전소용”처럼 구역을 나눈 셈이야.

### 🧩 정리하면!

1. **컴퓨터는 외부와 통신하기 위해 I/O 장치가 필요하다.**
2. 과거에는 I/O와 메모리 주소 공간을 분리했지만,
3. 요즘은 **메모리 공간에 I/O 장치를 포함**시켜 관리한다.
4. 이를 **Memory-Mapped I/O**라고 하며,
5. 표준화된 **I/O 슬롯** 구조를 통해 일관성 있게 연결된다.

## 3. 중앙 처리 장치(CPU)

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption><p>CPU</p></figcaption></figure>

중앙 처리 장치(CPU)는 실제 계산을 처리하는 컴퓨터 부품이야. 우리가 사용하는 비유에

* CPU는 도심에 해당
* 다른 모든 요소 : CPU를 지원하는 역할

### 1️⃣ 산술 논리 장치(ALU) : 컴퓨터 도심 한가운데의 계산소

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>





<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

이제 우리가 드디어 도달한 곳은 바로 **CPU의 심장부**, 계산의 중심인 ALU(산술 논리 장치)야!

#### ✅ ALU란?

ALU(Arithmetic Logic Unit)\*\*는\
산술 연산(+, -, shift)과 논리 연산(AND, OR, XOR 등)을 담당하는 장치야.

🧮 쉽게 말해, **컴퓨터 안의 계산기**!\
→ 연산을 수행하는 건 이 ALU가 도맡아 해.

#### 🎯 ALU는 어떤 일을 할까?

ALU는 기본적으로 다음 3가지를 입력으로 받아:

<figure><img src="../../.gitbook/assets/image (273).png" alt=""><figcaption></figcaption></figure>

1. **피연산자 A**
2. **피연산자 B**
3. **연산 코드 (opcode)**: 어떤 연산을 할지 지정

그리고 두 가지 출력을 만들어:

* **연산 결과 (result)**
* **조건 코드 (condition code)**

#### 🛠️ 연산 코드: ALU에게 내리는 명령

ALU는 연산 코드를 보고 어떤 연산을 수행할지 결정해.\
이건 마치 요리사에게 “볶아줘”, “끓여줘” 같은 지시를 내리는 것과 같아.

**예제 연산 코드들 (표 4-1 요약):**

| 명령코드   | 명령어 (니모닉) | 의미                        |
| ------ | --------- | ------------------------- |
| `0000` | `clr`     | 결과를 전부 0으로 (초기화)          |
| `0001` | `set`     | 결과를 전부 1로                 |
| `0010` | `not`     | A의 모든 비트 반전               |
| `0011` | `neg`     | A의 2의 보수 → -A             |
| `0100` | `shl`     | A를 B만큼 왼쪽으로 쉬프트           |
| `0101` | `shr`     | A를 B만큼 오른쪽으로 쉬프트          |
| `1000` | `load`    | B값을 결과로 복사                |
| `1001` | `and`     | A AND B                   |
| `1010` | `or`      | A OR B                    |
| `1011` | `xor`     | A XOR B                   |
| `1100` | `add`     | A + B                     |
| `1101` | `sub`     | A - B                     |
| `1110` | `cmp`     | B - A → 결과는 버리고 조건 코드만 설정 |

#### 📦 조건 코드 레지스터 (CCR, 그림 4-8)

ALU는 결과 외에도 “이 연산 결과가 어떤 특성을 가졌는지” 알려줘.\
이게 바로 **조건 코드**이고, **조건 코드 레지스터**에 저장돼.

| 비트             | 의미       | 설명                 |
| -------------- | -------- | ------------------ |
| `N` (Negative) | 음수면 1    | 결과가 음수면 1          |
| `Z` (Zero)     | 0이면 1    | 결과가 0이면 1          |
| `O` (Overflow) | 오버플로 시 1 | 덧셈/뺄셈 중 자리 넘침 발생 시 |

💡 조건 코드는 `if`, `jump` 같은 조건 분기문에서 사용돼!

#### 🧩 그림 4-9: ALU 내부를 들여다보면?

사실 ALU는 그렇게 신비한 존재가 아니야.

> 그냥 **논리 게이트 + 셀렉터의 조합**일 뿐이야!

그림을 보면 이렇게 구성되어 있어:

* 명령코드에 따라 특정 회로만 활성화되고,
* 선택된 회로가 A, B에 대해 연산을 수행하고,
* 결과가 출력돼!

예를 들어:

* `clr`: 무조건 0을 출력하는 회로
* `not`: A를 반전시키는 회로
* `and`, `or`: A와 B를 논리 연산하는 회로

→ 이 중 하나만 선택돼서 **출력선으로 연결**되는 구조야!

#### 🧠 요약하면?

| 구성 요소     | 설명                             |
| --------- | ------------------------------ |
| 피연산자 A, B | 계산에 사용될 입력 비트                  |
| 연산 코드     | 어떤 연산을 할지 지정하는 코드              |
| 결과        | 연산 후 나오는 비트                    |
| 조건 코드     | 연산 결과에 대한 추가 정보 (음수? 0? 오버플로?) |
| ALU 내부    | 논리 게이트 + 셀렉터 조합                |

#### 🎓 Q\&A로 정리해볼까?

* **Q: ALU는 무슨 일을 해?**\
  A: 숫자 계산, 논리 연산 등 CPU가 계산해야 하는 모든 걸 수행해.
* **Q: 조건 코드 레지스터는 왜 필요해?**\
  A: 결과가 0인지, 음수인지, 오버플로가 났는지를 기록해서 분기문에 쓰기 위함이야!
* **Q: ALU가 신비해 보여. 복잡한 회로일까?**\
  A: 아니, 사실은 `AND`, `OR`, `NOT` 같은 논리 게이트를 잘 조합한 구조일 뿐이야!



## 딥다이브&#x20;

## 1) 정렬되지 않은 접근이 문제가 되는 이유

### 🏙️ 비유로 이해하는 메모리 정렬

#### 🏘️ 건물(포플렉스) = 메모리 블록

컴퓨터 메모리는 일정 크기의 **블록(= 건물)**&#xC73C;로 나뉘어 있어.\
예를 들어, 32비트 컴퓨터라면 하나의 건물(블록)은 **4바이트 = 32비트**로 되어 있고, 이게 <mark style="color:red;">하나의 워드</mark>라고 보면 돼!

즉,

* 주소 0 \~ 3번 바이트 → 0번 건물 (포플렉스 0)
* 주소 4 \~ 7번 바이트 → 1번 건물 (포플렉스 1)
* 주소 8 \~ 11번 바이트 → 2번 건물 (포플렉스 2)\
  이런 식으로 나뉘는 거죠.

#### 🚌 버스 = 데이터 버스

“도심을 오가는 버스”는 **CPU와 메모리 사이를 오가는 데이터 버스**를 말해

> 한 번 버스를 태우면 <mark style="color:red;">한 건물(포플렉스)에서 4바이트를 한꺼번에 실어올 수 있어</mark>\
> &#xNAN;**= 정렬이 맞을 때**의 이상적인 상황!

### 🧩 문제 상황: 정렬이 맞지 않을 때

이제, 어떤 프로그램이 **주소 5번부터 8번까지 4바이트**를 읽으려 한다고 해보자

> 주소 58은 1번 건물(47)과 2번 건물(8\~11)에 걸쳐 있어\
> 즉, **한 건물에서만 데이터를 읽을 수 없어.**

그래서 CPU는…

1. 1번 건물에서 5\~7번 바이트를 읽고
2. 2번 건물에서 8번 바이트를 다시 읽어서
3. 두 번을 나눠 읽고 조립해야 해.

### 🐢 왜 이게 문제일까?

* 메모리 접근이 **두 번** 일어나서 느려짐
* **CPU 내부에서도 조립** 과정이 필요 → 복잡함
* 일부 아키텍처는 이런 접근 자체를 **허용하지 않음**

그래서 요즘 대부분의 시스템은 다음과 같은 규칙을 따른다:

> **"4바이트 데이터를 읽을 땐 반드시 4의 배수 주소에서 시작해야 한다!"**

\= 즉, 주소가 **0, 4, 8, 12…** 여야 한다는 거\
이걸 `정렬(alignment)`이라고 부른다.

### 📌 요약하면!

* 메모리는 워드 단위(4바이트 등)로 정렬된 구조를 가짐
* 버스는 한 번에 하나의 포플렉스(4바이트 블록)만 접근 가능
* **정렬이 맞지 않으면 버스를 두 번 왕복해야 하므로 비효율적**
* → 정렬된 접근이 더 빠르고 안정적이다!
